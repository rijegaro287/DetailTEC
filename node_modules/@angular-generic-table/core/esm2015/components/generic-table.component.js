/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
import { Component, EventEmitter, Input, Output, Renderer2, Type } from '@angular/core';
import { GtMetaPipe } from '../pipes/gt-meta.pipe';
// unsupported: template constraints.
// unsupported: template constraints.
/**
 * @template R, C
 */
export class GenericTableComponent {
    /**
     * @param {?} renderer
     * @param {?} gtMetaPipe
     */
    constructor(renderer, gtMetaPipe) {
        this.renderer = renderer;
        this.gtMetaPipe = gtMetaPipe;
        this.columnWidth = {};
        this.sortOrder = [];
        this.metaInfo = {};
        this.selectedRows = [];
        this.openRows = [];
        this._gtSettings = [];
        this._gtFields = [];
        this.gtDefaultTexts = {
            loading: 'Loading...',
            noData: 'No data',
            noMatchingData: 'No data matching results found',
            noVisibleColumnsHeading: 'No visible columns',
            noVisibleColumns: 'Please select at least one column to be visible.',
            tableInfo: 'Showing #recordFrom to #recordTo of #recordsAfterSearch entries.',
            tableInfoAfterSearch: 'Showing  #recordFrom to #recordTo of #recordsAfterSearch entries (filtered from a total of #recordsAll entries).',
            csvDownload: 'download',
            sortLabel: 'Sort:',
            paginateNext: 'Next page',
            paginatePrevious: 'Previous page',
            inlineEditEdited: 'Press enter to save'
        };
        this.gtTexts = this.gtDefaultTexts;
        this.gtEvent = new EventEmitter();
        this.gtDefaultOptions = {
            csvDelimiter: ';',
            stack: false,
            lazyLoad: false,
            cache: false,
            debounceTime: 200,
            highlightSearch: false,
            rowSelection: false,
            rowSelectionAllowMultiple: true,
            rowExpandAllowMultiple: true,
            numberOfRows: 10,
            reportColumnWidth: false,
            allowUnsorted: true,
            mutateData: true
        };
        this._gtOptions = this.gtDefaultOptions;
        this.store = [];
        this.loading = true;
        this.debounceTimer = null;
        this.lazyAllSelected = false;
        this.gtInfo = {
            pageCurrent: 1,
            pageTotal: 0,
            recordFrom: 0,
            recordTo: 0,
            recordLength: this.gtOptions.numberOfRows,
            recordsAll: 0,
            recordsAfterFilter: 0,
            recordsAfterSearch: 0
        };
        this.refreshPipe = false;
        this.refreshTotals = false;
        this.refreshSorting = false;
        this.refreshFilter = false;
        this.refreshPageArray = false;
        this.editedRows = {};
        this.data = { exportData: [] };
        /**
         * Sort table by object key.
         * @param objectKey - name of key to sort on.
         * @param event - such as key press during sorting.
         */
        this.gtSort = function (objectKey, event) {
            this.inlineEditCancel(); // cancel inline editing
            // loop through current settings
            for (let /** @type {?} */ i = 0; i < this._gtSettings.length; i++) {
                if (this._gtSettings[i].objectKey === objectKey) {
                    // check if sorting is disabled...
                    if (this._gtSettings[i].sort &&
                        this._gtSettings[i].sort.indexOf('disable') !== -1) {
                        // ...if so, exit function without applying any sorting
                        return;
                    }
                    else if (/* check if sorting is undefined... */ typeof this._gtSettings[i]
                        .sort === 'undefined') {
                        // ...is so, set sorting property to enable
                        this._gtSettings[i].sort = 'enable';
                    }
                }
            }
            // check length
            const /** @type {?} */ ctrlKey = event.metaKey || event.ctrlKey;
            const /** @type {?} */ sort = this.sortOrder.slice(0);
            let /** @type {?} */ match = -1;
            let /** @type {?} */ matchDesc = -1;
            let /** @type {?} */ pos = -1;
            // check if property already exits
            for (let /** @type {?} */ i = 0; i < sort.length; i++) {
                const /** @type {?} */ hit = sort[i].indexOf(objectKey);
                if (hit !== -1) {
                    match = this.sortOrder.indexOf(objectKey);
                    matchDesc =
                        match === -1 ? this.sortOrder.indexOf('-' + objectKey) : match;
                    pos = Math.max(match, matchDesc);
                }
            }
            // if ctrl key or meta key is press together with sort...
            if (ctrlKey) {
                if (this.sortOrder[this.sortOrder.length - 1] === '$$gtInitialRowIndex') {
                    this.sortOrder.pop();
                }
                switch (pos) {
                    // ...and property is not sorted before...
                    case -1:
                        // ...add property to sorting
                        this.sortOrder.push(objectKey);
                        break;
                    default:
                        // ...and property is sorted before...
                        if (match !== -1) {
                            // ...change from asc to desc if sorted asc
                            this.sortOrder[pos] = '-' + objectKey;
                        }
                        else if (this.sortOrder.length > 1) {
                            // ...remove sorting if sorted desc
                            if (ctrlKey) {
                                this.sortOrder[pos] = objectKey;
                            }
                            else {
                                this.sortOrder.splice(pos, 1);
                            }
                        }
                        else if (this.sortOrder.length === 1) {
                            // ...set sorting to asc if only sorted property
                            this.sortOrder[pos] = objectKey;
                        }
                        break;
                }
            }
            else {
                /* if ctrl key or meta key is not press together with sort... */
                switch (pos) {
                    // ...and property is not sorted before...
                    case -1:
                        // ...sort by property
                        this.sortOrder = [objectKey];
                        break;
                    default:
                        // ...change from desc to asc and vise versa
                        this.sortOrder =
                            match !== -1
                                ? ['-' + objectKey]
                                : ctrlKey || !this.gtOptions.allowUnsorted
                                    ? [objectKey]
                                    : [];
                        break;
                }
            }
            // update settings object with new sorting information
            for (let /** @type {?} */ i = 0; i < this._gtSettings.length; i++) {
                if (this._gtSettings[i].objectKey === objectKey) {
                    switch (this._gtSettings[i].sort) {
                        // if sorted asc...
                        case 'asc':
                            // ...change to desc
                            this._gtSettings[i].sort = 'desc';
                            break;
                        // if sorted desc...
                        case 'desc':
                            // ...change to asc if it's the only sorted property otherwise remove sorting
                            this._gtSettings[i].sort =
                                (this.sortOrder.length === 1 && sort.length < 2) ||
                                    ctrlKey ||
                                    !this.gtOptions.allowUnsorted
                                    ? 'asc'
                                    : 'enable';
                            break;
                        // if sorting enabled...
                        case 'enable':
                            // ...change to asc
                            this._gtSettings[i].sort = 'asc';
                            break;
                    }
                    this._gtSettings[i].sortOrder =
                        this._gtSettings[i].sort === 'enable'
                            ? this._gtSettings.length - 1
                            : this.sortOrder.indexOf(objectKey) === -1
                                ? this.sortOrder.indexOf('-' + objectKey)
                                : this.sortOrder.indexOf(objectKey);
                }
                else if (this._gtSettings[i].sort &&
                    this._gtSettings[i].sort.indexOf('disable') === -1 &&
                    this.sortOrder.indexOf(this._gtSettings[i].objectKey) === -1 &&
                    this.sortOrder.indexOf('-' + this._gtSettings[i].objectKey) === -1) {
                    this._gtSettings[i].sort = 'enable';
                    this._gtSettings[i].sortOrder = this._gtSettings.length - 1;
                }
            }
            // refresh sorting pipe
            this.refreshSorting = !this.refreshSorting;
            this.refreshPageArray = !this.refreshPageArray;
            // sort by initial sort order as last resort
            this.sortOrder.push('$$gtInitialRowIndex');
            // emit sort event
            this.gtEvent.emit({
                name: 'gt-sorting-applied',
                value: this.sortOrder
            });
        };
        /**
         * Change number of rows to be displayed.
         * @param rowLength - total number of rows.
         * @param reset - should page be reset to first page.
         */
        this.changeRowLength = function (rowLength, reset) {
            let /** @type {?} */ lengthValue = isNaN(parseInt(rowLength, 10))
                ? 0
                : parseInt(rowLength, 10);
            let /** @type {?} */ newPosition = 1;
            if (!lengthValue && this.gtData) {
                lengthValue = this.gtData.length;
            }
            // if reset is not true and we're not lazy loading data...
            if (reset !== true && this._gtOptions.lazyLoad !== true) {
                // ...get current position in record set
                const /** @type {?} */ currentRecord = this.gtInfo.recordLength * (this.gtInfo.pageCurrent - 1);
                const /** @type {?} */ currentPosition = this._gtData.indexOf(this._gtData[currentRecord]) + 1;
                // ...get new position
                newPosition = Math.ceil(currentPosition / lengthValue);
            }
            // change row length
            this.gtInfo.recordLength = lengthValue;
            // go to new position
            this.gtInfo.pageCurrent = newPosition;
            // if lazy loading data...
            if (this._gtOptions.lazyLoad) {
                // ...replace data with place holders for new data
                this._gtData[0] = this.loadingContent(lengthValue);
                // ...empty current store
                this.store = [];
            }
            // this.updateRecordRange();
            this.gtEvent.emit({
                name: 'gt-row-length-changed',
                value: lengthValue
            });
        };
        /**
         * Force a redraw of table rows.
         * As the table uses pure pipes, we need to force a redraw if an object in the array is changed to see the changes.
         */
        this.redraw = function ($event) {
            this.refreshSorting = !this.refreshSorting;
            this.refreshPageArray = !this.refreshPageArray;
            this.refreshPipe = !this.refreshPipe;
        };
        /**
         * Go to next page.
         */
        this.nextPage = function () {
            const /** @type {?} */ page = this.gtInfo.pageCurrent === this.gtInfo.pageTotal
                ? this.gtInfo.pageTotal
                : this.gtInfo.pageCurrent + 1;
            this.goToPage(page);
        };
        /**
         * Go to previous page.
         */
        this.previousPage = function () {
            const /** @type {?} */ page = this.gtInfo.pageCurrent === 1 ? 1 : this.gtInfo.pageCurrent - 1;
            this.goToPage(page);
        };
        /**
         * Request more data (used when lazy loading)
         */
        this.getData = function () {
            // ...emit event requesting for more data
            this.gtEvent.emit({
                name: 'gt-page-changed-lazy',
                value: {
                    pageCurrent: this.gtInfo.pageCurrent,
                    recordLength: this.gtInfo.recordLength
                }
            });
        };
        /**
         * Go to specific page.
         * @param page - page number.
         */
        this.goToPage = function (page) {
            const /** @type {?} */ previousPage = this.gtInfo.pageCurrent;
            this.gtInfo.pageCurrent = page;
            this.inlineEditCancel(); // cancel inline edit
            // if lazy loading and if page contains no records...
            if (this._gtOptions.lazyLoad) {
                // ...if data for current page contains no entries...
                if (this._gtOptions.cache === false ||
                    this._gtData[this.gtInfo.pageCurrent - 1].length === 0) {
                    // ...create temporary content while waiting for data
                    this._gtData[this.gtInfo.pageCurrent - 1] = this.loadingContent(this.gtInfo.recordLength);
                    this.loading = true; // loading true
                }
                // ...if first entry in current page equals our loading placeholder...
                if (this._gtData[this.gtInfo.pageCurrent - 1][0][this.loadingProperty] ===
                    this.gtTexts.loading) {
                    // ...get data
                    clearTimeout(this.debounceTimer);
                    this.debounceTimer = setTimeout(() => {
                        this.getData();
                    }, this._gtOptions.debounceTime);
                }
            }
            // this.updateRecordRange();
            // ...emit page change event
            if (previousPage !== page) {
                this.gtEvent.emit({
                    name: 'gt-page-changed',
                    value: {
                        pageCurrent: this.gtInfo.pageCurrent,
                        pagePrevious: previousPage,
                        recordLength: this.gtInfo.recordLength
                    }
                });
            }
        };
        /**
         * Sort by sort order
         */
        this.getSortOrder = function (a, b) {
            if (a.sortOrder < b.sortOrder) {
                return -1;
            }
            if (a.sortOrder > b.sortOrder || typeof a.sortOrder === 'undefined') {
                return 1;
            }
            return 0;
        };
        /**
         * Sort by column order
         */
        this.getColumnOrder = function (a, b) {
            if (a.columnOrder === undefined) {
                return -1;
            }
            if (a.columnOrder < b.columnOrder) {
                return -1;
            }
            if (a.columnOrder > b.columnOrder) {
                return 1;
            }
            return 0;
        };
        /**
         * Create a deep copy of data
         */
        this.cloneDeep = function (o) {
            return JSON.parse(JSON.stringify(o));
        };
        /**
         * Return property
         */
        this.getProperty = function (array, key) {
            for (let /** @type {?} */ i = 0; i < array.length; i++) {
                if (array[i].objectKey === key) {
                    return array[i];
                }
            }
        };
        this.restructureSorting = function () {
            /**
             * Check and store sort order upon initialization.
             *  This is done by checking sort properties in the settings array of the table, if no sorting is defined
             *  we'll sort the data by the first visible and enabled column in the table(ascending). Please note that actually
             *  sorting have to be done server side when lazy loading data for obvious reasons.
             */
            const /** @type {?} */ sorting = [];
            if (this._gtSettings) {
                // ...sort settings by sort order
                this._gtSettings.sort(this.getSortOrder);
                // ...loop through settings
                for (let /** @type {?} */ i = 0; i < this._gtSettings.length; i++) {
                    const /** @type {?} */ setting = this._gtSettings[i];
                    // ...if sorted ascending...
                    if (setting.sort === 'asc') {
                        // ... add to sorting
                        sorting.push(setting.objectKey);
                    }
                    else if (setting.sort === 'desc') {
                        /* ...else if sorted descending... */ 
                        // ... add to sorting
                        sorting.push('-' + setting.objectKey);
                    }
                }
                // ...if no sorting applied...
                if (sorting.length === 0) {
                    sorting.push('$$gtRowId');
                    /*// ...sort settings by column order
                                    this._gtSettings.sort(this.getColumnOrder);
                    
                                    // ...loop through settings
                                    for (let i = 0; i < this._gtSettings.length; i++) {
                                        const setting = this._gtSettings[i];
                    
                                        // ...if column is enabled and visible...
                                        if (setting.enabled !== false && setting.visible !== false) {
                                            // ...add first match and exit function
                                            this.sortOrder = [this._gtSettings[i].objectKey];
                                            return;
                                        }
                                    }*/
                }
            }
            if (this.sortOrder.length === 0) {
                this.sortOrder = sorting;
            }
        };
        /**
         *  Extend object function.
         */
        this.extend = function (a, b) {
            for (const /** @type {?} */ key in b) {
                if (b.hasOwnProperty(key)) {
                    a[key] = b[key];
                }
            }
            return a;
        };
        this.gtEvent.subscribe(($event) => {
            if ($event.name === 'gt-info') {
                this.updateRecordRange();
            }
            if ($event.name === 'gt-row-updated') {
                this.updateTotals();
            }
        });
    }
    /**
     * @return {?}
     */
    get gtRowComponent() {
        return this._gtRowComponent;
    }
    /**
     * @return {?}
     */
    get hasEdits() {
        return Object.keys(this.editedRows).length > 0;
    }
    /**
     * @return {?}
     */
    get gtOptions() {
        return this._gtOptions;
    }
    /**
     * @return {?}
     */
    get gtTotals() {
        return this._gtTotals;
    }
    /**
     * @return {?}
     */
    get gtFields() {
        return this._gtFields;
    }
    /**
     * @return {?}
     */
    get gtSettings() {
        return this._gtSettings;
    }
    /**
     * @return {?}
     */
    get gtData() {
        return this._gtData;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set gtOptions(value) {
        this._gtOptions = value;
        // if number of rows is passed and if number of rows differs from current record length...
        if (this.gtOptions.numberOfRows &&
            this.gtInfo.recordLength !== this.gtOptions.numberOfRows) {
            // ...update record length and redraw table
            this.gtInfo.recordLength = this.gtOptions.numberOfRows;
            this.redraw();
        }
        // ...extend gtOptions default values with values passed into component
        this._gtOptions = /** @type {?} */ (this.extend(this.gtDefaultOptions, this._gtOptions));
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set gtTotals(value) {
        this._gtTotals = value;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set gtFields(value) {
        this._gtFields = value;
        const /** @type {?} */ COLUMNS_WITH_CLASS_NAMES = this._gtFields
            .map(column => column)
            .filter(column => column.classNames);
        // TODO: remove deprecated warning when setting has been removed
        if (COLUMNS_WITH_CLASS_NAMES.length > 0) {
            console.warn('Field setting "classNames" have been deprecated in favor for "columnClass" and will be removed in the future, please update field settings for column with object key: ' +
                COLUMNS_WITH_CLASS_NAMES[0].objectKey);
        }
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set gtSettings(value) {
        this._gtSettings = value;
        // loop through current settings
        for (let /** @type {?} */ i = 0; i < this._gtSettings.length; i++) {
            // set sort enabled/disabled setting
            this._gtSettings[i].sortEnabled =
                this._gtSettings[i].sortEnabled !== false
                    ? (this._gtSettings[i].sortEnabled = !(this._gtSettings[i].sort &&
                        this._gtSettings[i].sort.indexOf('disable') !== -1))
                    : false;
            // check if sorting is undefined...
            if (typeof this._gtSettings[i].sort === 'undefined') {
                // ...is so, set sorting property to enable
                this._gtSettings[i].sort = 'enable';
            }
            // check if column order is undefined...
            if (typeof this._gtSettings[i].columnOrder === 'undefined' &&
                this._gtSettings[i].enabled !== false) {
                // ...is so, set sorting property to enable
                this._gtSettings[i].columnOrder = this._gtSettings[i - 1]
                    ? this._gtSettings[i - 1].columnOrder + 1
                    : 0;
            }
            // check if column lock settings are undefined...
            if (typeof this._gtSettings[i].lockSettings === 'undefined') {
                // ...if so, set lock settings to false unless field is disabled (enable === false)
                this._gtSettings[i].lockSettings =
                    this._gtSettings[i].enabled === false || false;
            }
        }
        this.restructureSorting();
    }
    /**
     * @param {?} initialData
     * @return {?}
     */
    set gtData(initialData) {
        const /** @type {?} */ data = this._gtOptions.mutateData
            ? [...initialData]
            : this.cloneDeep(initialData);
        if (this.gtOptions.lazyLoad && this.gtInfo) {
            this.gtMetaPipe.transform(data, this.gtOptions.rowIndex, this.gtInfo.pageCurrent - 1, this.gtInfo.recordLength);
            if (this.lazyAllSelected) {
                const /** @type {?} */ UNIQUE_ROWS = this.selectedRows.map(row => row.$$gtRowId);
                data.map(row => {
                    if (UNIQUE_ROWS.indexOf(row.$$gtRowId) === -1) {
                        this.selectedRows.push(row);
                    }
                });
                this._updateMetaInfo(this.selectedRows, 'isSelected', true);
            }
        }
        else {
            this.gtMetaPipe.transform(data, this.gtOptions.rowIndex);
        }
        if (this.gtOptions.rowSelectionInitialState) {
            data.map(row => {
                const /** @type {?} */ selected = typeof this.gtOptions.rowSelectionInitialState === 'function'
                    ? this.gtOptions.rowSelectionInitialState(row)
                    : this.gtOptions.rowSelectionInitialState;
                if (selected) {
                    if (typeof this.metaInfo[row.$$gtRowId] === 'undefined') {
                        this.metaInfo[row.$$gtRowId] = { isSelected: true };
                    }
                    else {
                        this.metaInfo[row.$$gtRowId].isSelected = true;
                    }
                    this.selectedRows.push(row);
                }
            });
        }
        if (this.gtOptions.rowExpandInitialState &&
            this.gtOptions.rowExpandInitialComponent) {
            data.map(row => {
                const /** @type {?} */ expanded = typeof this.gtOptions.rowExpandInitialState === 'function'
                    ? this.gtOptions.rowExpandInitialState(row)
                    : this.gtOptions.rowExpandInitialState;
                this.expandedRow = this.gtOptions.rowExpandInitialComponent;
                if (expanded) {
                    if (typeof this.metaInfo[row.$$gtRowId] === 'undefined') {
                        this.metaInfo[row.$$gtRowId] = { isOpen: true };
                    }
                    else {
                        this.metaInfo[row.$$gtRowId].isOpen = true;
                    }
                }
            });
        }
        this._gtData = data;
    }
    /**
     * @param {?} value
     * @return {?}
     */
    set gtRowComponent(value) {
        console.warn('GtRowComponent has been deprecated and support will be removed in a future release, see https://github.com/hjalmers/angular-generic-table/issues/34');
        this._gtRowComponent = value;
    }
    /**
     * Update record range.
     * @return {?}
     */
    updateRecordRange() {
        this.gtInfo.recordFrom =
            this.gtInfo.recordsAfterSearch === 0
                ? 0
                : (this.gtInfo.pageCurrent - 1) * this.gtInfo.recordLength + 1;
        this.gtInfo.recordTo =
            this.gtInfo.recordsAfterSearch <
                this.gtInfo.pageCurrent * this.gtInfo.recordLength
                ? this.gtInfo.recordsAfterSearch
                : this.gtInfo.pageCurrent * this.gtInfo.recordLength;
    }
    /**
     * Update totals.
     * @return {?}
     */
    updateTotals() {
        this.refreshTotals = !this.refreshTotals;
    }
    /**
     * Get meta data for row.
     * @param {?} row
     * @return {?}
     */
    getRowState(row) {
        return typeof this.metaInfo[row.$$gtRowId] === 'undefined'
            ? null
            : this.metaInfo[row.$$gtRowId];
    }
    /**
     * Expand all rows.
     * @param {?} expandedRow - component to render when rows are expanded.
     * @return {?}
     */
    expandAllRows(expandedRow) {
        this.expandedRow = expandedRow;
        this._toggleAllRowProperty('isOpen', true);
    }
    /**
     * Collapse all rows.
     * @return {?}
     */
    collapseAllRows() {
        this._toggleAllRowProperty('isOpen', false);
    }
    /**
     * Select all rows.
     * @return {?}
     */
    selectAllRows() {
        this._toggleAllRowProperty('isSelected', true);
    }
    /**
     * Deselect all rows.
     * @return {?}
     */
    deselectAllRows() {
        this._toggleAllRowProperty('isSelected', false);
    }
    /**
     * Toggle all rows.
     * @return {?}
     */
    toggleAllRows() {
        if (this._gtOptions.lazyLoad) {
            if (!this.lazyAllSelected || this.selectedRows.length === 0) {
                this.selectAllRows();
                this.lazyAllSelected = true;
            }
            else {
                this.deselectAllRows();
                this.lazyAllSelected = false;
            }
        }
        else {
            if (this.selectedRows.length !== this.gtData.length) {
                this.selectAllRows();
            }
            else {
                this.deselectAllRows();
            }
        }
    }
    /**
     * Toggle row collapsed state ie. expanded/open or collapsed/closed.
     * @param {?} row - row object that should be expanded/collapsed.
     * @param {?=} expandedRow - component to render when row is expanded.
     * @return {?}
     */
    toggleCollapse(row, expandedRow) {
        if (expandedRow) {
            this.expandedRow = expandedRow;
        }
        this._toggleRowProperty(row, 'isOpen');
    }
    /**
     * Toggle row selected state ie. selected or not.
     * @param {?} row - row object that should be selected/deselected.
     * @return {?}
     */
    toggleSelect(row) {
        this._toggleRowProperty(row, 'isSelected');
    }
    /**
     * @param {?} row
     * @param {?} $event
     * @return {?}
     */
    rowClick(row, $event) {
        this.gtEvent.emit({
            name: 'gt-row-clicked',
            value: { row: row, event: $event }
        });
    }
    /**
     * Update row data.
     * @param {?} row - row object that has been edited.
     * @param {?} oldValue - row object before edit.
     * @return {?}
     */
    updateRow(row, oldValue) {
        this._toggleRowProperty(row, 'isUpdated', oldValue);
    }
    /**
     * removes a row from the table
     * @param {?} row - the row object to remove
     * @return {?}
     */
    removeRow(row) {
        if (this.isRowSelected(row)) {
            this.toggleSelect(row);
        }
        const /** @type {?} */ index = this._gtData.indexOf(row);
        this._gtData.splice(index, 1);
    }
    /**
     * check if a row is selected
     * @param {?} row - row object
     * @return {?}
     */
    isRowSelected(row) {
        return (this.metaInfo[row.$$gtRowId] && this.metaInfo[row.$$gtRowId].isSelected);
    }
    /**
     * Update meta info for all rows, ie. isSelected, isOpen.
     * @param {?} array - array that holds rows that need to be updated.
     * @param {?} property - name of property that should be changed/toggled.
     * @param {?} active - should rows be expanded/open, selected.
     * @param {?=} exception - update all rows except this one.
     * @return {?}
     */
    _updateMetaInfo(array, property, active, exception) {
        for (let /** @type {?} */ i = 0; i < array.length; i++) {
            if (!this.metaInfo[array[i].$$gtRowId]) {
                this.metaInfo[array[i].$$gtRowId] = {};
            }
            if (exception && array[i].$$gtRowId === exception.$$gtRowId) {
            }
            else {
                this.metaInfo[array[i].$$gtRowId][property] = active;
            }
        }
    }
    /**
     * Push selected/expanded lazy loaded rows to array with meta data.
     * @param {?} target - array to which rows should be added.
     * @param {?} source - array that holds rows that should be added.
     * @return {?} array with added rows.
     */
    _pushLazyRows(target, source) {
        const /** @type {?} */ UNIQUE_ROWS = target.map(row => row.$$gtRowId);
        for (let /** @type {?} */ i = 0; i < source.length; i++) {
            // only add if not already in list
            if (UNIQUE_ROWS.indexOf(source[i].$$gtRowId) === -1) {
                target.push(source[i]);
            }
        }
        return target;
    }
    /**
     * Toggle meta info for all rows, ie. isSelected, isOpen.
     * @param {?} property - name of property that should be changed/toggled.
     * @param {?} active - should rows be expanded/open, selected.
     * @return {?}
     */
    _toggleAllRowProperty(property, active) {
        let /** @type {?} */ eventName;
        let /** @type {?} */ eventValue;
        switch (property) {
            case 'isOpen':
                // check if multiple expanded rows are allowed...
                if (this._gtOptions.rowExpandAllowMultiple === false) {
                    // ...if not, exit function
                    console.log('feature disabled: enable by setting "rowExpandAllowMultiple = true"');
                    return;
                }
                if (active) {
                    eventName = 'expand-all';
                    this.openRows = this._gtOptions.lazyLoad
                        ? this._pushLazyRows(this.openRows, this._gtData[this.gtInfo.pageCurrent - 1].slice())
                        : this._gtData.slice();
                    this._updateMetaInfo(this.openRows, property, active);
                }
                else {
                    eventName = 'collapse-all';
                    this._updateMetaInfo(this.openRows, property, active);
                    this.openRows = [];
                }
                eventValue = {
                    expandedRows: this.openRows,
                    changedRow: 'all'
                };
                break;
            case 'isSelected':
                // check if multi row selection is allowed...
                if (this._gtOptions.rowSelectionAllowMultiple === false) {
                    // ...if not, exit function
                    console.log('feature disabled: enable by setting "rowSelectionAllowMultiple = true"');
                    return;
                }
                if (active) {
                    eventName = 'select-all';
                    this.selectedRows = this._gtOptions.lazyLoad
                        ? this._pushLazyRows(this.selectedRows, this._gtData[this.gtInfo.pageCurrent - 1].slice())
                        : this._gtData.slice();
                    this._updateMetaInfo(this.selectedRows, property, active);
                }
                else {
                    eventName = 'deselect-all';
                    this._updateMetaInfo(this.selectedRows, property, active);
                    this.selectedRows = [];
                }
                eventValue = {
                    selectedRows: this.selectedRows,
                    changedRow: 'all'
                };
                break;
        }
        this.gtEvent.emit({
            name: 'gt-row-' + eventName,
            value: eventValue
        });
    }
    /**
     * Toggle meta info for row, ie. isSelected, isOpen.
     * @param {?} row - row object.
     * @param {?} property - name of property that should be changed/toggled.
     * @param {?=} propertyValues - optional property values that can be passed.
     * @return {?}
     */
    _toggleRowProperty(row, property, propertyValues) {
        let /** @type {?} */ eventName;
        let /** @type {?} */ eventValue;
        // make sure gtRowId exists on row object
        if (typeof row.$$gtRowId !== 'undefined') {
            // check if meta info exists for row
            if (!this.metaInfo[row.$$gtRowId]) {
                // if not, add object to store meta info
                this.metaInfo[row.$$gtRowId] = {};
            }
            switch (property) {
                case 'isOpen':
                    const /** @type {?} */ opened = this.metaInfo[row.$$gtRowId][property];
                    // check if multiple expanded rows are allowed...
                    if (this._gtOptions.rowExpandAllowMultiple === false) {
                        // ...if not, collapse all rows except current row
                        this._updateMetaInfo(this.openRows, property, false, row);
                        this.openRows = [];
                    }
                    // check if row is expanded
                    if (!opened) {
                        eventName = 'expand';
                        // add row to expanded rows
                        this.openRows.push(row);
                    }
                    else {
                        eventName = 'collapse';
                        // loop through expanded rows...
                        for (let /** @type {?} */ i = 0; i < this.openRows.length; i++) {
                            // if expanded row equals passed row...
                            if (this.openRows[i].$$gtRowId === row.$$gtRowId) {
                                // ...remove row from expanded rows...
                                this.openRows.splice(i, 1);
                                // ...and exit loop
                                break;
                            }
                        }
                    }
                    eventValue = {
                        expandedRows: this.openRows,
                        changedRow: row
                    };
                    break;
                case 'isSelected':
                    const /** @type {?} */ selected = this.metaInfo[row.$$gtRowId][property];
                    // check if multi row selection is allowed...
                    if (this._gtOptions.rowSelectionAllowMultiple === false) {
                        // ...if not, deselect all rows except current row
                        this._updateMetaInfo(this.selectedRows, property, false, row);
                        this.selectedRows = [];
                    }
                    // check if row is selected
                    if (!selected) {
                        eventName = 'select';
                        // add row to selected rows
                        this.selectedRows.push(row);
                    }
                    else {
                        if (this.gtOptions.lazyLoad && this.lazyAllSelected) {
                            this.lazyAllSelected = false;
                        }
                        eventName = 'deselect';
                        // loop through selected rows...
                        for (let /** @type {?} */ i = 0; i < this.selectedRows.length; i++) {
                            // if selected row equals passed row...
                            if (this.selectedRows[i].$$gtRowId === row.$$gtRowId) {
                                // ...remove row from selected rows...
                                this.selectedRows.splice(i, 1);
                                // ...and exit loop
                                break;
                            }
                        }
                    }
                    eventValue = {
                        selectedRows: this.selectedRows,
                        changedRow: row
                    };
                    break;
                case 'isUpdated':
                    eventName = 'updated';
                    const /** @type {?} */ oldValue = propertyValues;
                    // check if edit object exists for row
                    if (typeof this.metaInfo[row.$$gtRowId][property] === 'undefined') {
                        this.metaInfo[row.$$gtRowId][property] = {
                            originalValue: oldValue,
                            oldValue: oldValue,
                            newValue: row
                        };
                    }
                    else {
                        this.metaInfo[row.$$gtRowId][property].oldValue = oldValue;
                        this.metaInfo[row.$$gtRowId][property].newValue = row;
                    }
                    eventValue = this.metaInfo[row.$$gtRowId][property];
                    this.redraw();
                    this.inlineEditCancel(row);
                    // this.gtData = [...this.gtData.map((r) => { return{...r}; })];
                    break;
            }
            this.gtEvent.emit({
                name: 'gt-row-' + eventName,
                value: eventValue
            });
            if (property !== 'isUpdated') {
                this.metaInfo[row.$$gtRowId][property] = !this.metaInfo[row.$$gtRowId][property];
            }
        }
    }
    /**
     * Update column.
     * @param {?} $event - key up event.
     * @param {?} row - row object.
     * @param {?} column - column object.
     * @return {?}
     */
    gtUpdateColumn($event, row, column) {
        this._editRow(row, column);
    }
    /**
     * Dropdown select.
     * @param {?} row - row object.
     * @param {?} column - column object.
     * @return {?}
     */
    gtDropdownSelect(row, column) {
        const /** @type {?} */ oldValue = Object.assign({}, row);
        row[column.objectKey] = column.renderValue;
        this.updateRow(row, oldValue);
    }
    /**
     * @param {?} row
     * @param {?} column
     * @return {?}
     */
    _editRow(row, column) {
        const /** @type {?} */ OBJECT_KEY = column.objectKey; // declare object key which contains changes
        // check if cell has changed value
        column.edited = row[column.objectKey] !== column.renderValue;
        // check if row contains changes...
        if (!this.editedRows[row.$$gtRowId]) {
            // if not, create an object for the changed row
            this.editedRows[row.$$gtRowId] = {
                changes: {},
                // create placeholder for changes
                row: row // store reference to the row that should be updated
            };
        }
        // store changed column under changes if it has been edited
        if (column.edited) {
            this.editedRows[row.$$gtRowId].changes[OBJECT_KEY] = column;
        }
        else {
            // delete change object if column is unchanged
            delete this.editedRows[row.$$gtRowId].changes[OBJECT_KEY];
            // check how many columns have been changed
            const /** @type {?} */ CHANGED_COLUMNS = Object.keys(this.editedRows[row.$$gtRowId].changes).length;
            if (CHANGED_COLUMNS === 0) {
                // delete row from edited rows if no columns have been edited
                delete this.editedRows[row.$$gtRowId];
            }
        }
        // if no listener is present...
        if (!this.globalInlineEditListener) {
            // ...listen for update event
            this._listenForKeydownEvent();
        }
    }
    /**
     * Listen for key down event - listen for key down event during inline edit.
     * @return {?}
     */
    _listenForKeydownEvent() {
        // add global listener for key down events
        this.globalInlineEditListener = this.renderer.listen('document', 'keydown', $event => {
            switch ($event.key) {
                case 'Enter':
                    // update data object
                    this.inlineEditUpdate();
                    break;
                case 'Escape':
                    // cancel
                    this.inlineEditCancel();
                    break;
            }
        });
    }
    /**
     * Inline edit update - accept changes and update row values.
     * @return {?}
     */
    inlineEditUpdate() {
        // loop through rows that have been edited
        Object.keys(this.editedRows).map(key => {
            const /** @type {?} */ ROW = this.editedRows[key].row; // row to update
            const /** @type {?} */ CHANGES = this.editedRows[key].changes; // changes to the row
            // loop through changes in row
            Object.keys(CHANGES).map(objectKey => {
                const /** @type {?} */ oldValue = Object.assign({}, ROW);
                ROW[objectKey] = CHANGES[objectKey].renderValue; // update data value
                this.updateRow(ROW, oldValue); // update meta info for row and send event
                CHANGES[objectKey].edited = false; // disable edit mode
            });
        });
        // clear rows marked as edited as the rows have been updated
        this.editedRows = {};
        // remove listener
        this._stopListeningForKeydownEvent();
    }
    /**
     * Inline edit cancel - cancel and reset inline edits.
     * @param {?=} row
     * @return {?}
     */
    inlineEditCancel(row) {
        if (row) {
            delete this.editedRows[row.$$gtRowId];
            // remove listener
            this._stopListeningForKeydownEvent();
            return;
        }
        // loop through rows that have been edited
        Object.keys(this.editedRows).map(key => {
            const /** @type {?} */ ROW = this.editedRows[key].row; // row to update
            const /** @type {?} */ CHANGES = this.editedRows[key].changes; // changes to the row
            // loop through changes in row
            Object.keys(CHANGES).map(objectKey => {
                CHANGES[objectKey].renderValue = ROW[objectKey]; // reset rendered value
                CHANGES[objectKey].edited = false; // disable edit mode
            });
        });
        // clear rows marked as edited as the rows have been updated
        this.editedRows = {};
        // remove listener
        this._stopListeningForKeydownEvent();
    }
    /**
     * Stop listening for key down event - stop listening for key down events passed during inline edit.
     * @return {?}
     */
    _stopListeningForKeydownEvent() {
        if (this.globalInlineEditListener) {
            this.globalInlineEditListener();
            this.globalInlineEditListener = null;
        }
    }
    /**
     * Apply filter(s).
     * @param {?} filter - object containing key value pairs, where value should be array of values.
     * @return {?}
     */
    gtApplyFilter(filter) {
        this.gtInfo.filter = filter;
        // go to first page
        this.goToPage(1);
        this.updateTotals();
    }
    /**
     * Clear/remove applied filter(s).
     * @return {?}
     */
    gtClearFilter() {
        this.gtInfo.filter = false;
        this.updateTotals();
        // this.updateRecordRange();
    }
    /**
     * Search
     * @param {?} value - string containing one or more words
     * @return {?}
     */
    gtSearch(value) {
        this.gtInfo.searchTerms = value;
        // always go to first page when searching
        this.goToPage(1);
        this.updateTotals();
    }
    /**
     * Add rows
     * @param {?} rows - rows to add
     * @return {?} new data array.
     */
    gtAdd(rows) {
        this.gtData = [...this.gtData, ...rows];
        return [...this.gtData];
    }
    /**
     * Delete row
     * @param {?} objectKey - object key you want to find match with
     * @param {?} value - the value that should be deleted
     * @param {?=} match - all: delete all matches, first: delete first match (default)
     * @return {?} new data array.
     */
    gtDelete(objectKey, value, match = 'first') {
        if (match === 'first') {
            for (let /** @type {?} */ i = 0; i < this.gtData.length; i++) {
                if (this.gtData[i][objectKey] === value) {
                    if (this.isRowSelected(this.gtData[i])) {
                        this.toggleSelect(this.gtData[i]);
                    }
                    this.gtData.splice(i, 1);
                    this.gtData = [...this.gtData];
                    if (match === 'first') {
                        break;
                    }
                }
            }
        }
        else {
            for (let /** @type {?} */ i = this.gtData.length; i > 0; i--) {
                if (this.gtData[i - 1][objectKey] === value) {
                    if (this.isRowSelected(this.gtData[i - 1])) {
                        this.toggleSelect(this.gtData[i - 1]);
                    }
                    this.gtData.splice(i - 1, 1);
                    this.gtData = [...this.gtData];
                }
            }
        }
        return [...this.gtData];
    }
    /**
     * Create store to hold previously loaded records.
     * @param {?} records - total number of records in store.
     * @param {?} perPage - how many records to show per page.
     * @return {?} a nested array to hold records per page.
     */
    createStore(records, perPage) {
        const /** @type {?} */ stores = Math.ceil(records / perPage);
        const /** @type {?} */ store = [];
        for (let /** @type {?} */ i = 0; i < stores; i++) {
            store[i] = [];
        }
        return store;
    }
    /**
     * Create placeholders for rows while loading data from back-end.
     * @param {?} perPage - how many records to show per page.
     * @return {?} an array containing empty records to be presented while fetching real data.
     */
    loadingContent(perPage) {
        // create row object
        const /** @type {?} */ rowObject = {
            $$loading: true
        };
        let /** @type {?} */ order = 0;
        // sort settings by column order
        this._gtSettings.sort(this.getColumnOrder);
        // loop through all settings objects...
        for (let /** @type {?} */ i = 0; i < this._gtSettings.length; i++) {
            const /** @type {?} */ setting = this._gtSettings[i];
            // ...if column is visible and enabled...
            if (setting.visible !== false && setting.enabled !== false) {
                // ...if first column, set value to loading text otherwise leave it empty
                if (order === 0) {
                    rowObject[setting.objectKey] = this.gtTexts.loading;
                    this.loadingProperty = setting.objectKey;
                }
                else {
                    rowObject[setting.objectKey] = '';
                }
                order++;
            }
            else {
                rowObject[setting.objectKey] = '';
            }
        }
        // create content placeholder
        const /** @type {?} */ contentPlaceholder = [];
        // create equal number of rows as rows per page
        for (let /** @type {?} */ i = 0; i < perPage; i++) {
            // ...add temporary row object
            contentPlaceholder.push(rowObject);
        }
        return contentPlaceholder;
    }
    /**
     * Export data as CSV
     * @param {?=} fileName - optional file name (overrides default file name).
     * @param {?=} useBOM - use BOM (byte order marker).
     * @return {?}
     */
    exportCSV(fileName, useBOM = false) {
        const /** @type {?} */ data = this.data.exportData;
        let /** @type {?} */ csv = '';
        const /** @type {?} */ BOM = '\uFEFF';
        // csv export headers
        for (let /** @type {?} */ i = 0; i < this._gtSettings.length; i++) {
            if (this._gtSettings[i].export !== false) {
                // get field settings
                const /** @type {?} */ fieldSetting = this.getProperty(this._gtFields, this._gtSettings[i].objectKey);
                // get export value, if exportHeader string is defined use it otherwise returns name
                const /** @type {?} */ exportValue = fieldSetting.exportHeader
                    ? fieldSetting.exportHeader
                    : fieldSetting.name;
                csv += this.escapeCSVDelimiter(exportValue);
                csv += this.getProperty(this._gtFields, this._gtSettings[i].objectKey)
                    .name;
                if (i < this._gtSettings.length - 1) {
                    csv += this._gtOptions.csvDelimiter;
                }
            }
        }
        // csv export body
        data.forEach(row => {
            csv += '\n';
            for (let /** @type {?} */ i = 0; i < this._gtSettings.length; i++) {
                if (this._gtSettings[i].export !== false) {
                    // get field settings
                    const /** @type {?} */ fieldSetting = this.getProperty(this._gtFields, this._gtSettings[i].objectKey);
                    // get export value, if export function is defined use it otherwise check for value function and as a last resort export raw data
                    const /** @type {?} */ exportValue = fieldSetting.export && typeof fieldSetting.export === 'function'
                        ? fieldSetting.export(row)
                        : fieldSetting.value && typeof fieldSetting.value === 'function'
                            ? fieldSetting.value(row)
                            : row[this._gtSettings[i].objectKey];
                    csv += this.escapeCSVDelimiter(exportValue);
                    if (i < this._gtSettings.length - 1) {
                        csv += this._gtOptions.csvDelimiter;
                    }
                }
            }
        });
        const /** @type {?} */ blob = new Blob([(useBOM ? BOM : '') + csv], {
            type: 'text/csv;charset=utf-8'
        });
        if (window.navigator.msSaveOrOpenBlob) {
            navigator.msSaveOrOpenBlob(blob, fileName ? fileName + '.csv' : this.gtTexts.csvDownload + '.csv');
        }
        else {
            const /** @type {?} */ link = document.createElement('a');
            link.style.display = 'none';
            document.body.appendChild(link);
            if (link.download !== undefined) {
                link.setAttribute('href', 'data:text/csv;charset=utf-8,' +
                    encodeURIComponent((useBOM ? BOM : '') + csv)); // URL.createObjectURL(blob));
                link.setAttribute('download', fileName ? fileName + '.csv' : this.gtTexts.csvDownload + '.csv');
                document.body.appendChild(link);
                link.click();
            }
            else {
                csv = 'data:text/csv;charset=utf-8,' + (useBOM ? BOM : '') + csv;
                window.open(encodeURIComponent(csv));
            }
            document.body.removeChild(link);
        }
        // emit export event
        this.gtEvent.emit({
            name: 'gt-exported-csv',
            value: fileName ? fileName : this.gtTexts.csvDownload + '.csv'
        });
    }
    /**
     * Escape export value using double quotes (") if export value contains delimiter
     * @param {?} value Value to be escaped
     * @return {?}
     */
    escapeCSVDelimiter(value) {
        return typeof value === 'string' &&
            value.indexOf(this._gtOptions.csvDelimiter) !== -1
            ? '"' + value + '"'
            : value;
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        // if number of row to display from start is set to null or 0...
        if (!this.gtOptions.numberOfRows) {
            // ...change row length
            this.changeRowLength(this.gtOptions.numberOfRows);
        }
        this.restructureSorting();
    }
    /**
     * @param {?} changes
     * @return {?}
     */
    ngOnChanges(changes) {
        // if gt texts have changed...
        if (changes['gtTexts']) {
            // ...extend gtOptions default values with values passed into component
            this.gtTexts = /** @type {?} */ (this.extend(this.gtDefaultTexts, this.gtTexts));
        }
        // if lazy loading data and paging information is available...
        if (this.gtOptions.lazyLoad && this.gtInfo) {
            // ...calculate total number of pages
            this.gtInfo.pageTotal = Math.ceil(this.gtInfo.recordsAfterSearch / this.gtInfo.recordLength);
            // ...declare store position
            const /** @type {?} */ storePosition = this.gtInfo.pageCurrent - 1;
            // ...and if store is empty or page length has changed...
            if (this.store.length === 0 ||
                this.store[0].length !== this.gtInfo.recordLength) {
                // ...create store
                this.store = this.createStore(this.gtInfo.recordsAfterSearch, this.gtInfo.recordLength);
            }
            // ...store retrieved data in store at store position
            this.store[storePosition] = this.gtData;
            this.gtInfo.visibleRecords = [...this.gtData]; // add visible rows
            // replace data with store
            this._gtData = this.store;
            this.loading = false;
            this.updateRecordRange();
            this.gtEvent.emit({
                name: 'gt-info',
                value: this.gtInfo
            });
        }
        else if (this._gtData &&
            this._gtData.length >= 0 &&
            changes['gtData'] &&
            changes['gtData'].previousValue) {
            this.loading = false;
        }
        else if (changes['gtData'] &&
            changes['gtData'].firstChange &&
            this._gtData &&
            this._gtData.length > 0) {
            this.loading = false;
        }
    }
    /**
     * @param {?} index
     * @param {?} item
     * @return {?}
     */
    trackByFn(index, item) {
        return item.$$gtRowId;
    }
    /**
     * @param {?} index
     * @param {?} item
     * @return {?}
     */
    trackByColumnFn(index, item) {
        return item.objectKey;
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        // remove listener
        this._stopListeningForKeydownEvent();
    }
}
GenericTableComponent.decorators = [
    { type: Component, args: [{
                selector: 'generic-table',
                template: `<table class="table" ngClass="{{gtClasses}} {{gtOptions.stack ? 'table-stacked':''}}"
       *ngIf="gtFields && gtSettings && (gtFields | gtVisible:gtSettings:refreshPipe).length > 0">
  <thead>
  <tr>
    <th class="gt-sort-label" *ngIf="gtOptions.stack">{{gtTexts.sortLabel}}</th>
    <th *ngFor="let column of gtSettings | gtVisible:gtSettings:refreshPipe"
        ngClass="{{column.objectKey +'-column' | dashCase}} {{gtFields | gtProperty:column.objectKey:'classNames'}} {{column.sortEnabled ? 'sort-'+column.sort:''}} {{column.sortEnabled && column.sortOrder >= 0  ? 'sort-order-'+column.sortOrder:''}} {{ gtFields | gtColumnClass:column }}"
        (click)="column.sortEnabled ? gtSort(column.objectKey,$event):'';">
      <span *ngIf="!(gtFields | gtProperty:column.objectKey:'header')">{{gtFields | gtProperty:column.objectKey:'name'}}</span>
      <gt-custom-component-factory *ngIf="(gtFields | gtProperty:column.objectKey:'header')"
                                   [type]="(gtFields | gtProperty:column.objectKey:'header')?.type"
                                   [injector]="(gtFields | gtProperty:column.objectKey:'header')?.injector"
                                   [column]="gtFields | gtProperty:column.objectKey:'name'"></gt-custom-component-factory>
      <gt-checkbox *ngIf="(gtFields | gtProperty:column.objectKey:'columnComponent')?.type === 'checkbox'" [checked]="(gtOptions.lazyLoad ? lazyAllSelected:selectedRows.length === gtData.length)" (changed)="toggleAllRows()"></gt-checkbox>
    </th>
  </tr>
  </thead>
  <ng-template
    [ngIf]="gtTotals && (gtOptions.lazyLoad === false ? (gtData | gtFilter:gtInfo.filter:gtInfo:refreshFilter:gtData.length | gtSearch:gtInfo.searchTerms:gtInfo:gtSettings:gtFields:gtData.length).length > 0 : gtData.length > 0)">
    <thead class="gt-totals">
    <tr *ngFor="let total of gtTotals | gtTotalsPosition">
      <td *ngFor="let column of gtSettings | gtVisible:gtSettings:refreshPipe;let i = index;"
          ngClass="{{column.objectKey +'-totals-column' | dashCase}} {{gtFields | gtProperty:column.objectKey:'classNames'}} {{ gtFields | gtColumnClass:column }}">
        <span *ngIf="i === 0" class="float-left">{{total.name}}</span><span
        [innerHTML]="total.fields[column.objectKey] | gtTotals:(total.update === false || gtOptions.lazyLoad === true) ? gtData:(gtData | gtFilter:gtInfo.filter:gtInfo:refreshFilter:gtData.length | gtSearch:gtInfo.searchTerms:gtInfo:gtSettings:gtFields:gtData.length):column.objectKey:refreshTotals"></span>
      </td>
    </tr>
    </thead>
    <tfoot class="gt-totals">
    <tr *ngFor="let total of gtTotals | gtTotalsPosition:'footer'">
      <td *ngFor="let column of gtSettings | gtVisible:gtSettings:refreshPipe;let i = index;"
          ngClass="{{column.objectKey +'-totals-column' | dashCase}} {{gtFields | gtProperty:column.objectKey:'classNames'}} {{ gtFields | gtColumnClass:column }}">
        <span *ngIf="i === 0" class="float-left">{{total.name}}</span><span
        [innerHTML]="total.fields[column.objectKey] | gtTotals:(total.update === false || gtOptions.lazyLoad === true) ? gtData:(gtData | gtFilter:gtInfo.filter:gtInfo:refreshFilter:gtData.length | gtSearch:gtInfo.searchTerms:gtInfo:gtSettings:gtFields:gtData.length):column.objectKey:refreshTotals"></span>
      </td>
    </tr>
    </tfoot>
  </ng-template>
  <tbody *ngIf="gtData && gtInfo">
  <ng-template class="table-rows" ngFor let-row let-last="last" [ngForTrackBy]="trackByFn"
               [ngForOf]="gtOptions.lazyLoad && gtInfo ? (gtData[gtInfo.pageCurrent-1]) : (gtData | gtFilter:gtInfo.filter:gtInfo:refreshFilter:gtData.length | gtSearch:gtInfo.searchTerms:gtInfo:gtSettings:gtFields:gtData.length | gtOrderBy:sortOrder:gtFields:refreshSorting:gtData.length | gtChunk:gtInfo:gtInfo.recordLength:gtInfo.pageCurrent:refreshPageArray:gtData.length:gtEvent:data | gtRowClass:gtFields)">
    <tr [ngClass]="{'row-selected':metaInfo[row.$$gtRowId]?.isSelected, 'row-open':metaInfo[row.$$gtRowId]?.isOpen, 'row-loading':loading, 'row-expandable':gtRowComponent}"
        class="{{row.$$gtRowClass}}"
        (click)="gtOptions.rowSelection ? toggleSelect(row):rowClick(row, $event)">
      <td *ngFor="let column of row | gtRender:gtSettings:gtFields:refreshPipe:loading:gtOptions.highlightSearch:gtInfo.searchTerms;trackBy:trackByColumnFn"
          ngClass="{{column.objectKey +'-column' | dashCase}} {{gtFields | gtProperty:column.objectKey:'classNames'}} {{(gtFields | gtProperty:column.objectKey:'inlineEdit') ? 'gt-inline-edit':''}} {{column.edited ? 'gt-edited':''}} {{ gtFields | gtColumnClass:column:row }}">
                        <span class="gt-row-label"
                              *ngIf="gtOptions.stack">{{(gtFields | gtProperty:column.objectKey:'stackedHeading') ? (gtFields | gtProperty:column.objectKey:'stackedHeading') : (gtFields | gtProperty:column.objectKey:'name')}}</span>
        <gt-custom-component-factory *ngIf="column.columnComponent && column.columnComponent.type !== 'checkbox'" class="gt-row-content"
                                     [type]="column.columnComponent.type"
                                     [injector]="column.columnComponent.injector" [row]="row"
                                     [column]="column" (redrawEvent)="redraw($event)"
                                     [searchTerms]="gtInfo.searchTerms"  (searchEvent)="redraw($event)"
                                     (click)="column.click ? column.click(row,column,$event):'';column.expand ? toggleCollapse(row, column.expand):''"></gt-custom-component-factory>
        <span *ngIf="!column.columnComponent && (!(gtFields | gtProperty:column.objectKey:'inlineEdit') || ((gtFields | gtProperty:column.objectKey:'inlineEdit')?.active | gtIsObservable) && !((gtFields | gtProperty:column.objectKey:'inlineEdit')?.active | async) || (!((gtFields | gtProperty:column.objectKey:'inlineEdit')?.active | gtIsObservable) && !((gtFields | gtProperty:column.objectKey:'inlineEdit')?.active | gtIsEditable:row:refreshPipe)))"
              class="gt-row-content" [innerHTML]="column.renderValue"
              (click)="column.click ? column.click(row,column,$event):'';column.expand ? toggleCollapse(row, column.expand):''"></span>
        <ng-template
          [ngIf]="!column.columnComponent && (((gtFields | gtProperty:column.objectKey:'inlineEdit')?.active | gtIsObservable) && ((gtFields | gtProperty:column.objectKey:'inlineEdit')?.active | async) || ((gtFields | gtProperty:column.objectKey:'inlineEdit')?.active | gtIsEditable:row:refreshPipe))">
          <ng-template [ngIf]="([true,'email','number','password', 'text'].indexOf((gtFields | gtProperty:column.objectKey:'inlineEdit').type) !== -1) || !(gtFields | gtProperty:column.objectKey:'inlineEdit').type">
            <input class="inline-edit" [attr.type]="!(gtFields | gtProperty:column.objectKey:'inlineEdit').type ? 'text' : !((gtFields | gtProperty:column.objectKey:'inlineEdit').type | gtIsObservable) ? (gtFields | gtProperty:column.objectKey:'inlineEdit').type:(gtFields | gtProperty:column.objectKey:'inlineEdit').type | async" [(ngModel)]="column.renderValue"
                   (input)="gtUpdateColumn($event,row, column)">
            <span class="gt-inline-edit-notice">{{gtTexts.inlineEditEdited}}</span>
          </ng-template>
          <gt-dropdown
            *ngIf="(((gtFields | gtProperty:column.objectKey:'inlineEdit').type) && ((gtFields | gtProperty:column.objectKey:'inlineEdit').type).length > 0) || ((gtFields | gtProperty:column.objectKey:'inlineEdit').type | gtIsObservable)"
            [options]="!((gtFields | gtProperty:column.objectKey:'inlineEdit').type | gtIsObservable) ? (gtFields | gtProperty:column.objectKey:'inlineEdit').type : (gtFields | gtProperty:column.objectKey:'inlineEdit').type | async"
            [id]="'_' + row.$$gtRowId + '_' + column.objectKey"
            [(selected)]="column.renderValue" (selectedChange)="gtDropdownSelect(row, column)">Add
            inline editing module
          </gt-dropdown>
        </ng-template>
        <ng-template [ngIf]="!column.columnComponent && !((gtFields | gtProperty:column.objectKey:'inlineEdit')?.active) ">
          <ng-template
            [ngIf]="[true,'email','number','password'].indexOf(gtFields | gtProperty:column.objectKey:'inlineEdit') !== -1">
            <input class="inline-edit" [attr.type]="(gtFields | gtProperty:column.objectKey:'inlineEdit') === true ? 'text':(gtFields | gtProperty:column.objectKey:'inlineEdit')" [(ngModel)]="column.renderValue"
                   (input)="gtUpdateColumn($event,row, column)">
            <span class="gt-inline-edit-notice">{{gtTexts.inlineEditEdited}}</span>
          </ng-template>
          <gt-dropdown
            *ngIf="(gtFields | gtProperty:column.objectKey:'inlineEdit') && [true,'email','number','password'].indexOf(gtFields | gtProperty:column.objectKey:'inlineEdit') === -1"
            [options]="gtFields | gtProperty:column.objectKey:'inlineEdit'"
            [id]="'_' + row.$$gtRowId + '_' + column.objectKey"
            [(selected)]="column.renderValue" (selectedChange)="gtDropdownSelect(row, column)">Add
            inline editing module
          </gt-dropdown>
        </ng-template>
        <gt-checkbox *ngIf="column.columnComponent && column.columnComponent.type === 'checkbox'" [checked]="metaInfo[row.$$gtRowId]?.isSelected" (changed)="toggleSelect(row)"></gt-checkbox>
      </td>
    </tr>
    <tr class="row-expanded" *ngIf="metaInfo[row.$$gtRowId]?.isOpen">
      <td [attr.colspan]="(gtFields | gtVisible:gtSettings:refreshPipe).length">
        <gt-expanding-row [row]="row"
                          [type]="expandedRow.component ? expandedRow.component:gtRowComponent"
                          [columnWidth]="columnWidth"
                          [gtFields]="gtFields"
                          [gtOptions]="gtOptions"
                          [gtEvent]="gtEvent"
                          [gtInfo]="gtInfo"
                          [gtSettings]="gtSettings"
                          [data]="expandedRow.data ? expandedRow.data:row"
                          (redrawEvent)="redraw($event)"
                          (toggleRowEvent)="toggleCollapse($event)"></gt-expanding-row>
      </td>
    </tr>
    <tr *ngIf="gtOptions.reportColumnWidth && last">
      <td style="padding: 0; border:none;"
          *ngFor="let column of gtSettings | gtVisible:gtSettings:refreshPipe" gtColumnWidth
          [objectKey]="column.objectKey" [widths]="columnWidth"></td>
    </tr>
  </ng-template>
  <tr *ngIf="gtInfo.pageTotal === 0 && (gtInfo.searchTerms || gtInfo.filter) && !loading">
    <td class="gt-no-matching-results" [attr.colspan]="(gtFields | gtVisible:gtSettings).length">
      {{gtTexts.noMatchingData}}
    </td>
  </tr>
  <tr *ngIf="gtInfo.pageTotal === 0 && !(gtInfo.searchTerms || gtInfo.filter) && !loading">
    <td class="gt-no-results" [attr.colspan]="(gtFields | gtVisible:gtSettings).length">{{gtTexts.noData}}
    </td>
  </tr>
  <tr *ngIf="gtInfo.pageTotal === 0 && loading">
    <td class="gt-loading-data" [attr.colspan]="(gtFields | gtVisible:gtSettings).length">{{gtTexts.loading}}</td>
  </tr>
  </tbody>
</table>
<table class="table" ngClass="{{gtClasses}} {{gtOptions.stack ? 'table-stacked':''}}"
       *ngIf="gtFields && gtSettings && (gtFields | gtVisible:gtSettings:refreshPipe).length === 0">
  <thead>
  <tr>
    <th class="gt-no-visible-columns">{{gtTexts.noVisibleColumnsHeading}}</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td class="gt-no-visible-columns">{{gtTexts.noVisibleColumns}}</td>
  </tr>
  </tbody>
</table>
<table class="table" ngClass="{{gtClasses}} {{gtOptions.stack ? 'table-stacked':''}}"
       *ngIf="!gtFields || !gtSettings">
  <thead>
  <tr>
    <th class="gt-loading-config">&nbsp;</th>
  </tr>
  </thead>
  <tbody>
  <tr>
    <td class="gt-loading-config">&nbsp;</td>
  </tr>
  </tbody>
</table>
`
            },] },
];
/** @nocollapse */
GenericTableComponent.ctorParameters = () => [
    { type: Renderer2, },
    { type: GtMetaPipe, },
];
GenericTableComponent.propDecorators = {
    "gtOptions": [{ type: Input },],
    "gtTotals": [{ type: Input },],
    "gtFields": [{ type: Input },],
    "gtSettings": [{ type: Input },],
    "gtData": [{ type: Input },],
    "gtRowComponent": [{ type: Input },],
    "gtTexts": [{ type: Input },],
    "gtClasses": [{ type: Input },],
    "gtEvent": [{ type: Output },],
    "gtInfo": [{ type: Input },],
};
function GenericTableComponent_tsickle_Closure_declarations() {
    /** @type {!Array<{type: !Function, args: (undefined|!Array<?>)}>} */
    GenericTableComponent.decorators;
    /**
     * @nocollapse
     * @type {function(): !Array<(null|{type: ?, decorators: (undefined|!Array<{type: !Function, args: (undefined|!Array<?>)}>)})>}
     */
    GenericTableComponent.ctorParameters;
    /** @type {!Object<string,!Array<{type: !Function, args: (undefined|!Array<?>)}>>} */
    GenericTableComponent.propDecorators;
    /** @type {?} */
    GenericTableComponent.prototype.columnWidth;
    /** @type {?} */
    GenericTableComponent.prototype.configObject;
    /** @type {?} */
    GenericTableComponent.prototype.sortOrder;
    /** @type {?} */
    GenericTableComponent.prototype.metaInfo;
    /** @type {?} */
    GenericTableComponent.prototype.selectedRows;
    /** @type {?} */
    GenericTableComponent.prototype.openRows;
    /** @type {?} */
    GenericTableComponent.prototype._gtSettings;
    /** @type {?} */
    GenericTableComponent.prototype._gtFields;
    /** @type {?} */
    GenericTableComponent.prototype._gtData;
    /** @type {?} */
    GenericTableComponent.prototype._gtTotals;
    /** @type {?} */
    GenericTableComponent.prototype._gtRowComponent;
    /** @type {?} */
    GenericTableComponent.prototype.expandedRow;
    /** @type {?} */
    GenericTableComponent.prototype.gtDefaultTexts;
    /** @type {?} */
    GenericTableComponent.prototype.gtTexts;
    /** @type {?} */
    GenericTableComponent.prototype.gtClasses;
    /** @type {?} */
    GenericTableComponent.prototype.gtEvent;
    /** @type {?} */
    GenericTableComponent.prototype.gtDefaultOptions;
    /** @type {?} */
    GenericTableComponent.prototype._gtOptions;
    /** @type {?} */
    GenericTableComponent.prototype.store;
    /** @type {?} */
    GenericTableComponent.prototype.loading;
    /** @type {?} */
    GenericTableComponent.prototype.debounceTimer;
    /** @type {?} */
    GenericTableComponent.prototype.loadingProperty;
    /** @type {?} */
    GenericTableComponent.prototype.lazyAllSelected;
    /** @type {?} */
    GenericTableComponent.prototype.gtInfo;
    /** @type {?} */
    GenericTableComponent.prototype.refreshPipe;
    /** @type {?} */
    GenericTableComponent.prototype.refreshTotals;
    /** @type {?} */
    GenericTableComponent.prototype.refreshSorting;
    /** @type {?} */
    GenericTableComponent.prototype.refreshFilter;
    /** @type {?} */
    GenericTableComponent.prototype.refreshPageArray;
    /** @type {?} */
    GenericTableComponent.prototype.globalInlineEditListener;
    /** @type {?} */
    GenericTableComponent.prototype.editedRows;
    /** @type {?} */
    GenericTableComponent.prototype.data;
    /**
     * Sort table by object key.
     * \@param objectKey - name of key to sort on.
     * \@param event - such as key press during sorting.
     * @type {?}
     */
    GenericTableComponent.prototype.gtSort;
    /**
     * Change number of rows to be displayed.
     * \@param rowLength - total number of rows.
     * \@param reset - should page be reset to first page.
     * @type {?}
     */
    GenericTableComponent.prototype.changeRowLength;
    /**
     * Force a redraw of table rows.
     * As the table uses pure pipes, we need to force a redraw if an object in the array is changed to see the changes.
     * @type {?}
     */
    GenericTableComponent.prototype.redraw;
    /**
     * Go to next page.
     * @type {?}
     */
    GenericTableComponent.prototype.nextPage;
    /**
     * Go to previous page.
     * @type {?}
     */
    GenericTableComponent.prototype.previousPage;
    /**
     * Request more data (used when lazy loading)
     * @type {?}
     */
    GenericTableComponent.prototype.getData;
    /**
     * Go to specific page.
     * \@param page - page number.
     * @type {?}
     */
    GenericTableComponent.prototype.goToPage;
    /**
     * Sort by sort order
     * @type {?}
     */
    GenericTableComponent.prototype.getSortOrder;
    /**
     * Sort by column order
     * @type {?}
     */
    GenericTableComponent.prototype.getColumnOrder;
    /**
     * Create a deep copy of data
     * @type {?}
     */
    GenericTableComponent.prototype.cloneDeep;
    /**
     * Return property
     * @type {?}
     */
    GenericTableComponent.prototype.getProperty;
    /** @type {?} */
    GenericTableComponent.prototype.restructureSorting;
    /**
     *  Extend object function.
     * @type {?}
     */
    GenericTableComponent.prototype.extend;
    /** @type {?} */
    GenericTableComponent.prototype.renderer;
    /** @type {?} */
    GenericTableComponent.prototype.gtMetaPipe;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2VuZXJpYy10YWJsZS5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AYW5ndWxhci1nZW5lcmljLXRhYmxlL2NvcmUvIiwic291cmNlcyI6WyJjb21wb25lbnRzL2dlbmVyaWMtdGFibGUuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFBQSxPQUFPLEVBQ04sU0FBUyxFQUNULFlBQVksRUFDWixLQUFLLEVBSUwsTUFBTSxFQUNOLFNBQVMsRUFFVCxJQUFJLEVBQ0osTUFBTSxlQUFlLENBQUM7QUFjdkIsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLHVCQUF1QixDQUFDOzs7Ozs7QUE2Sm5ELE1BQU07Ozs7O0lBMlFMLFlBQW9CLFFBQW1CLEVBQVUsVUFBc0I7UUFBbkQsYUFBUSxHQUFSLFFBQVEsQ0FBVztRQUFVLGVBQVUsR0FBVixVQUFVLENBQVk7MkJBbkYxQyxFQUFFO3lCQUVBLEVBQUU7d0JBQ21CLEVBQUU7NEJBQ2xCLEVBQUU7d0JBQ04sRUFBRTsyQkFDTyxFQUFFO3lCQUNFLEVBQUU7OEJBUWQ7WUFDaEMsT0FBTyxFQUFFLFlBQVk7WUFDckIsTUFBTSxFQUFFLFNBQVM7WUFDakIsY0FBYyxFQUFFLGdDQUFnQztZQUNoRCx1QkFBdUIsRUFBRSxvQkFBb0I7WUFDN0MsZ0JBQWdCLEVBQUUsa0RBQWtEO1lBQ3BFLFNBQVMsRUFDUixrRUFBa0U7WUFDbkUsb0JBQW9CLEVBQ25CLGtIQUFrSDtZQUNuSCxXQUFXLEVBQUUsVUFBVTtZQUN2QixTQUFTLEVBQUUsT0FBTztZQUNsQixZQUFZLEVBQUUsV0FBVztZQUN6QixnQkFBZ0IsRUFBRSxlQUFlO1lBQ2pDLGdCQUFnQixFQUFFLHFCQUFxQjtTQUN2Qzt1QkFDMkIsSUFBSSxDQUFDLGNBQWM7dUJBRUosSUFBSSxZQUFZLEVBQUU7Z0NBQ3hCO1lBQ3BDLFlBQVksRUFBRSxHQUFHO1lBQ2pCLEtBQUssRUFBRSxLQUFLO1lBQ1osUUFBUSxFQUFFLEtBQUs7WUFDZixLQUFL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dCI6WyJpbXBvcnQge1xuXHRDb21wb25lbnQsXG5cdEV2ZW50RW1pdHRlcixcblx0SW5wdXQsXG5cdE9uQ2hhbmdlcyxcblx0T25EZXN0cm95LFxuXHRPbkluaXQsXG5cdE91dHB1dCxcblx0UmVuZGVyZXIyLFxuXHRTaW1wbGVDaGFuZ2VzLFxuXHRUeXBlXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHtcblx0R3RDb25maWcsXG5cdEd0Q29uZmlnRmllbGQsXG5cdEd0Q29uZmlnU2V0dGluZyxcblx0R3RFdmVudCxcblx0R3RFeHBhbmRlZFJvdyxcblx0R3RJbmZvcm1hdGlvbixcblx0R3RPcHRpb25zLFxuXHRHdFJlbmRlckZpZWxkLFxuXHRHdFJvdyxcblx0R3RSb3dNZXRhLFxuXHRHdFRleHRzXG59IGZyb20gJy4uJztcbmltcG9ydCB7IEd0TWV0YVBpcGUgfSBmcm9tICcuLi9waXBlcy9ndC1tZXRhLnBpcGUnO1xuXG5AQ29tcG9uZW50KHtcblx0c2VsZWN0b3I6ICdnZW5lcmljLXRhYmxlJyxcblx0dGVtcGxhdGU6IGA8dGFibGUgY2xhc3M9XCJ0YWJsZVwiIG5nQ2xhc3M9XCJ7e2d0Q2xhc3Nlc319IHt7Z3RPcHRpb25zLnN0YWNrID8gJ3RhYmxlLXN0YWNrZWQnOicnfX1cIlxuICAgICAgICpuZ0lmPVwiZ3RGaWVsZHMgJiYgZ3RTZXR0aW5ncyAmJiAoZ3RGaWVsZHMgfCBndFZpc2libGU6Z3RTZXR0aW5nczpyZWZyZXNoUGlwZSkubGVuZ3RoID4gMFwiPlxuICA8dGhlYWQ+XG4gIDx0cj5cbiAgICA8dGggY2xhc3M9XCJndC1zb3J0LWxhYmVsXCIgKm5nSWY9XCJndE9wdGlvbnMuc3RhY2tcIj57e2d0VGV4dHMuc29ydExhYmVsfX08L3RoPlxuICAgIDx0aCAqbmdGb3I9XCJsZXQgY29sdW1uIG9mIGd0U2V0dGluZ3MgfCBndFZpc2libGU6Z3RTZXR0aW5nczpyZWZyZXNoUGlwZVwiXG4gICAgICAgIG5nQ2xhc3M9XCJ7e2NvbHVtbi5vYmplY3RLZXkgKyctY29sdW1uJyB8IGRhc2hDYXNlfX0ge3tndEZpZWxkcyB8IGd0UHJvcGVydHk6Y29sdW1uLm9iamVjdEtleTonY2xhc3NOYW1lcyd9fSB7e2NvbHVtbi5zb3J0RW5hYmxlZCA/ICdzb3J0LScrY29sdW1uLnNvcnQ6Jyd9fSB7e2NvbHVtbi5zb3J0RW5hYmxlZCAmJiBjb2x1bW4uc29ydE9yZGVyID49IDAgID8gJ3NvcnQtb3JkZXItJytjb2x1bW4uc29ydE9yZGVyOicnfX0ge3sgZ3RGaWVsZHMgfCBndENvbHVtbkNsYXNzOmNvbHVtbiB9fVwiXG4gICAgICAgIChjbGljayk9XCJjb2x1bW4uc29ydEVuYWJsZWQgPyBndFNvcnQoY29sdW1uLm9iamVjdEtleSwkZXZlbnQpOicnO1wiPlxuICAgICAgPHNwYW4gKm5nSWY9XCIhKGd0RmllbGRzIHwgZ3RQcm9wZXJ0eTpjb2x1bW4ub2JqZWN0S2V5OidoZWFkZXInKVwiPnt7Z3RGaWVsZHMgfCBndFByb3BlcnR5OmNvbHVtbi5vYmplY3RLZXk6J25hbWUnfX08L3NwYW4+XG4gICAgICA8Z3QtY3VzdG9tLWNvbXBvbmVudC1mYWN0b3J5ICpuZ0lmPVwiKGd0RmllbGRzIHwgZ3RQcm9wZXJ0eTpjb2x1bW4ub2JqZWN0S2V5OidoZWFkZXInKVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFt0eXBlXT1cIihndEZpZWxkcyB8IGd0UHJvcGVydHk6Y29sdW1uLm9iamVjdEtleTonaGVhZGVyJyk/LnR5cGVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbaW5qZWN0b3JdPVwiKGd0RmllbGRzIHwgZ3RQcm9wZXJ0eTpjb2x1bW4ub2JqZWN0S2V5OidoZWFkZXInKT8uaW5qZWN0b3JcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbY29sdW1uXT1cImd0RmllbGRzIHwgZ3RQcm9wZXJ0eTpjb2x1bW4ub2JqZWN0S2V5OiduYW1lJ1wiPjwvZ3QtY3VzdG9tLWNvbXBvbmVudC1mYWN0b3J5PlxuICAgICAgPGd0LWNoZWNrYm94ICpuZ0lmPVwiKGd0RmllbGRzIHwgZ3RQcm9wZXJ0eTpjb2x1bW4ub2JqZWN0S2V5Oidjb2x1bW5Db21wb25lbnQnKT8udHlwZSA9PT0gJ2NoZWNrYm94J1wiIFtjaGVja2VkXT1cIihndE9wdGlvbnMubGF6eUxvYWQgPyBsYXp5QWxsU2VsZWN0ZWQ6c2VsZWN0ZWRSb3dzLmxlbmd0aCA9PT0gZ3REYXRhLmxlbmd0aClcIiAoY2hhbmdlZCk9XCJ0b2dnbGVBbGxSb3dzKClcIj48L2d0LWNoZWNrYm94PlxuICAgIDwvdGg+XG4gIDwvdHI+XG4gIDwvdGhlYWQ+XG4gIDxuZy10ZW1wbGF0ZVxuICAgIFtuZ0lmXT1cImd0VG90YWxzICYmIChndE9wdGlvbnMubGF6eUxvYWQgPT09IGZhbHNlID8gKGd0RGF0YSB8IGd0RmlsdGVyOmd0SW5mby5maWx0ZXI6Z3RJbmZvOnJlZnJlc2hGaWx0ZXI6Z3REYXRhLmxlbmd0aCB8IGd0U2VhcmNoOmd0SW5mby5zZWFyY2hUZXJtczpndEluZm86Z3RTZXR0aW5nczpndEZpZWxkczpndERhdGEubGVuZ3RoKS5sZW5ndGggPiAwIDogZ3REYXRhLmxlbmd0aCA+IDApXCI+XG4gICAgPHRoZWFkIGNsYXNzPVwiZ3QtdG90YWxzXCI+XG4gICAgPHRyICpuZ0Zvcj1cImxldCB0b3RhbCBvZiBndFRvdGFscyB8IGd0VG90YWxzUG9zaXRpb25cIj5cbiAgICAgIDx0ZCAqbmdGb3I9XCJsZXQgY29sdW1uIG9mIGd0U2V0dGluZ3MgfCBndFZpc2libGU6Z3RTZXR0aW5nczpyZWZyZXNoUGlwZTtsZXQgaSA9IGluZGV4O1wiXG4gICAgICAgICAgbmdDbGFzcz1cInt7Y29sdW1uLm9iamVjdEtleSArJy10b3RhbHMtY29sdW1uJyB8IGRhc2hDYXNlfX0ge3tndEZpZWxkcyB8IGd0UHJvcGVydHk6Y29sdW1uLm9iamVjdEtleTonY2xhc3NOYW1lcyd9fSB7eyBndEZpZWxkcyB8IGd0Q29sdW1uQ2xhc3M6Y29sdW1uIH19XCI+XG4gICAgICAgIDxzcGFuICpuZ0lmPVwiaSA9PT0gMFwiIGNsYXNzPVwiZmxvYXQtbGVmdFwiPnt7dG90YWwubmFtZX19PC9zcGFuPjxzcGFuXG4gICAgICAgIFtpbm5lckhUTUxdPVwidG90YWwuZmllbGRzW2NvbHVtbi5vYmplY3RLZXldIHwgZ3RUb3RhbHM6KHRvdGFsLnVwZGF0ZSA9PT0gZmFsc2UgfHwgZ3RPcHRpb25zLmxhenlMb2FkID09PSB0cnVlKSA/IGd0RGF0YTooZ3REYXRhIHwgZ3RGaWx0ZXI6Z3RJbmZvLmZpbHRlcjpndEluZm86cmVmcmVzaEZpbHRlcjpndERhdGEubGVuZ3RoIHwgZ3RTZWFyY2g6Z3RJbmZvLnNlYXJjaFRlcm1zOmd0SW5mbzpndFNldHRpbmdzOmd0RmllbGRzOmd0RGF0YS5sZW5ndGgpOmNvbHVtbi5vYmplY3RLZXk6cmVmcmVzaFRvdGFsc1wiPjwvc3Bhbj5cbiAgICAgIDwvdGQ+XG4gICAgPC90cj5cbiAgICA8L3RoZWFkPlxuICAgIDx0Zm9vdCBjbGFzcz1cImd0LXRvdGFsc1wiPlxuICAgIDx0ciAqbmdGb3I9XCJsZXQgdG90YWwgb2YgZ3RUb3RhbHMgfCBndFRvdGFsc1Bvc2l0aW9uOidmb290ZXInXCI+XG4gICAgICA8dGQgKm5nRm9yPVwibGV0IGNvbHVtbiBvZiBndFNldHRpbmdzIHwgZ3RWaXNpYmxlOmd0U2V0dGluZ3M6cmVmcmVzaFBpcGU7bGV0IGkgPSBpbmRleDtcIlxuICAgICAgICAgIG5nQ2xhc3M9XCJ7e2NvbHVtbi5vYmplY3RLZXkgKyctdG90YWxzLWNvbHVtbicgfCBkYXNoQ2FzZX19IHt7Z3RGaWVsZHMgfCBndFByb3BlcnR5OmNvbHVtbi5vYmplY3RLZXk6J2NsYXNzTmFtZXMnfX0ge3sgZ3RGaWVsZHMgfCBndENvbHVtbkNsYXNzOmNvbHVtbiB9fVwiPlxuICAgICAgICA8c3BhbiAqbmdJZj1cImkgPT09IDBcIiBjbGFzcz1cImZsb2F0LWxlZnRcIj57e3RvdGFsLm5hbWV9fTwvc3Bhbj48c3BhblxuICAgICAgICBbaW5uZXJIVE1MXT1cInRvdGFsLmZpZWxkc1tjb2x1bW4ub2JqZWN0S2V5XSB8IGd0VG90YWxzOih0b3RhbC51cGRhdGUgPT09IGZhbHNlIHx8IGd0T3B0aW9ucy5sYXp5TG9hZCA9PT0gdHJ1ZSkgPyBndERhdGE6KGd0RGF0YSB8IGd0RmlsdGVyOmd0SW5mby5maWx0ZXI6Z3RJbmZvOnJlZnJlc2hGaWx0ZXI6Z3REYXRhLmxlbmd0aCB8IGd0U2VhcmNoOmd0SW5mby5zZWFyY2hUZXJtczpndEluZm86Z3RTZXR0aW5nczpndEZpZWxkczpndERhdGEubGVuZ3RoKTpjb2x1bW4ub2JqZWN0S2V5OnJlZnJlc2hUb3RhbHNcIj48L3NwYW4+XG4gICAgICA8L3RkPlxuICAgIDwvdHI+XG4gICAgPC90Zm9vdD5cbiAgPC9uZy10ZW1wbGF0ZT5cbiAgPHRib2R5ICpuZ0lmPVwiZ3REYXRhICYmIGd0SW5mb1wiPlxuICA8bmctdGVtcGxhdGUgY2xhc3M9XCJ0YWJsZS1yb3dzXCIgbmdGb3IgbGV0LXJvdyBsZXQtbGFzdD1cImxhc3RcIiBbbmdGb3JUcmFja0J5XT1cInRyYWNrQnlGblwiXG4gICAgICAgICAgICAgICBbbmdGb3JPZl09XCJndE9wdGlvbnMubGF6eUxvYWQgJiYgZ3RJbmZvID8gKGd0RGF0YVtndEluZm8ucGFnZUN1cnJlbnQtMV0pIDogKGd0RGF0YSB8IGd0RmlsdGVyOmd0SW5mby5maWx0ZXI6Z3RJbmZvOnJlZnJlc2hGaWx0ZXI6Z3REYXRhLmxlbmd0aCB8IGd0U2VhcmNoOmd0SW5mby5zZWFyY2hUZXJtczpndEluZm86Z3RTZXR0aW5nczpndEZpZWxkczpndERhdGEubGVuZ3RoIHwgZ3RPcmRlckJ5OnNvcnRPcmRlcjpndEZpZWxkczpyZWZyZXNoU29ydGluZzpndERhdGEubGVuZ3RoIHwgZ3RDaHVuazpndEluZm86Z3RJbmZvLnJlY29yZExlbmd0aDpndEluZm8ucGFnZUN1cnJlbnQ6cmVmcmVzaFBhZ2VBcnJheTpndERhdGEubGVuZ3RoOmd0RXZlbnQ6ZGF0YSB8IGd0Um93Q2xhc3M6Z3RGaWVsZHMpXCI+XG4gICAgPHRyIFtuZ0NsYXNzXT1cInsncm93LXNlbGVjdGVkJzptZXRhSW5mb1tyb3cuJCRndFJvd0lkXT8uaXNTZWxlY3RlZCwgJ3Jvdy1vcGVuJzptZXRhSW5mb1tyb3cuJCRndFJvd0lkXT8uaXNPcGVuLCAncm93LWxvYWRpbmcnOmxvYWRpbmcsICdyb3ctZXhwYW5kYWJsZSc6Z3RSb3dDb21wb25lbnR9XCJcbiAgICAgICAgY2xhc3M9XCJ7e3Jvdy4kJGd0Um93Q2xhc3N9fVwiXG4gICAgICAgIChjbGljayk9XCJndE9wdGlvbnMucm93U2VsZWN0aW9uID8gdG9nZ2xlU2VsZWN0KHJvdyk6cm93Q2xpY2socm93LCAkZXZlbnQpXCI+XG4gICAgICA8dGQgKm5nRm9yPVwibGV0IGNvbHVtbiBvZiByb3cgfCBndFJlbmRlcjpndFNldHRpbmdzOmd0RmllbGRzOnJlZnJlc2hQaXBlOmxvYWRpbmc6Z3RPcHRpb25zLmhpZ2hsaWdodFNlYXJjaDpndEluZm8uc2VhcmNoVGVybXM7dHJhY2tCeTp0cmFja0J5Q29sdW1uRm5cIlxuICAgICAgICAgIG5nQ2xhc3M9XCJ7e2NvbHVtbi5vYmplY3RLZXkgKyctY29sdW1uJyB8IGRhc2hDYXNlfX0ge3tndEZpZWxkcyB8IGd0UHJvcGVydHk6Y29sdW1uLm9iamVjdEtleTonY2xhc3NOYW1lcyd9fSB7eyhndEZpZWxkcyB8IGd0UHJvcGVydHk6Y29sdW1uLm9iamVjdEtleTonaW5saW5lRWRpdCcpID8gJ2d0LWlubGluZS1lZGl0JzonJ319IHt7Y29sdW1uLmVkaXRlZCA/ICdndC1lZGl0ZWQnOicnfX0ge3sgZ3RGaWVsZHMgfCBndENvbHVtbkNsYXNzOmNvbHVtbjpyb3cgfX1cIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZ3Qtcm93LWxhYmVsXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICpuZ0lmPVwiZ3RPcHRpb25zLnN0YWNrXCI+e3soZ3RGaWVsZHMgfCBndFByb3BlcnR5OmNvbHVtbi5vYmplY3RLZXk6J3N0YWNrZWRIZWFkaW5nJykgPyAoZ3RGaWVsZHMgfCBndFByb3BlcnR5OmNvbHVtbi5vYmplY3RLZXk6J3N0YWNrZWRIZWFkaW5nJykgOiAoZ3RGaWVsZHMgfCBndFByb3BlcnR5OmNvbHVtbi5vYmplY3RLZXk6J25hbWUnKX19PC9zcGFuPlxuICAgICAgICA8Z3QtY3VzdG9tLWNvbXBvbmVudC1mYWN0b3J5ICpuZ0lmPVwiY29sdW1uLmNvbHVtbkNvbXBvbmVudCAmJiBjb2x1bW4uY29sdW1uQ29tcG9uZW50LnR5cGUgIT09ICdjaGVja2JveCdcIiBjbGFzcz1cImd0LXJvdy1jb250ZW50XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbdHlwZV09XCJjb2x1bW4uY29sdW1uQ29tcG9uZW50LnR5cGVcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtpbmplY3Rvcl09XCJjb2x1bW4uY29sdW1uQ29tcG9uZW50LmluamVjdG9yXCIgW3Jvd109XCJyb3dcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtjb2x1bW5dPVwiY29sdW1uXCIgKHJlZHJhd0V2ZW50KT1cInJlZHJhdygkZXZlbnQpXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBbc2VhcmNoVGVybXNdPVwiZ3RJbmZvLnNlYXJjaFRlcm1zXCIgIChzZWFyY2hFdmVudCk9XCJyZWRyYXcoJGV2ZW50KVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGNsaWNrKT1cImNvbHVtbi5jbGljayA/IGNvbHVtbi5jbGljayhyb3csY29sdW1uLCRldmVudCk6Jyc7Y29sdW1uLmV4cGFuZCA/IHRvZ2dsZUNvbGxhcHNlKHJvdywgY29sdW1uLmV4cGFuZCk6JydcIj48L2d0LWN1c3RvbS1jb21wb25lbnQtZmFjdG9yeT5cbiAgICAgICAgPHNwYW4gKm5nSWY9XCIhY29sdW1uLmNvbHVtbkNvbXBvbmVudCAmJiAoIShndEZpZWxkcyB8IGd0UHJvcGVydHk6Y29sdW1uLm9iamVjdEtleTonaW5saW5lRWRpdCcpIHx8ICgoZ3RGaWVsZHMgfCBndFByb3BlcnR5OmNvbHVtbi5vYmplY3RLZXk6J2lubGluZUVkaXQnKT8uYWN0aXZlIHwgZ3RJc09ic2VydmFibGUpICYmICEoKGd0RmllbGRzIHwgZ3RQcm9wZXJ0eTpjb2x1bW4ub2JqZWN0S2V5OidpbmxpbmVFZGl0Jyk/LmFjdGl2ZSB8IGFzeW5jKSB8fCAoISgoZ3RGaWVsZHMgfCBndFByb3BlcnR5OmNvbHVtbi5vYmplY3RLZXk6J2lubGluZUVkaXQnKT8uYWN0aXZlIHwgZ3RJc09ic2VydmFibGUpICYmICEoKGd0RmllbGRzIHwgZ3RQcm9wZXJ0eTpjb2x1bW4ub2JqZWN0S2V5OidpbmxpbmVFZGl0Jyk/LmFjdGl2ZSB8IGd0SXNFZGl0YWJsZTpyb3c6cmVmcmVzaFBpcGUpKSlcIlxuICAgICAgICAgICAgICBjbGFzcz1cImd0LXJvdy1jb250ZW50XCIgW2lubmVySFRNTF09XCJjb2x1bW4ucmVuZGVyVmFsdWVcIlxuICAgICAgICAgICAgICAoY2xpY2spPVwiY29sdW1uLmNsaWNrID8gY29sdW1uLmNsaWNrKHJvdyxjb2x1bW4sJGV2ZW50KTonJztjb2x1bW4uZXhwYW5kID8gdG9nZ2xlQ29sbGFwc2Uocm93LCBjb2x1bW4uZXhwYW5kKTonJ1wiPjwvc3Bhbj5cbiAgICAgICAgPG5nLXRlbXBsYXRlXG4gICAgICAgICAgW25nSWZdPVwiIWNvbHVtbi5jb2x1bW5Db21wb25lbnQgJiYgKCgoZ3RGaWVsZHMgfCBndFByb3BlcnR5OmNvbHVtbi5vYmplY3RLZXk6J2lubGluZUVkaXQnKT8uYWN0aXZlIHwgZ3RJc09ic2VydmFibGUpICYmICgoZ3RGaWVsZHMgfCBndFByb3BlcnR5OmNvbHVtbi5vYmplY3RLZXk6J2lubGluZUVkaXQnKT8uYWN0aXZlIHwgYXN5bmMpIHx8ICgoZ3RGaWVsZHMgfCBndFByb3BlcnR5OmNvbHVtbi5vYmplY3RLZXk6J2lubGluZUVkaXQnKT8uYWN0aXZlIHwgZ3RJc0VkaXRhYmxlOnJvdzpyZWZyZXNoUGlwZSkpXCI+XG4gICAgICAgICAgPG5nLXRlbXBsYXRlIFtuZ0lmXT1cIihbdHJ1ZSwnZW1haWwnLCdudW1iZXInLCdwYXNzd29yZCcsICd0ZXh0J10uaW5kZXhPZigoZ3RGaWVsZHMgfCBndFByb3BlcnR5OmNvbHVtbi5vYmplY3RLZXk6J2lubGluZUVkaXQnKS50eXBlKSAhPT0gLTEpIHx8ICEoZ3RGaWVsZHMgfCBndFByb3BlcnR5OmNvbHVtbi5vYmplY3RLZXk6J2lubGluZUVkaXQnKS50eXBlXCI+XG4gICAgICAgICAgICA8aW5wdXQgY2xhc3M9XCJpbmxpbmUtZWRpdFwiIFthdHRyLnR5cGVdPVwiIShndEZpZWxkcyB8IGd0UHJvcGVydHk6Y29sdW1uLm9iamVjdEtleTonaW5saW5lRWRpdCcpLnR5cGUgPyAndGV4dCcgOiAhKChndEZpZWxkcyB8IGd0UHJvcGVydHk6Y29sdW1uLm9iamVjdEtleTonaW5saW5lRWRpdCcpLnR5cGUgfCBndElzT2JzZXJ2YWJsZSkgPyAoZ3RGaWVsZHMgfCBndFByb3BlcnR5OmNvbHVtbi5vYmplY3RLZXk6J2lubGluZUVkaXQnKS50eXBlOihndEZpZWxkcyB8IGd0UHJvcGVydHk6Y29sdW1uLm9iamVjdEtleTonaW5saW5lRWRpdCcpLnR5cGUgfCBhc3luY1wiIFsobmdNb2RlbCldPVwiY29sdW1uLnJlbmRlclZhbHVlXCJcbiAgICAgICAgICAgICAgICAgICAoaW5wdXQpPVwiZ3RVcGRhdGVDb2x1bW4oJGV2ZW50LHJvdywgY29sdW1uKVwiPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJndC1pbmxpbmUtZWRpdC1ub3RpY2VcIj57e2d0VGV4dHMuaW5saW5lRWRpdEVkaXRlZH19PC9zcGFuPlxuICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgICAgICAgPGd0LWRyb3Bkb3duXG4gICAgICAgICAgICAqbmdJZj1cIigoKGd0RmllbGRzIHwgZ3RQcm9wZXJ0eTpjb2x1bW4ub2JqZWN0S2V5OidpbmxpbmVFZGl0JykudHlwZSkgJiYgKChndEZpZWxkcyB8IGd0UHJvcGVydHk6Y29sdW1uLm9iamVjdEtleTonaW5saW5lRWRpdCcpLnR5cGUpLmxlbmd0aCA+IDApIHx8ICgoZ3RGaWVsZHMgfCBndFByb3BlcnR5OmNvbHVtbi5vYmplY3RLZXk6J2lubGluZUVkaXQnKS50eXBlIHwgZ3RJc09ic2VydmFibGUpXCJcbiAgICAgICAgICAgIFtvcHRpb25zXT1cIiEoKGd0RmllbGRzIHwgZ3RQcm9wZXJ0eTpjb2x1bW4ub2JqZWN0S2V5OidpbmxpbmVFZGl0JykudHlwZSB8IGd0SXNPYnNlcnZhYmxlKSA/IChndEZpZWxkcyB8IGd0UHJvcGVydHk6Y29sdW1uLm9iamVjdEtleTonaW5saW5lRWRpdCcpLnR5cGUgOiAoZ3RGaWVsZHMgfCBndFByb3BlcnR5OmNvbHVtbi5vYmplY3RLZXk6J2lubGluZUVkaXQnKS50eXBlIHwgYXN5bmNcIlxuICAgICAgICAgICAgW2lkXT1cIidfJyArIHJvdy4kJGd0Um93SWQgKyAnXycgKyBjb2x1bW4ub2JqZWN0S2V5XCJcbiAgICAgICAgICAgIFsoc2VsZWN0ZWQpXT1cImNvbHVtbi5yZW5kZXJWYWx1ZVwiIChzZWxlY3RlZENoYW5nZSk9XCJndERyb3Bkb3duU2VsZWN0KHJvdywgY29sdW1uKVwiPkFkZFxuICAgICAgICAgICAgaW5saW5lIGVkaXRpbmcgbW9kdWxlXG4gICAgICAgICAgPC9ndC1kcm9wZG93bj5cbiAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgPG5nLXRlbXBsYXRlIFtuZ0lmXT1cIiFjb2x1bW4uY29sdW1uQ29tcG9uZW50ICYmICEoKGd0RmllbGRzIHwgZ3RQcm9wZXJ0eTpjb2x1bW4ub2JqZWN0S2V5OidpbmxpbmVFZGl0Jyk/LmFjdGl2ZSkgXCI+XG4gICAgICAgICAgPG5nLXRlbXBsYXRlXG4gICAgICAgICAgICBbbmdJZl09XCJbdHJ1ZSwnZW1haWwnLCdudW1iZXInLCdwYXNzd29yZCddLmluZGV4T2YoZ3RGaWVsZHMgfCBndFByb3BlcnR5OmNvbHVtbi5vYmplY3RLZXk6J2lubGluZUVkaXQnKSAhPT0gLTFcIj5cbiAgICAgICAgICAgIDxpbnB1dCBjbGFzcz1cImlubGluZS1lZGl0XCIgW2F0dHIudHlwZV09XCIoZ3RGaWVsZHMgfCBndFByb3BlcnR5OmNvbHVtbi5vYmplY3RLZXk6J2lubGluZUVkaXQnKSA9PT0gdHJ1ZSA/ICd0ZXh0JzooZ3RGaWVsZHMgfCBndFByb3BlcnR5OmNvbHVtbi5vYmplY3RLZXk6J2lubGluZUVkaXQnKVwiIFsobmdNb2RlbCldPVwiY29sdW1uLnJlbmRlclZhbHVlXCJcbiAgICAgICAgICAgICAgICAgICAoaW5wdXQpPVwiZ3RVcGRhdGVDb2x1bW4oJGV2ZW50LHJvdywgY29sdW1uKVwiPlxuICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJndC1pbmxpbmUtZWRpdC1ub3RpY2VcIj57e2d0VGV4dHMuaW5saW5lRWRpdEVkaXRlZH19PC9zcGFuPlxuICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgICAgICAgPGd0LWRyb3Bkb3duXG4gICAgICAgICAgICAqbmdJZj1cIihndEZpZWxkcyB8IGd0UHJvcGVydHk6Y29sdW1uLm9iamVjdEtleTonaW5saW5lRWRpdCcpICYmIFt0cnVlLCdlbWFpbCcsJ251bWJlcicsJ3Bhc3N3b3JkJ10uaW5kZXhPZihndEZpZWxkcyB8IGd0UHJvcGVydHk6Y29sdW1uLm9iamVjdEtleTonaW5saW5lRWRpdCcpID09PSAtMVwiXG4gICAgICAgICAgICBbb3B0aW9uc109XCJndEZpZWxkcyB8IGd0UHJvcGVydHk6Y29sdW1uLm9iamVjdEtleTonaW5saW5lRWRpdCdcIlxuICAgICAgICAgICAgW2lkXT1cIidfJyArIHJvdy4kJGd0Um93SWQgKyAnXycgKyBjb2x1bW4ub2JqZWN0S2V5XCJcbiAgICAgICAgICAgIFsoc2VsZWN0ZWQpXT1cImNvbHVtbi5yZW5kZXJWYWx1ZVwiIChzZWxlY3RlZENoYW5nZSk9XCJndERyb3Bkb3duU2VsZWN0KHJvdywgY29sdW1uKVwiPkFkZFxuICAgICAgICAgICAgaW5saW5lIGVkaXRpbmcgbW9kdWxlXG4gICAgICAgICAgPC9ndC1kcm9wZG93bj5cbiAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgPGd0LWNoZWNrYm94ICpuZ0lmPVwiY29sdW1uLmNvbHVtbkNvbXBvbmVudCAmJiBjb2x1bW4uY29sdW1uQ29tcG9uZW50LnR5cGUgPT09ICdjaGVja2JveCdcIiBbY2hlY2tlZF09XCJtZXRhSW5mb1tyb3cuJCRndFJvd0lkXT8uaXNTZWxlY3RlZFwiIChjaGFuZ2VkKT1cInRvZ2dsZVNlbGVjdChyb3cpXCI+PC9ndC1jaGVja2JveD5cbiAgICAgIDwvdGQ+XG4gICAgPC90cj5cbiAgICA8dHIgY2xhc3M9XCJyb3ctZXhwYW5kZWRcIiAqbmdJZj1cIm1ldGFJbmZvW3Jvdy4kJGd0Um93SWRdPy5pc09wZW5cIj5cbiAgICAgIDx0ZCBbYXR0ci5jb2xzcGFuXT1cIihndEZpZWxkcyB8IGd0VmlzaWJsZTpndFNldHRpbmdzOnJlZnJlc2hQaXBlKS5sZW5ndGhcIj5cbiAgICAgICAgPGd0LWV4cGFuZGluZy1yb3cgW3Jvd109XCJyb3dcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICBbdHlwZV09XCJleHBhbmRlZFJvdy5jb21wb25lbnQgPyBleHBhbmRlZFJvdy5jb21wb25lbnQ6Z3RSb3dDb21wb25lbnRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICBbY29sdW1uV2lkdGhdPVwiY29sdW1uV2lkdGhcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICBbZ3RGaWVsZHNdPVwiZ3RGaWVsZHNcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICBbZ3RPcHRpb25zXT1cImd0T3B0aW9uc1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFtndEV2ZW50XT1cImd0RXZlbnRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICBbZ3RJbmZvXT1cImd0SW5mb1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFtndFNldHRpbmdzXT1cImd0U2V0dGluZ3NcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICBbZGF0YV09XCJleHBhbmRlZFJvdy5kYXRhID8gZXhwYW5kZWRSb3cuZGF0YTpyb3dcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAocmVkcmF3RXZlbnQpPVwicmVkcmF3KCRldmVudClcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAodG9nZ2xlUm93RXZlbnQpPVwidG9nZ2xlQ29sbGFwc2UoJGV2ZW50KVwiPjwvZ3QtZXhwYW5kaW5nLXJvdz5cbiAgICAgIDwvdGQ+XG4gICAgPC90cj5cbiAgICA8dHIgKm5nSWY9XCJndE9wdGlvbnMucmVwb3J0Q29sdW1uV2lkdGggJiYgbGFzdFwiPlxuICAgICAgPHRkIHN0eWxlPVwicGFkZGluZzogMDsgYm9yZGVyOm5vbmU7XCJcbiAgICAgICAgICAqbmdGb3I9XCJsZXQgY29sdW1uIG9mIGd0U2V0dGluZ3MgfCBndFZpc2libGU6Z3RTZXR0aW5nczpyZWZyZXNoUGlwZVwiIGd0Q29sdW1uV2lkdGhcbiAgICAgICAgICBbb2JqZWN0S2V5XT1cImNvbHVtbi5vYmplY3RLZXlcIiBbd2lkdGhzXT1cImNvbHVtbldpZHRoXCI+PC90ZD5cbiAgICA8L3RyPlxuICA8L25nLXRlbXBsYXRlPlxuICA8dHIgKm5nSWY9XCJndEluZm8ucGFnZVRvdGFsID09PSAwICYmIChndEluZm8uc2VhcmNoVGVybXMgfHwgZ3RJbmZvLmZpbHRlcikgJiYgIWxvYWRpbmdcIj5cbiAgICA8dGQgY2xhc3M9XCJndC1uby1tYXRjaGluZy1yZXN1bHRzXCIgW2F0dHIuY29sc3Bhbl09XCIoZ3RGaWVsZHMgfCBndFZpc2libGU6Z3RTZXR0aW5ncykubGVuZ3RoXCI+XG4gICAgICB7e2d0VGV4dHMubm9NYXRjaGluZ0RhdGF9fVxuICAgIDwvdGQ+XG4gIDwvdHI+XG4gIDx0ciAqbmdJZj1cImd0SW5mby5wYWdlVG90YWwgPT09IDAgJiYgIShndEluZm8uc2VhcmNoVGVybXMgfHwgZ3RJbmZvLmZpbHRlcikgJiYgIWxvYWRpbmdcIj5cbiAgICA8dGQgY2xhc3M9XCJndC1uby1yZXN1bHRzXCIgW2F0dHIuY29sc3Bhbl09XCIoZ3RGaWVsZHMgfCBndFZpc2libGU6Z3RTZXR0aW5ncykubGVuZ3RoXCI+e3tndFRleHRzLm5vRGF0YX19XG4gICAgPC90ZD5cbiAgPC90cj5cbiAgPHRyICpuZ0lmPVwiZ3RJbmZvLnBhZ2VUb3RhbCA9PT0gMCAmJiBsb2FkaW5nXCI+XG4gICAgPHRkIGNsYXNzPVwiZ3QtbG9hZGluZy1kYXRhXCIgW2F0dHIuY29sc3Bhbl09XCIoZ3RGaWVsZHMgfCBndFZpc2libGU6Z3RTZXR0aW5ncykubGVuZ3RoXCI+e3tndFRleHRzLmxvYWRpbmd9fTwvdGQ+XG4gIDwvdHI+XG4gIDwvdGJvZHk+XG48L3RhYmxlPlxuPHRhYmxlIGNsYXNzPVwidGFibGVcIiBuZ0NsYXNzPVwie3tndENsYXNzZXN9fSB7e2d0T3B0aW9ucy5zdGFjayA/ICd0YWJsZS1zdGFja2VkJzonJ319XCJcbiAgICAgICAqbmdJZj1cImd0RmllbGRzICYmIGd0U2V0dGluZ3MgJiYgKGd0RmllbGRzIHwgZ3RWaXNpYmxlOmd0U2V0dGluZ3M6cmVmcmVzaFBpcGUpLmxlbmd0aCA9PT0gMFwiPlxuICA8dGhlYWQ+XG4gIDx0cj5cbiAgICA8dGggY2xhc3M9XCJndC1uby12aXNpYmxlLWNvbHVtbnNcIj57e2d0VGV4dHMubm9WaXNpYmxlQ29sdW1uc0hlYWRpbmd9fTwvdGg+XG4gIDwvdHI+XG4gIDwvdGhlYWQ+XG4gIDx0Ym9keT5cbiAgPHRyPlxuICAgIDx0ZCBjbGFzcz1cImd0LW5vLXZpc2libGUtY29sdW1uc1wiPnt7Z3RUZXh0cy5ub1Zpc2libGVDb2x1bW5zfX08L3RkPlxuICA8L3RyPlxuICA8L3Rib2R5PlxuPC90YWJsZT5cbjx0YWJsZSBjbGFzcz1cInRhYmxlXCIgbmdDbGFzcz1cInt7Z3RDbGFzc2VzfX0ge3tndE9wdGlvbnMuc3RhY2sgPyAndGFibGUtc3RhY2tlZCc6Jyd9fVwiXG4gICAgICAgKm5nSWY9XCIhZ3RGaWVsZHMgfHwgIWd0U2V0dGluZ3NcIj5cbiAgPHRoZWFkPlxuICA8dHI+XG4gICAgPHRoIGNsYXNzPVwiZ3QtbG9hZGluZy1jb25maWdcIj4mbmJzcDs8L3RoPlxuICA8L3RyPlxuICA8L3RoZWFkPlxuICA8dGJvZHk+XG4gIDx0cj5cbiAgICA8dGQgY2xhc3M9XCJndC1sb2FkaW5nLWNvbmZpZ1wiPiZuYnNwOzwvdGQ+XG4gIDwvdHI+XG4gIDwvdGJvZHk+XG48L3RhYmxlPlxuYFxufSlcbmV4cG9ydCBjbGFzcyBHZW5lcmljVGFibGVDb21wb25lbnQ8UiBleHRlbmRzIEd0Um93LCBDIGV4dGVuZHMgR3RFeHBhbmRlZFJvdzxSPj5cblx0aW1wbGVtZW50cyBPbkluaXQsIE9uQ2hhbmdlcywgT25EZXN0cm95IHtcblx0Z2V0IGd0Um93Q29tcG9uZW50KCk6IFR5cGU8Qz4ge1xuXHRcdHJldHVybiB0aGlzLl9ndFJvd0NvbXBvbmVudDtcblx0fVxuXG5cdGdldCBoYXNFZGl0cygpOiBib29sZWFuIHtcblx0XHRyZXR1cm4gT2JqZWN0LmtleXModGhpcy5lZGl0ZWRSb3dzKS5sZW5ndGggPiAwO1xuXHR9XG5cblx0Z2V0IGd0T3B0aW9ucygpOiBHdE9wdGlvbnMge1xuXHRcdHJldHVybiB0aGlzLl9ndE9wdGlvbnM7XG5cdH1cblxuXHRnZXQgZ3RUb3RhbHMoKTogYW55IHtcblx0XHRyZXR1cm4gdGhpcy5fZ3RUb3RhbHM7XG5cdH1cblxuXHRnZXQgZ3RGaWVsZHMoKTogR3RDb25maWdGaWVsZDxSLCBhbnk+W10ge1xuXHRcdHJldHVybiB0aGlzLl9ndEZpZWxkcztcblx0fVxuXG5cdGdldCBndFNldHRpbmdzKCk6IEd0Q29uZmlnU2V0dGluZ1tdIHtcblx0XHRyZXR1cm4gdGhpcy5fZ3RTZXR0aW5ncztcblx0fVxuXG5cdGdldCBndERhdGEoKTogQXJyYXk8YW55PiB7XG5cdFx0cmV0dXJuIHRoaXMuX2d0RGF0YTtcblx0fVxuXG5cdEBJbnB1dCgpXG5cdHNldCBndE9wdGlvbnModmFsdWU6IEd0T3B0aW9ucykge1xuXHRcdHRoaXMuX2d0T3B0aW9ucyA9IHZhbHVlO1xuXG5cdFx0Ly8gaWYgbnVtYmVyIG9mIHJvd3MgaXMgcGFzc2VkIGFuZCBpZiBudW1iZXIgb2Ygcm93cyBkaWZmZXJzIGZyb20gY3VycmVudCByZWNvcmQgbGVuZ3RoLi4uXG5cdFx0aWYgKFxuXHRcdFx0dGhpcy5ndE9wdGlvbnMubnVtYmVyT2ZSb3dzICYmXG5cdFx0XHR0aGlzLmd0SW5mby5yZWNvcmRMZW5ndGggIT09IHRoaXMuZ3RPcHRpb25zLm51bWJlck9mUm93c1xuXHRcdCkge1xuXHRcdFx0Ly8gLi4udXBkYXRlIHJlY29yZCBsZW5ndGggYW5kIHJlZHJhdyB0YWJsZVxuXHRcdFx0dGhpcy5ndEluZm8ucmVjb3JkTGVuZ3RoID0gdGhpcy5ndE9wdGlvbnMubnVtYmVyT2ZSb3dzO1xuXHRcdFx0dGhpcy5yZWRyYXcoKTtcblx0XHR9XG5cblx0XHQvLyAuLi5leHRlbmQgZ3RPcHRpb25zIGRlZmF1bHQgdmFsdWVzIHdpdGggdmFsdWVzIHBhc3NlZCBpbnRvIGNvbXBvbmVudFxuXHRcdHRoaXMuX2d0T3B0aW9ucyA9IDxHdE9wdGlvbnM+dGhpcy5leHRlbmQoXG5cdFx0XHR0aGlzLmd0RGVmYXVsdE9wdGlvbnMsXG5cdFx0XHR0aGlzLl9ndE9wdGlvbnNcblx0XHQpO1xuXHR9XG5cblx0QElucHV0KClcblx0c2V0IGd0VG90YWxzKHZhbHVlOiBhbnkpIHtcblx0XHR0aGlzLl9ndFRvdGFscyA9IHZhbHVlO1xuXHR9XG5cblx0QElucHV0KClcblx0c2V0IGd0RmllbGRzKHZhbHVlOiBHdENvbmZpZ0ZpZWxkPFIsIGFueT5bXSkge1xuXHRcdHRoaXMuX2d0RmllbGRzID0gdmFsdWU7XG5cdFx0Y29uc3QgQ09MVU1OU19XSVRIX0NMQVNTX05BTUVTID0gdGhpcy5fZ3RGaWVsZHNcblx0XHRcdC5tYXAoY29sdW1uID0+IGNvbHVtbilcblx0XHRcdC5maWx0ZXIoY29sdW1uID0+IGNvbHVtbi5jbGFzc05hbWVzKTtcblx0XHQvLyBUT0RPOiByZW1vdmUgZGVwcmVjYXRlZCB3YXJuaW5nIHdoZW4gc2V0dGluZyBoYXMgYmVlbiByZW1vdmVkXG5cdFx0aWYgKENPTFVNTlNfV0lUSF9DTEFTU19OQU1FUy5sZW5ndGggPiAwKSB7XG5cdFx0XHRjb25zb2xlLndhcm4oXG5cdFx0XHRcdCdGaWVsZCBzZXR0aW5nIFwiY2xhc3NOYW1lc1wiIGhhdmUgYmVlbiBkZXByZWNhdGVkIGluIGZhdm9yIGZvciBcImNvbHVtbkNsYXNzXCIgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgZnV0dXJlLCBwbGVhc2UgdXBkYXRlIGZpZWxkIHNldHRpbmdzIGZvciBjb2x1bW4gd2l0aCBvYmplY3Qga2V5OiAnICtcblx0XHRcdFx0XHRDT0xVTU5TX1dJVEhfQ0xBU1NfTkFNRVNbMF0ub2JqZWN0S2V5XG5cdFx0XHQpO1xuXHRcdH1cblx0fVxuXG5cdEBJbnB1dCgpXG5cdHNldCBndFNldHRpbmdzKHZhbHVlOiBHdENvbmZpZ1NldHRpbmdbXSkge1xuXHRcdHRoaXMuX2d0U2V0dGluZ3MgPSB2YWx1ZTtcblxuXHRcdC8vIGxvb3AgdGhyb3VnaCBjdXJyZW50IHNldHRpbmdzXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9ndFNldHRpbmdzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHQvLyBzZXQgc29ydCBlbmFibGVkL2Rpc2FibGVkIHNldHRpbmdcblx0XHRcdHRoaXMuX2d0U2V0dGluZ3NbaV0uc29ydEVuYWJsZWQgPVxuXHRcdFx0XHR0aGlzLl9ndFNldHRpbmdzW2ldLnNvcnRFbmFibGVkICE9PSBmYWxzZVxuXHRcdFx0XHRcdD8gKHRoaXMuX2d0U2V0dGluZ3NbaV0uc29ydEVuYWJsZWQgPSAhKFxuXHRcdFx0XHRcdFx0XHR0aGlzLl9ndFNldHRpbmdzW2ldLnNvcnQgJiZcblx0XHRcdFx0XHRcdFx0dGhpcy5fZ3RTZXR0aW5nc1tpXS5zb3J0LmluZGV4T2YoJ2Rpc2FibGUnKSAhPT0gLTFcblx0XHRcdFx0XHQgICkpXG5cdFx0XHRcdFx0OiBmYWxzZTtcblxuXHRcdFx0Ly8gY2hlY2sgaWYgc29ydGluZyBpcyB1bmRlZmluZWQuLi5cblx0XHRcdGlmICh0eXBlb2YgdGhpcy5fZ3RTZXR0aW5nc1tpXS5zb3J0ID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHQvLyAuLi5pcyBzbywgc2V0IHNvcnRpbmcgcHJvcGVydHkgdG8gZW5hYmxlXG5cdFx0XHRcdHRoaXMuX2d0U2V0dGluZ3NbaV0uc29ydCA9ICdlbmFibGUnO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBjaGVjayBpZiBjb2x1bW4gb3JkZXIgaXMgdW5kZWZpbmVkLi4uXG5cdFx0XHRpZiAoXG5cdFx0XHRcdHR5cGVvZiB0aGlzLl9ndFNldHRpbmdzW2ldLmNvbHVtbk9yZGVyID09PSAndW5kZWZpbmVkJyAmJlxuXHRcdFx0XHR0aGlzLl9ndFNldHRpbmdzW2ldLmVuYWJsZWQgIT09IGZhbHNlXG5cdFx0XHQpIHtcblx0XHRcdFx0Ly8gLi4uaXMgc28sIHNldCBzb3J0aW5nIHByb3BlcnR5IHRvIGVuYWJsZVxuXHRcdFx0XHR0aGlzLl9ndFNldHRpbmdzW2ldLmNvbHVtbk9yZGVyID0gdGhpcy5fZ3RTZXR0aW5nc1tpIC0gMV1cblx0XHRcdFx0XHQ/IHRoaXMuX2d0U2V0dGluZ3NbaSAtIDFdLmNvbHVtbk9yZGVyICsgMVxuXHRcdFx0XHRcdDogMDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gY2hlY2sgaWYgY29sdW1uIGxvY2sgc2V0dGluZ3MgYXJlIHVuZGVmaW5lZC4uLlxuXHRcdFx0aWYgKHR5cGVvZiB0aGlzLl9ndFNldHRpbmdzW2ldLmxvY2tTZXR0aW5ncyA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdFx0Ly8gLi4uaWYgc28sIHNldCBsb2NrIHNldHRpbmdzIHRvIGZhbHNlIHVubGVzcyBmaWVsZCBpcyBkaXNhYmxlZCAoZW5hYmxlID09PSBmYWxzZSlcblx0XHRcdFx0dGhpcy5fZ3RTZXR0aW5nc1tpXS5sb2NrU2V0dGluZ3MgPVxuXHRcdFx0XHRcdHRoaXMuX2d0U2V0dGluZ3NbaV0uZW5hYmxlZCA9PT0gZmFsc2UgfHwgZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHRoaXMucmVzdHJ1Y3R1cmVTb3J0aW5nKCk7XG5cdH1cblxuXHRASW5wdXQoKVxuXHRzZXQgZ3REYXRhKGluaXRpYWxEYXRhOiBBcnJheTxhbnk+KSB7XG5cdFx0Y29uc3QgZGF0YSA9IHRoaXMuX2d0T3B0aW9ucy5tdXRhdGVEYXRhXG5cdFx0XHQ/IFsuLi5pbml0aWFsRGF0YV1cblx0XHRcdDogdGhpcy5jbG9uZURlZXAoaW5pdGlhbERhdGEpO1xuXHRcdGlmICh0aGlzLmd0T3B0aW9ucy5sYXp5TG9hZCAmJiB0aGlzLmd0SW5mbykge1xuXHRcdFx0dGhpcy5ndE1ldGFQaXBlLnRyYW5zZm9ybShcblx0XHRcdFx0ZGF0YSxcblx0XHRcdFx0dGhpcy5ndE9wdGlvbnMucm93SW5kZXgsXG5cdFx0XHRcdHRoaXMuZ3RJbmZvLnBhZ2VDdXJyZW50IC0gMSxcblx0XHRcdFx0dGhpcy5ndEluZm8ucmVjb3JkTGVuZ3RoXG5cdFx0XHQpO1xuXHRcdFx0aWYgKHRoaXMubGF6eUFsbFNlbGVjdGVkKSB7XG5cdFx0XHRcdGNvbnN0IFVOSVFVRV9ST1dTID0gdGhpcy5zZWxlY3RlZFJvd3MubWFwKHJvdyA9PiByb3cuJCRndFJvd0lkKTtcblx0XHRcdFx0ZGF0YS5tYXAocm93ID0+IHtcblx0XHRcdFx0XHRpZiAoVU5JUVVFX1JPV1MuaW5kZXhPZihyb3cuJCRndFJvd0lkKSA9PT0gLTEpIHtcblx0XHRcdFx0XHRcdHRoaXMuc2VsZWN0ZWRSb3dzLnB1c2gocm93KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHR0aGlzLl91cGRhdGVNZXRhSW5mbyh0aGlzLnNlbGVjdGVkUm93cywgJ2lzU2VsZWN0ZWQnLCB0cnVlKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5ndE1ldGFQaXBlLnRyYW5zZm9ybShkYXRhLCB0aGlzLmd0T3B0aW9ucy5yb3dJbmRleCk7XG5cdFx0fVxuXHRcdGlmICh0aGlzLmd0T3B0aW9ucy5yb3dTZWxlY3Rpb25Jbml0aWFsU3RhdGUpIHtcblx0XHRcdGRhdGEubWFwKHJvdyA9PiB7XG5cdFx0XHRcdGNvbnN0IHNlbGVjdGVkID1cblx0XHRcdFx0XHR0eXBlb2YgdGhpcy5ndE9wdGlvbnMucm93U2VsZWN0aW9uSW5pdGlhbFN0YXRlID09PSAnZnVuY3Rpb24nXG5cdFx0XHRcdFx0XHQ/IHRoaXMuZ3RPcHRpb25zLnJvd1NlbGVjdGlvbkluaXRpYWxTdGF0ZShyb3cpXG5cdFx0XHRcdFx0XHQ6IHRoaXMuZ3RPcHRpb25zLnJvd1NlbGVjdGlvbkluaXRpYWxTdGF0ZTtcblx0XHRcdFx0aWYgKHNlbGVjdGVkKSB7XG5cdFx0XHRcdFx0aWYgKHR5cGVvZiB0aGlzLm1ldGFJbmZvW3Jvdy4kJGd0Um93SWRdID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHRcdFx0dGhpcy5tZXRhSW5mb1tyb3cuJCRndFJvd0lkXSA9IHsgaXNTZWxlY3RlZDogdHJ1ZSB9O1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0aGlzLm1ldGFJbmZvW3Jvdy4kJGd0Um93SWRdLmlzU2VsZWN0ZWQgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLnNlbGVjdGVkUm93cy5wdXNoKHJvdyk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblx0XHRpZiAoXG5cdFx0XHR0aGlzLmd0T3B0aW9ucy5yb3dFeHBhbmRJbml0aWFsU3RhdGUgJiZcblx0XHRcdHRoaXMuZ3RPcHRpb25zLnJvd0V4cGFuZEluaXRpYWxDb21wb25lbnRcblx0XHQpIHtcblx0XHRcdGRhdGEubWFwKHJvdyA9PiB7XG5cdFx0XHRcdGNvbnN0IGV4cGFuZGVkID1cblx0XHRcdFx0XHR0eXBlb2YgdGhpcy5ndE9wdGlvbnMucm93RXhwYW5kSW5pdGlhbFN0YXRlID09PSAnZnVuY3Rpb24nXG5cdFx0XHRcdFx0XHQ/IHRoaXMuZ3RPcHRpb25zLnJvd0V4cGFuZEluaXRpYWxTdGF0ZShyb3cpXG5cdFx0XHRcdFx0XHQ6IHRoaXMuZ3RPcHRpb25zLnJvd0V4cGFuZEluaXRpYWxTdGF0ZTtcblx0XHRcdFx0dGhpcy5leHBhbmRlZFJvdyA9IHRoaXMuZ3RPcHRpb25zLnJvd0V4cGFuZEluaXRpYWxDb21wb25lbnQ7XG5cblx0XHRcdFx0aWYgKGV4cGFuZGVkKSB7XG5cdFx0XHRcdFx0aWYgKHR5cGVvZiB0aGlzLm1ldGFJbmZvW3Jvdy4kJGd0Um93SWRdID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHRcdFx0dGhpcy5tZXRhSW5mb1tyb3cuJCRndFJvd0lkXSA9IHsgaXNPcGVuOiB0cnVlIH07XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRoaXMubWV0YUluZm9bcm93LiQkZ3RSb3dJZF0uaXNPcGVuID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblx0XHR0aGlzLl9ndERhdGEgPSBkYXRhO1xuXHR9XG5cblx0QElucHV0KClcblx0c2V0IGd0Um93Q29tcG9uZW50KHZhbHVlOiBUeXBlPEM+KSB7XG5cdFx0Y29uc29sZS53YXJuKFxuXHRcdFx0J0d0Um93Q29tcG9uZW50IGhhcyBiZWVuIGRlcHJlY2F0ZWQgYW5kIHN1cHBvcnQgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIHJlbGVhc2UsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vaGphbG1lcnMvYW5ndWxhci1nZW5lcmljLXRhYmxlL2lzc3Vlcy8zNCdcblx0XHQpO1xuXHRcdHRoaXMuX2d0Um93Q29tcG9uZW50ID0gdmFsdWU7XG5cdH1cblxuXHRwdWJsaWMgY29sdW1uV2lkdGg6IE9iamVjdCA9IHt9O1xuXHRwdWJsaWMgY29uZmlnT2JqZWN0OiBHdENvbmZpZzxSPjtcblx0cHVibGljIHNvcnRPcmRlcjogQXJyYXk8YW55PiA9IFtdO1xuXHRwdWJsaWMgbWV0YUluZm86IHsgW2d0Um93SWQ6IHN0cmluZ106IEd0Um93TWV0YSB9ID0ge307XG5cdHB1YmxpYyBzZWxlY3RlZFJvd3M6IEFycmF5PEd0Um93PiA9IFtdO1xuXHRwdWJsaWMgb3BlblJvd3M6IEFycmF5PEd0Um93PiA9IFtdO1xuXHRwcml2YXRlIF9ndFNldHRpbmdzOiBHdENvbmZpZ1NldHRpbmdbXSA9IFtdO1xuXHRwcml2YXRlIF9ndEZpZWxkczogR3RDb25maWdGaWVsZDxSLCBhbnk+W10gPSBbXTtcblx0cHJpdmF0ZSBfZ3REYXRhOiBBcnJheTxhbnk+O1xuXHRwcml2YXRlIF9ndFRvdGFsczogYW55O1xuXHRwcml2YXRlIF9ndFJvd0NvbXBvbmVudDogVHlwZTxDPjtcblx0cHVibGljIGV4cGFuZGVkUm93OiB7XG5cdFx0Y29tcG9uZW50OiBUeXBlPEM+O1xuXHRcdGRhdGE/OiBBcnJheTxhbnk+O1xuXHR9O1xuXHRwdWJsaWMgZ3REZWZhdWx0VGV4dHM6IEd0VGV4dHMgPSB7XG5cdFx0bG9hZGluZzogJ0xvYWRpbmcuLi4nLFxuXHRcdG5vRGF0YTogJ05vIGRhdGEnLFxuXHRcdG5vTWF0Y2hpbmdEYXRhOiAnTm8gZGF0YSBtYXRjaGluZyByZXN1bHRzIGZvdW5kJyxcblx0XHRub1Zpc2libGVDb2x1bW5zSGVhZGluZzogJ05vIHZpc2libGUgY29sdW1ucycsXG5cdFx0bm9WaXNpYmxlQ29sdW1uczogJ1BsZWFzZSBzZWxlY3QgYXQgbGVhc3Qgb25lIGNvbHVtbiB0byBiZSB2aXNpYmxlLicsXG5cdFx0dGFibGVJbmZvOlxuXHRcdFx0J1Nob3dpbmcgI3JlY29yZEZyb20gdG8gI3JlY29yZFRvIG9mICNyZWNvcmRzQWZ0ZXJTZWFyY2ggZW50cmllcy4nLFxuXHRcdHRhYmxlSW5mb0FmdGVyU2VhcmNoOlxuXHRcdFx0J1Nob3dpbmcgICNyZWNvcmRGcm9tIHRvICNyZWNvcmRUbyBvZiAjcmVjb3Jkc0FmdGVyU2VhcmNoIGVudHJpZXMgKGZpbHRlcmVkIGZyb20gYSB0b3RhbCBvZiAjcmVjb3Jkc0FsbCBlbnRyaWVzKS4nLFxuXHRcdGNzdkRvd25sb2FkOiAnZG93bmxvYWQnLFxuXHRcdHNvcnRMYWJlbDogJ1NvcnQ6Jyxcblx0XHRwYWdpbmF0ZU5leHQ6ICdOZXh0IHBhZ2UnLFxuXHRcdHBhZ2luYXRlUHJldmlvdXM6ICdQcmV2aW91cyBwYWdlJyxcblx0XHRpbmxpbmVFZGl0RWRpdGVkOiAnUHJlc3MgZW50ZXIgdG8gc2F2ZSdcblx0fTtcblx0QElucHV0KCkgZ3RUZXh0czogR3RUZXh0cyA9IHRoaXMuZ3REZWZhdWx0VGV4dHM7XG5cdEBJbnB1dCgpIGd0Q2xhc3Nlczogc3RyaW5nO1xuXHRAT3V0cHV0KCkgZ3RFdmVudDogRXZlbnRFbWl0dGVyPEd0RXZlbnQ+ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXHRwdWJsaWMgZ3REZWZhdWx0T3B0aW9uczogR3RPcHRpb25zID0ge1xuXHRcdGNzdkRlbGltaXRlcjogJzsnLFxuXHRcdHN0YWNrOiBmYWxzZSxcblx0XHRsYXp5TG9hZDogZmFsc2UsXG5cdFx0Y2FjaGU6IGZhbHNlLFxuXHRcdGRlYm91bmNlVGltZTogMjAwLFxuXHRcdGhpZ2hsaWdodFNlYXJjaDogZmFsc2UsXG5cdFx0cm93U2VsZWN0aW9uOiBmYWxzZSxcblx0XHRyb3dTZWxlY3Rpb25BbGxvd011bHRpcGxlOiB0cnVlLFxuXHRcdHJvd0V4cGFuZEFsbG93TXVsdGlwbGU6IHRydWUsXG5cdFx0bnVtYmVyT2ZSb3dzOiAxMCxcblx0XHRyZXBvcnRDb2x1bW5XaWR0aDogZmFsc2UsXG5cdFx0YWxsb3dVbnNvcnRlZDogdHJ1ZSxcblx0XHRtdXRhdGVEYXRhOiB0cnVlXG5cdH07XG5cdHByaXZhdGUgX2d0T3B0aW9uczogR3RPcHRpb25zID0gdGhpcy5ndERlZmF1bHRPcHRpb25zO1xuXHRwdWJsaWMgc3RvcmU6IEFycmF5PGFueT4gPSBbXTtcblx0cHVibGljIGxvYWRpbmcgPSB0cnVlO1xuXHRwcml2YXRlIGRlYm91bmNlVGltZXI6IHZvaWQgPSBudWxsO1xuXHRwdWJsaWMgbG9hZGluZ1Byb3BlcnR5OiBzdHJpbmc7XG5cdHB1YmxpYyBsYXp5QWxsU2VsZWN0ZWQgPSBmYWxzZTtcblxuXHRASW5wdXQoKVxuXHRndEluZm86IEd0SW5mb3JtYXRpb24gPSB7XG5cdFx0cGFnZUN1cnJlbnQ6IDEsXG5cdFx0cGFnZVRvdGFsOiAwLFxuXHRcdHJlY29yZEZyb206IDAsXG5cdFx0cmVjb3JkVG86IDAsXG5cdFx0cmVjb3JkTGVuZ3RoOiB0aGlzLmd0T3B0aW9ucy5udW1iZXJPZlJvd3MsXG5cdFx0cmVjb3Jkc0FsbDogMCxcblx0XHRyZWNvcmRzQWZ0ZXJGaWx0ZXI6IDAsXG5cdFx0cmVjb3Jkc0FmdGVyU2VhcmNoOiAwXG5cdH07XG5cblx0cHVibGljIHJlZnJlc2hQaXBlID0gZmFsc2U7XG5cdHB1YmxpYyByZWZyZXNoVG90YWxzID0gZmFsc2U7XG5cdHB1YmxpYyByZWZyZXNoU29ydGluZyA9IGZhbHNlO1xuXHRwdWJsaWMgcmVmcmVzaEZpbHRlciA9IGZhbHNlO1xuXHRwdWJsaWMgcmVmcmVzaFBhZ2VBcnJheSA9IGZhbHNlO1xuXHRwcml2YXRlIGdsb2JhbElubGluZUVkaXRMaXN0ZW5lcjogRnVuY3Rpb247XG5cdHB1YmxpYyBlZGl0ZWRSb3dzOiB7XG5cdFx0W2tleTogc3RyaW5nXToge1xuXHRcdFx0Y2hhbmdlczogeyBba2V5OiBzdHJpbmddOiBHdFJlbmRlckZpZWxkPEd0Um93LCBhbnk+IH07XG5cdFx0XHRyb3c6IEd0Um93O1xuXHRcdH07XG5cdH0gPSB7fTtcblxuXHRwdWJsaWMgZGF0YTogeyBleHBvcnREYXRhOiBBcnJheTxhbnk+IH0gPSB7IGV4cG9ydERhdGE6IFtdIH07IC8vIFN0b3JlIGZpbHRlcmVkIGRhdGEgZm9yIGV4cG9ydFxuXG5cdGNvbnN0cnVjdG9yKHByaXZhdGUgcmVuZGVyZXI6IFJlbmRlcmVyMiwgcHJpdmF0ZSBndE1ldGFQaXBlOiBHdE1ldGFQaXBlKSB7XG5cdFx0dGhpcy5ndEV2ZW50LnN1YnNjcmliZSgoJGV2ZW50OiBHdEV2ZW50KSA9PiB7XG5cdFx0XHRpZiAoJGV2ZW50Lm5hbWUgPT09ICdndC1pbmZvJykge1xuXHRcdFx0XHR0aGlzLnVwZGF0ZVJlY29yZFJhbmdlKCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoJGV2ZW50Lm5hbWUgPT09ICdndC1yb3ctdXBkYXRlZCcpIHtcblx0XHRcdFx0dGhpcy51cGRhdGVUb3RhbHMoKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTb3J0IHRhYmxlIGJ5IG9iamVjdCBrZXkuXG5cdCAqIEBwYXJhbSBvYmplY3RLZXkgLSBuYW1lIG9mIGtleSB0byBzb3J0IG9uLlxuXHQgKiBAcGFyYW0gZXZlbnQgLSBzdWNoIGFzIGtleSBwcmVzcyBkdXJpbmcgc29ydGluZy5cblx0ICovXG5cdHB1YmxpYyBndFNvcnQgPSBmdW5jdGlvbihvYmplY3RLZXk6IHN0cmluZywgZXZlbnQ6IGFueSkge1xuXHRcdHRoaXMuaW5saW5lRWRpdENhbmNlbCgpOyAvLyBjYW5jZWwgaW5saW5lIGVkaXRpbmdcblxuXHRcdC8vIGxvb3AgdGhyb3VnaCBjdXJyZW50IHNldHRpbmdzXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9ndFNldHRpbmdzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAodGhpcy5fZ3RTZXR0aW5nc1tpXS5vYmplY3RLZXkgPT09IG9iamVjdEtleSkge1xuXHRcdFx0XHQvLyBjaGVjayBpZiBzb3J0aW5nIGlzIGRpc2FibGVkLi4uXG5cdFx0XHRcdGlmIChcblx0XHRcdFx0XHR0aGlzLl9ndFNldHRpbmdzW2ldLnNvcnQgJiZcblx0XHRcdFx0XHR0aGlzLl9ndFNldHRpbmdzW2ldLnNvcnQuaW5kZXhPZignZGlzYWJsZScpICE9PSAtMVxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHQvLyAuLi5pZiBzbywgZXhpdCBmdW5jdGlvbiB3aXRob3V0IGFwcGx5aW5nIGFueSBzb3J0aW5nXG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9IGVsc2UgaWYgKFxuXHRcdFx0XHRcdC8qIGNoZWNrIGlmIHNvcnRpbmcgaXMgdW5kZWZpbmVkLi4uICovIHR5cGVvZiB0aGlzLl9ndFNldHRpbmdzW2ldXG5cdFx0XHRcdFx0XHQuc29ydCA9PT0gJ3VuZGVmaW5lZCdcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0Ly8gLi4uaXMgc28sIHNldCBzb3J0aW5nIHByb3BlcnR5IHRvIGVuYWJsZVxuXHRcdFx0XHRcdHRoaXMuX2d0U2V0dGluZ3NbaV0uc29ydCA9ICdlbmFibGUnO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gY2hlY2sgbGVuZ3RoXG5cdFx0Y29uc3QgY3RybEtleSA9IGV2ZW50Lm1ldGFLZXkgfHwgZXZlbnQuY3RybEtleTtcblx0XHRjb25zdCBzb3J0ID0gdGhpcy5zb3J0T3JkZXIuc2xpY2UoMCk7XG5cblx0XHRsZXQgbWF0Y2ggPSAtMTtcblx0XHRsZXQgbWF0Y2hEZXNjID0gLTE7XG5cdFx0bGV0IHBvcyA9IC0xO1xuXG5cdFx0Ly8gY2hlY2sgaWYgcHJvcGVydHkgYWxyZWFkeSBleGl0c1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgc29ydC5sZW5ndGg7IGkrKykge1xuXHRcdFx0Y29uc3QgaGl0ID0gc29ydFtpXS5pbmRleE9mKG9iamVjdEtleSk7XG5cdFx0XHRpZiAoaGl0ICE9PSAtMSkge1xuXHRcdFx0XHRtYXRjaCA9IHRoaXMuc29ydE9yZGVyLmluZGV4T2Yob2JqZWN0S2V5KTtcblx0XHRcdFx0bWF0Y2hEZXNjID1cblx0XHRcdFx0XHRtYXRjaCA9PT0gLTEgPyB0aGlzLnNvcnRPcmRlci5pbmRleE9mKCctJyArIG9iamVjdEtleSkgOiBtYXRjaDtcblx0XHRcdFx0cG9zID0gTWF0aC5tYXgobWF0Y2gsIG1hdGNoRGVzYyk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gaWYgY3RybCBrZXkgb3IgbWV0YSBrZXkgaXMgcHJlc3MgdG9nZXRoZXIgd2l0aCBzb3J0Li4uXG5cdFx0aWYgKGN0cmxLZXkpIHtcblx0XHRcdGlmICh0aGlzLnNvcnRPcmRlclt0aGlzLnNvcnRPcmRlci5sZW5ndGggLSAxXSA9PT0gJyQkZ3RJbml0aWFsUm93SW5kZXgnKSB7XG5cdFx0XHRcdHRoaXMuc29ydE9yZGVyLnBvcCgpO1xuXHRcdFx0fVxuXHRcdFx0c3dpdGNoIChwb3MpIHtcblx0XHRcdFx0Ly8gLi4uYW5kIHByb3BlcnR5IGlzIG5vdCBzb3J0ZWQgYmVmb3JlLi4uXG5cdFx0XHRcdGNhc2UgLTE6XG5cdFx0XHRcdFx0Ly8gLi4uYWRkIHByb3BlcnR5IHRvIHNvcnRpbmdcblx0XHRcdFx0XHR0aGlzLnNvcnRPcmRlci5wdXNoKG9iamVjdEtleSk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0Ly8gLi4uYW5kIHByb3BlcnR5IGlzIHNvcnRlZCBiZWZvcmUuLi5cblx0XHRcdFx0XHRpZiAobWF0Y2ggIT09IC0xKSB7XG5cdFx0XHRcdFx0XHQvLyAuLi5jaGFuZ2UgZnJvbSBhc2MgdG8gZGVzYyBpZiBzb3J0ZWQgYXNjXG5cdFx0XHRcdFx0XHR0aGlzLnNvcnRPcmRlcltwb3NdID0gJy0nICsgb2JqZWN0S2V5O1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAodGhpcy5zb3J0T3JkZXIubGVuZ3RoID4gMSkge1xuXHRcdFx0XHRcdFx0Ly8gLi4ucmVtb3ZlIHNvcnRpbmcgaWYgc29ydGVkIGRlc2Ncblx0XHRcdFx0XHRcdGlmIChjdHJsS2V5KSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuc29ydE9yZGVyW3Bvc10gPSBvYmplY3RLZXk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHR0aGlzLnNvcnRPcmRlci5zcGxpY2UocG9zLCAxKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IGVsc2UgaWYgKHRoaXMuc29ydE9yZGVyLmxlbmd0aCA9PT0gMSkge1xuXHRcdFx0XHRcdFx0Ly8gLi4uc2V0IHNvcnRpbmcgdG8gYXNjIGlmIG9ubHkgc29ydGVkIHByb3BlcnR5XG5cdFx0XHRcdFx0XHR0aGlzLnNvcnRPcmRlcltwb3NdID0gb2JqZWN0S2V5O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0LyogaWYgY3RybCBrZXkgb3IgbWV0YSBrZXkgaXMgbm90IHByZXNzIHRvZ2V0aGVyIHdpdGggc29ydC4uLiAqL1xuXHRcdFx0c3dpdGNoIChwb3MpIHtcblx0XHRcdFx0Ly8gLi4uYW5kIHByb3BlcnR5IGlzIG5vdCBzb3J0ZWQgYmVmb3JlLi4uXG5cdFx0XHRcdGNhc2UgLTE6XG5cdFx0XHRcdFx0Ly8gLi4uc29ydCBieSBwcm9wZXJ0eVxuXHRcdFx0XHRcdHRoaXMuc29ydE9yZGVyID0gW29iamVjdEtleV07XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0Ly8gLi4uY2hhbmdlIGZyb20gZGVzYyB0byBhc2MgYW5kIHZpc2UgdmVyc2Fcblx0XHRcdFx0XHR0aGlzLnNvcnRPcmRlciA9XG5cdFx0XHRcdFx0XHRtYXRjaCAhPT0gLTFcblx0XHRcdFx0XHRcdFx0PyBbJy0nICsgb2JqZWN0S2V5XVxuXHRcdFx0XHRcdFx0XHQ6IGN0cmxLZXkgfHwgIXRoaXMuZ3RPcHRpb25zLmFsbG93VW5zb3J0ZWRcblx0XHRcdFx0XHRcdFx0XHQ/IFtvYmplY3RLZXldXG5cdFx0XHRcdFx0XHRcdFx0OiBbXTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyB1cGRhdGUgc2V0dGluZ3Mgb2JqZWN0IHdpdGggbmV3IHNvcnRpbmcgaW5mb3JtYXRpb25cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2d0U2V0dGluZ3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmICh0aGlzLl9ndFNldHRpbmdzW2ldLm9iamVjdEtleSA9PT0gb2JqZWN0S2V5KSB7XG5cdFx0XHRcdHN3aXRjaCAodGhpcy5fZ3RTZXR0aW5nc1tpXS5zb3J0KSB7XG5cdFx0XHRcdFx0Ly8gaWYgc29ydGVkIGFzYy4uLlxuXHRcdFx0XHRcdGNhc2UgJ2FzYyc6XG5cdFx0XHRcdFx0XHQvLyAuLi5jaGFuZ2UgdG8gZGVzY1xuXHRcdFx0XHRcdFx0dGhpcy5fZ3RTZXR0aW5nc1tpXS5zb3J0ID0gJ2Rlc2MnO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Ly8gaWYgc29ydGVkIGRlc2MuLi5cblx0XHRcdFx0XHRjYXNlICdkZXNjJzpcblx0XHRcdFx0XHRcdC8vIC4uLmNoYW5nZSB0byBhc2MgaWYgaXQncyB0aGUgb25seSBzb3J0ZWQgcHJvcGVydHkgb3RoZXJ3aXNlIHJlbW92ZSBzb3J0aW5nXG5cdFx0XHRcdFx0XHR0aGlzLl9ndFNldHRpbmdzW2ldLnNvcnQgPVxuXHRcdFx0XHRcdFx0XHQodGhpcy5zb3J0T3JkZXIubGVuZ3RoID09PSAxICYmIHNvcnQubGVuZ3RoIDwgMikgfHxcblx0XHRcdFx0XHRcdFx0Y3RybEtleSB8fFxuXHRcdFx0XHRcdFx0XHQhdGhpcy5ndE9wdGlvbnMuYWxsb3dVbnNvcnRlZFxuXHRcdFx0XHRcdFx0XHRcdD8gJ2FzYydcblx0XHRcdFx0XHRcdFx0XHQ6ICdlbmFibGUnO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Ly8gaWYgc29ydGluZyBlbmFibGVkLi4uXG5cdFx0XHRcdFx0Y2FzZSAnZW5hYmxlJzpcblx0XHRcdFx0XHRcdC8vIC4uLmNoYW5nZSB0byBhc2Ncblx0XHRcdFx0XHRcdHRoaXMuX2d0U2V0dGluZ3NbaV0uc29ydCA9ICdhc2MnO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5fZ3RTZXR0aW5nc1tpXS5zb3J0T3JkZXIgPVxuXHRcdFx0XHRcdHRoaXMuX2d0U2V0dGluZ3NbaV0uc29ydCA9PT0gJ2VuYWJsZSdcblx0XHRcdFx0XHRcdD8gdGhpcy5fZ3RTZXR0aW5ncy5sZW5ndGggLSAxXG5cdFx0XHRcdFx0XHQ6IHRoaXMuc29ydE9yZGVyLmluZGV4T2Yob2JqZWN0S2V5KSA9PT0gLTFcblx0XHRcdFx0XHRcdFx0PyB0aGlzLnNvcnRPcmRlci5pbmRleE9mKCctJyArIG9iamVjdEtleSlcblx0XHRcdFx0XHRcdFx0OiB0aGlzLnNvcnRPcmRlci5pbmRleE9mKG9iamVjdEtleSk7XG5cdFx0XHR9IGVsc2UgaWYgKFxuXHRcdFx0XHR0aGlzLl9ndFNldHRpbmdzW2ldLnNvcnQgJiZcblx0XHRcdFx0dGhpcy5fZ3RTZXR0aW5nc1tpXS5zb3J0LmluZGV4T2YoJ2Rpc2FibGUnKSA9PT0gLTEgJiZcblx0XHRcdFx0dGhpcy5zb3J0T3JkZXIuaW5kZXhPZih0aGlzLl9ndFNldHRpbmdzW2ldLm9iamVjdEtleSkgPT09IC0xICYmXG5cdFx0XHRcdHRoaXMuc29ydE9yZGVyLmluZGV4T2YoJy0nICsgdGhpcy5fZ3RTZXR0aW5nc1tpXS5vYmplY3RLZXkpID09PSAtMVxuXHRcdFx0KSB7XG5cdFx0XHRcdHRoaXMuX2d0U2V0dGluZ3NbaV0uc29ydCA9ICdlbmFibGUnO1xuXHRcdFx0XHR0aGlzLl9ndFNldHRpbmdzW2ldLnNvcnRPcmRlciA9IHRoaXMuX2d0U2V0dGluZ3MubGVuZ3RoIC0gMTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyByZWZyZXNoIHNvcnRpbmcgcGlwZVxuXHRcdHRoaXMucmVmcmVzaFNvcnRpbmcgPSAhdGhpcy5yZWZyZXNoU29ydGluZztcblx0XHR0aGlzLnJlZnJlc2hQYWdlQXJyYXkgPSAhdGhpcy5yZWZyZXNoUGFnZUFycmF5O1xuXG5cdFx0Ly8gc29ydCBieSBpbml0aWFsIHNvcnQgb3JkZXIgYXMgbGFzdCByZXNvcnRcblx0XHR0aGlzLnNvcnRPcmRlci5wdXNoKCckJGd0SW5pdGlhbFJvd0luZGV4Jyk7XG5cblx0XHQvLyBlbWl0IHNvcnQgZXZlbnRcblx0XHR0aGlzLmd0RXZlbnQuZW1pdCh7XG5cdFx0XHRuYW1lOiAnZ3Qtc29ydGluZy1hcHBsaWVkJyxcblx0XHRcdHZhbHVlOiB0aGlzLnNvcnRPcmRlclxuXHRcdH0pO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDaGFuZ2UgbnVtYmVyIG9mIHJvd3MgdG8gYmUgZGlzcGxheWVkLlxuXHQgKiBAcGFyYW0gcm93TGVuZ3RoIC0gdG90YWwgbnVtYmVyIG9mIHJvd3MuXG5cdCAqIEBwYXJhbSByZXNldCAtIHNob3VsZCBwYWdlIGJlIHJlc2V0IHRvIGZpcnN0IHBhZ2UuXG5cdCAqL1xuXHRwdWJsaWMgY2hhbmdlUm93TGVuZ3RoID0gZnVuY3Rpb24ocm93TGVuZ3RoOiBhbnksIHJlc2V0PzogYm9vbGVhbikge1xuXHRcdGxldCBsZW5ndGhWYWx1ZSA9IGlzTmFOKHBhcnNlSW50KHJvd0xlbmd0aCwgMTApKVxuXHRcdFx0PyAwXG5cdFx0XHQ6IHBhcnNlSW50KHJvd0xlbmd0aCwgMTApO1xuXHRcdGxldCBuZXdQb3NpdGlvbiA9IDE7XG5cblx0XHRpZiAoIWxlbmd0aFZhbHVlICYmIHRoaXMuZ3REYXRhKSB7XG5cdFx0XHRsZW5ndGhWYWx1ZSA9IHRoaXMuZ3REYXRhLmxlbmd0aDtcblx0XHR9XG5cblx0XHQvLyBpZiByZXNldCBpcyBub3QgdHJ1ZSBhbmQgd2UncmUgbm90IGxhenkgbG9hZGluZyBkYXRhLi4uXG5cdFx0aWYgKHJlc2V0ICE9PSB0cnVlICYmIHRoaXMuX2d0T3B0aW9ucy5sYXp5TG9hZCAhPT0gdHJ1ZSkge1xuXHRcdFx0Ly8gLi4uZ2V0IGN1cnJlbnQgcG9zaXRpb24gaW4gcmVjb3JkIHNldFxuXHRcdFx0Y29uc3QgY3VycmVudFJlY29yZCA9XG5cdFx0XHRcdHRoaXMuZ3RJbmZvLnJlY29yZExlbmd0aCAqICh0aGlzLmd0SW5mby5wYWdlQ3VycmVudCAtIDEpO1xuXHRcdFx0Y29uc3QgY3VycmVudFBvc2l0aW9uID1cblx0XHRcdFx0dGhpcy5fZ3REYXRhLmluZGV4T2YodGhpcy5fZ3REYXRhW2N1cnJlbnRSZWNvcmRdKSArIDE7XG5cblx0XHRcdC8vIC4uLmdldCBuZXcgcG9zaXRpb25cblx0XHRcdG5ld1Bvc2l0aW9uID0gTWF0aC5jZWlsKGN1cnJlbnRQb3NpdGlvbiAvIGxlbmd0aFZhbHVlKTtcblx0XHR9XG5cblx0XHQvLyBjaGFuZ2Ugcm93IGxlbmd0aFxuXHRcdHRoaXMuZ3RJbmZvLnJlY29yZExlbmd0aCA9IGxlbmd0aFZhbHVlO1xuXG5cdFx0Ly8gZ28gdG8gbmV3IHBvc2l0aW9uXG5cdFx0dGhpcy5ndEluZm8ucGFnZUN1cnJlbnQgPSBuZXdQb3NpdGlvbjtcblxuXHRcdC8vIGlmIGxhenkgbG9hZGluZyBkYXRhLi4uXG5cdFx0aWYgKHRoaXMuX2d0T3B0aW9ucy5sYXp5TG9hZCkge1xuXHRcdFx0Ly8gLi4ucmVwbGFjZSBkYXRhIHdpdGggcGxhY2UgaG9sZGVycyBmb3IgbmV3IGRhdGFcblx0XHRcdHRoaXMuX2d0RGF0YVswXSA9IHRoaXMubG9hZGluZ0NvbnRlbnQobGVuZ3RoVmFsdWUpO1xuXG5cdFx0XHQvLyAuLi5lbXB0eSBjdXJyZW50IHN0b3JlXG5cdFx0XHR0aGlzLnN0b3JlID0gW107XG5cdFx0fVxuXG5cdFx0Ly8gdGhpcy51cGRhdGVSZWNvcmRSYW5nZSgpO1xuXG5cdFx0dGhpcy5ndEV2ZW50LmVtaXQoe1xuXHRcdFx0bmFtZTogJ2d0LXJvdy1sZW5ndGgtY2hhbmdlZCcsXG5cdFx0XHR2YWx1ZTogbGVuZ3RoVmFsdWVcblx0XHR9KTtcblx0fTtcblxuXHQvKipcblx0ICogRm9yY2UgYSByZWRyYXcgb2YgdGFibGUgcm93cy5cblx0ICogQXMgdGhlIHRhYmxlIHVzZXMgcHVyZSBwaXBlcywgd2UgbmVlZCB0byBmb3JjZSBhIHJlZHJhdyBpZiBhbiBvYmplY3QgaW4gdGhlIGFycmF5IGlzIGNoYW5nZWQgdG8gc2VlIHRoZSBjaGFuZ2VzLlxuXHQgKi9cblx0cHVibGljIHJlZHJhdyA9IGZ1bmN0aW9uKCRldmVudD86IGFueSkge1xuXHRcdHRoaXMucmVmcmVzaFNvcnRpbmcgPSAhdGhpcy5yZWZyZXNoU29ydGluZztcblx0XHR0aGlzLnJlZnJlc2hQYWdlQXJyYXkgPSAhdGhpcy5yZWZyZXNoUGFnZUFycmF5O1xuXHRcdHRoaXMucmVmcmVzaFBpcGUgPSAhdGhpcy5yZWZyZXNoUGlwZTtcblx0fTtcblxuXHQvKiogVXBkYXRlIHJlY29yZCByYW5nZS4gKi9cblx0cHJpdmF0ZSB1cGRhdGVSZWNvcmRSYW5nZSgpIHtcblx0XHR0aGlzLmd0SW5mby5yZWNvcmRGcm9tID1cblx0XHRcdHRoaXMuZ3RJbmZvLnJlY29yZHNBZnRlclNlYXJjaCA9PT0gMFxuXHRcdFx0XHQ/IDBcblx0XHRcdFx0OiAodGhpcy5ndEluZm8ucGFnZUN1cnJlbnQgLSAxKSAqIHRoaXMuZ3RJbmZvLnJlY29yZExlbmd0aCArIDE7XG5cdFx0dGhpcy5ndEluZm8ucmVjb3JkVG8gPVxuXHRcdFx0dGhpcy5ndEluZm8ucmVjb3Jkc0FmdGVyU2VhcmNoIDxcblx0XHRcdHRoaXMuZ3RJbmZvLnBhZ2VDdXJyZW50ICogdGhpcy5ndEluZm8ucmVjb3JkTGVuZ3RoXG5cdFx0XHRcdD8gdGhpcy5ndEluZm8ucmVjb3Jkc0FmdGVyU2VhcmNoXG5cdFx0XHRcdDogdGhpcy5ndEluZm8ucGFnZUN1cnJlbnQgKiB0aGlzLmd0SW5mby5yZWNvcmRMZW5ndGg7XG5cdH1cblxuXHQvKiogVXBkYXRlIHRvdGFscy4gKi9cblx0cHJpdmF0ZSB1cGRhdGVUb3RhbHMoKSB7XG5cdFx0dGhpcy5yZWZyZXNoVG90YWxzID0gIXRoaXMucmVmcmVzaFRvdGFscztcblx0fVxuXG5cdC8qKiBHbyB0byBuZXh0IHBhZ2UuICovXG5cdHB1YmxpYyBuZXh0UGFnZSA9IGZ1bmN0aW9uKCkge1xuXHRcdGNvbnN0IHBhZ2UgPVxuXHRcdFx0dGhpcy5ndEluZm8ucGFnZUN1cnJlbnQgPT09IHRoaXMuZ3RJbmZvLnBhZ2VUb3RhbFxuXHRcdFx0XHQ/IHRoaXMuZ3RJbmZvLnBhZ2VUb3RhbFxuXHRcdFx0XHQ6IHRoaXMuZ3RJbmZvLnBhZ2VDdXJyZW50ICsgMTtcblx0XHR0aGlzLmdvVG9QYWdlKHBhZ2UpO1xuXHR9O1xuXG5cdC8qKiBHbyB0byBwcmV2aW91cyBwYWdlLiAqL1xuXHRwdWJsaWMgcHJldmlvdXNQYWdlID0gZnVuY3Rpb24oKSB7XG5cdFx0Y29uc3QgcGFnZSA9XG5cdFx0XHR0aGlzLmd0SW5mby5wYWdlQ3VycmVudCA9PT0gMSA/IDEgOiB0aGlzLmd0SW5mby5wYWdlQ3VycmVudCAtIDE7XG5cdFx0dGhpcy5nb1RvUGFnZShwYWdlKTtcblx0fTtcblxuXHQvKiogUmVxdWVzdCBtb3JlIGRhdGEgKHVzZWQgd2hlbiBsYXp5IGxvYWRpbmcpICovXG5cdHByaXZhdGUgZ2V0RGF0YSA9IGZ1bmN0aW9uKCkge1xuXHRcdC8vIC4uLmVtaXQgZXZlbnQgcmVxdWVzdGluZyBmb3IgbW9yZSBkYXRhXG5cdFx0dGhpcy5ndEV2ZW50LmVtaXQoe1xuXHRcdFx0bmFtZTogJ2d0LXBhZ2UtY2hhbmdlZC1sYXp5Jyxcblx0XHRcdHZhbHVlOiB7XG5cdFx0XHRcdHBhZ2VDdXJyZW50OiB0aGlzLmd0SW5mby5wYWdlQ3VycmVudCxcblx0XHRcdFx0cmVjb3JkTGVuZ3RoOiB0aGlzLmd0SW5mby5yZWNvcmRMZW5ndGhcblx0XHRcdH1cblx0XHR9KTtcblx0fTtcblxuXHQvKipcblx0ICogR28gdG8gc3BlY2lmaWMgcGFnZS5cblx0ICogQHBhcmFtIHBhZ2UgLSBwYWdlIG51bWJlci5cblx0ICovXG5cdHB1YmxpYyBnb1RvUGFnZSA9IGZ1bmN0aW9uKHBhZ2U6IG51bWJlcikge1xuXHRcdGNvbnN0IHByZXZpb3VzUGFnZSA9IHRoaXMuZ3RJbmZvLnBhZ2VDdXJyZW50O1xuXHRcdHRoaXMuZ3RJbmZvLnBhZ2VDdXJyZW50ID0gcGFnZTtcblx0XHR0aGlzLmlubGluZUVkaXRDYW5jZWwoKTsgLy8gY2FuY2VsIGlubGluZSBlZGl0XG5cblx0XHQvLyBpZiBsYXp5IGxvYWRpbmcgYW5kIGlmIHBhZ2UgY29udGFpbnMgbm8gcmVjb3Jkcy4uLlxuXHRcdGlmICh0aGlzLl9ndE9wdGlvbnMubGF6eUxvYWQpIHtcblx0XHRcdC8vIC4uLmlmIGRhdGEgZm9yIGN1cnJlbnQgcGFnZSBjb250YWlucyBubyBlbnRyaWVzLi4uXG5cdFx0XHRpZiAoXG5cdFx0XHRcdHRoaXMuX2d0T3B0aW9ucy5jYWNoZSA9PT0gZmFsc2UgfHxcblx0XHRcdFx0dGhpcy5fZ3REYXRhW3RoaXMuZ3RJbmZvLnBhZ2VDdXJyZW50IC0gMV0ubGVuZ3RoID09PSAwXG5cdFx0XHQpIHtcblx0XHRcdFx0Ly8gLi4uY3JlYXRlIHRlbXBvcmFyeSBjb250ZW50IHdoaWxlIHdhaXRpbmcgZm9yIGRhdGFcblx0XHRcdFx0dGhpcy5fZ3REYXRhW3RoaXMuZ3RJbmZvLnBhZ2VDdXJyZW50IC0gMV0gPSB0aGlzLmxvYWRpbmdDb250ZW50KFxuXHRcdFx0XHRcdHRoaXMuZ3RJbmZvLnJlY29yZExlbmd0aFxuXHRcdFx0XHQpO1xuXHRcdFx0XHR0aGlzLmxvYWRpbmcgPSB0cnVlOyAvLyBsb2FkaW5nIHRydWVcblx0XHRcdH1cblx0XHRcdC8vIC4uLmlmIGZpcnN0IGVudHJ5IGluIGN1cnJlbnQgcGFnZSBlcXVhbHMgb3VyIGxvYWRpbmcgcGxhY2Vob2xkZXIuLi5cblx0XHRcdGlmIChcblx0XHRcdFx0dGhpcy5fZ3REYXRhW3RoaXMuZ3RJbmZvLnBhZ2VDdXJyZW50IC0gMV1bMF1bdGhpcy5sb2FkaW5nUHJvcGVydHldID09PVxuXHRcdFx0XHR0aGlzLmd0VGV4dHMubG9hZGluZ1xuXHRcdFx0KSB7XG5cdFx0XHRcdC8vIC4uLmdldCBkYXRhXG5cdFx0XHRcdGNsZWFyVGltZW91dCh0aGlzLmRlYm91bmNlVGltZXIpO1xuXHRcdFx0XHR0aGlzLmRlYm91bmNlVGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcblx0XHRcdFx0XHR0aGlzLmdldERhdGEoKTtcblx0XHRcdFx0fSwgdGhpcy5fZ3RPcHRpb25zLmRlYm91bmNlVGltZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gdGhpcy51cGRhdGVSZWNvcmRSYW5nZSgpO1xuXG5cdFx0Ly8gLi4uZW1pdCBwYWdlIGNoYW5nZSBldmVudFxuXHRcdGlmIChwcmV2aW91c1BhZ2UgIT09IHBhZ2UpIHtcblx0XHRcdHRoaXMuZ3RFdmVudC5lbWl0KHtcblx0XHRcdFx0bmFtZTogJ2d0LXBhZ2UtY2hhbmdlZCcsXG5cdFx0XHRcdHZhbHVlOiB7XG5cdFx0XHRcdFx0cGFnZUN1cnJlbnQ6IHRoaXMuZ3RJbmZvLnBhZ2VDdXJyZW50LFxuXHRcdFx0XHRcdHBhZ2VQcmV2aW91czogcHJldmlvdXNQYWdlLFxuXHRcdFx0XHRcdHJlY29yZExlbmd0aDogdGhpcy5ndEluZm8ucmVjb3JkTGVuZ3RoXG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogR2V0IG1ldGEgZGF0YSBmb3Igcm93LlxuXHQgKi9cblx0cHVibGljIGdldFJvd1N0YXRlKHJvdzogUik6IEd0Um93TWV0YSB7XG5cdFx0cmV0dXJuIHR5cGVvZiB0aGlzLm1ldGFJbmZvW3Jvdy4kJGd0Um93SWRdID09PSAndW5kZWZpbmVkJ1xuXHRcdFx0PyBudWxsXG5cdFx0XHQ6IHRoaXMubWV0YUluZm9bcm93LiQkZ3RSb3dJZF07XG5cdH1cblxuXHQvKipcblx0ICogRXhwYW5kIGFsbCByb3dzLlxuXHQgKiBAcGFyYW0gZXhwYW5kZWRSb3cgLSBjb21wb25lbnQgdG8gcmVuZGVyIHdoZW4gcm93cyBhcmUgZXhwYW5kZWQuXG5cdCAqL1xuXHRwdWJsaWMgZXhwYW5kQWxsUm93cyhleHBhbmRlZFJvdzogeyBjb21wb25lbnQ6IFR5cGU8Qz47IGRhdGE/OiBhbnkgfSk6IHZvaWQge1xuXHRcdHRoaXMuZXhwYW5kZWRSb3cgPSBleHBhbmRlZFJvdztcblx0XHR0aGlzLl90b2dnbGVBbGxSb3dQcm9wZXJ0eSgnaXNPcGVuJywgdHJ1ZSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29sbGFwc2UgYWxsIHJvd3MuXG5cdCAqL1xuXHRwdWJsaWMgY29sbGFwc2VBbGxSb3dzKCk6IHZvaWQge1xuXHRcdHRoaXMuX3RvZ2dsZUFsbFJvd1Byb3BlcnR5KCdpc09wZW4nLCBmYWxzZSk7XG5cdH1cblxuXHQvKipcblx0ICogU2VsZWN0IGFsbCByb3dzLlxuXHQgKi9cblx0cHVibGljIHNlbGVjdEFsbFJvd3MoKTogdm9pZCB7XG5cdFx0dGhpcy5fdG9nZ2xlQWxsUm93UHJvcGVydHkoJ2lzU2VsZWN0ZWQnLCB0cnVlKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBEZXNlbGVjdCBhbGwgcm93cy5cblx0ICovXG5cdHB1YmxpYyBkZXNlbGVjdEFsbFJvd3MoKTogdm9pZCB7XG5cdFx0dGhpcy5fdG9nZ2xlQWxsUm93UHJvcGVydHkoJ2lzU2VsZWN0ZWQnLCBmYWxzZSk7XG5cdH1cblxuXHQvKipcblx0ICogVG9nZ2xlIGFsbCByb3dzLlxuXHQgKi9cblx0cHVibGljIHRvZ2dsZUFsbFJvd3MoKTogdm9pZCB7XG5cdFx0aWYgKHRoaXMuX2d0T3B0aW9ucy5sYXp5TG9hZCkge1xuXHRcdFx0aWYgKCF0aGlzLmxhenlBbGxTZWxlY3RlZCB8fCB0aGlzLnNlbGVjdGVkUm93cy5sZW5ndGggPT09IDApIHtcblx0XHRcdFx0dGhpcy5zZWxlY3RBbGxSb3dzKCk7XG5cdFx0XHRcdHRoaXMubGF6eUFsbFNlbGVjdGVkID0gdHJ1ZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuZGVzZWxlY3RBbGxSb3dzKCk7XG5cdFx0XHRcdHRoaXMubGF6eUFsbFNlbGVjdGVkID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICh0aGlzLnNlbGVjdGVkUm93cy5sZW5ndGggIT09IHRoaXMuZ3REYXRhLmxlbmd0aCkge1xuXHRcdFx0XHR0aGlzLnNlbGVjdEFsbFJvd3MoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuZGVzZWxlY3RBbGxSb3dzKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFRvZ2dsZSByb3cgY29sbGFwc2VkIHN0YXRlIGllLiBleHBhbmRlZC9vcGVuIG9yIGNvbGxhcHNlZC9jbG9zZWQuXG5cdCAqIEBwYXJhbSByb3cgLSByb3cgb2JqZWN0IHRoYXQgc2hvdWxkIGJlIGV4cGFuZGVkL2NvbGxhcHNlZC5cblx0ICogQHBhcmFtIGV4cGFuZGVkUm93IC0gY29tcG9uZW50IHRvIHJlbmRlciB3aGVuIHJvdyBpcyBleHBhbmRlZC5cblx0ICovXG5cdHB1YmxpYyB0b2dnbGVDb2xsYXBzZShcblx0XHRyb3c6IEd0Um93LFxuXHRcdGV4cGFuZGVkUm93PzogeyBjb21wb25lbnQ6IFR5cGU8Qz47IGRhdGE/OiBhbnkgfVxuXHQpIHtcblx0XHRpZiAoZXhwYW5kZWRSb3cpIHtcblx0XHRcdHRoaXMuZXhwYW5kZWRSb3cgPSBleHBhbmRlZFJvdztcblx0XHR9XG5cdFx0dGhpcy5fdG9nZ2xlUm93UHJvcGVydHkocm93LCAnaXNPcGVuJyk7XG5cdH1cblxuXHQvKipcblx0ICogVG9nZ2xlIHJvdyBzZWxlY3RlZCBzdGF0ZSBpZS4gc2VsZWN0ZWQgb3Igbm90LlxuXHQgKiBAcGFyYW0gcm93IC0gcm93IG9iamVjdCB0aGF0IHNob3VsZCBiZSBzZWxlY3RlZC9kZXNlbGVjdGVkLlxuXHQgKi9cblx0cHVibGljIHRvZ2dsZVNlbGVjdChyb3c6IEd0Um93KSB7XG5cdFx0dGhpcy5fdG9nZ2xlUm93UHJvcGVydHkocm93LCAnaXNTZWxlY3RlZCcpO1xuXHR9XG5cblx0cHVibGljIHJvd0NsaWNrKHJvdzogR3RSb3csICRldmVudDogTW91c2VFdmVudCkge1xuXHRcdHRoaXMuZ3RFdmVudC5lbWl0KHtcblx0XHRcdG5hbWU6ICdndC1yb3ctY2xpY2tlZCcsXG5cdFx0XHR2YWx1ZTogeyByb3c6IHJvdywgZXZlbnQ6ICRldmVudCB9XG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogVXBkYXRlIHJvdyBkYXRhLlxuXHQgKiBAcGFyYW0gcm93IC0gcm93IG9iamVjdCB0aGF0IGhhcyBiZWVuIGVkaXRlZC5cblx0ICogQHBhcmFtIG9sZFZhbHVlIC0gcm93IG9iamVjdCBiZWZvcmUgZWRpdC5cblx0ICovXG5cdHB1YmxpYyB1cGRhdGVSb3cocm93OiBHdFJvdywgb2xkVmFsdWU6IEd0Um93KSB7XG5cdFx0dGhpcy5fdG9nZ2xlUm93UHJvcGVydHkocm93LCAnaXNVcGRhdGVkJywgb2xkVmFsdWUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIHJlbW92ZXMgYSByb3cgZnJvbSB0aGUgdGFibGVcblx0ICogQHBhcmFtIHJvdyAtIHRoZSByb3cgb2JqZWN0IHRvIHJlbW92ZVxuXHQgKi9cblx0cHVibGljIHJlbW92ZVJvdyhyb3c6IEd0Um93KSB7XG5cdFx0aWYgKHRoaXMuaXNSb3dTZWxlY3RlZChyb3cpKSB7XG5cdFx0XHR0aGlzLnRvZ2dsZVNlbGVjdChyb3cpO1xuXHRcdH1cblx0XHRjb25zdCBpbmRleCA9IHRoaXMuX2d0RGF0YS5pbmRleE9mKHJvdyk7XG5cdFx0dGhpcy5fZ3REYXRhLnNwbGljZShpbmRleCwgMSk7XG5cdH1cblxuXHQvKipcblx0ICogY2hlY2sgaWYgYSByb3cgaXMgc2VsZWN0ZWRcblx0ICogQHBhcmFtIHJvdyAtIHJvdyBvYmplY3Rcblx0ICovXG5cdHB1YmxpYyBpc1Jvd1NlbGVjdGVkKHJvdzogR3RSb3cpOiBib29sZWFuIHtcblx0XHRyZXR1cm4gKFxuXHRcdFx0dGhpcy5tZXRhSW5mb1tyb3cuJCRndFJvd0lkXSAmJiB0aGlzLm1ldGFJbmZvW3Jvdy4kJGd0Um93SWRdLmlzU2VsZWN0ZWRcblx0XHQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFVwZGF0ZSBtZXRhIGluZm8gZm9yIGFsbCByb3dzLCBpZS4gaXNTZWxlY3RlZCwgaXNPcGVuLlxuXHQgKiBAcGFyYW0gYXJyYXkgLSBhcnJheSB0aGF0IGhvbGRzIHJvd3MgdGhhdCBuZWVkIHRvIGJlIHVwZGF0ZWQuXG5cdCAqIEBwYXJhbSBwcm9wZXJ0eSAtIG5hbWUgb2YgcHJvcGVydHkgdGhhdCBzaG91bGQgYmUgY2hhbmdlZC90b2dnbGVkLlxuXHQgKiBAcGFyYW0gYWN0aXZlIC0gc2hvdWxkIHJvd3MgYmUgZXhwYW5kZWQvb3Blbiwgc2VsZWN0ZWQuXG5cdCAqIEBwYXJhbSBleGNlcHRpb24gLSB1cGRhdGUgYWxsIHJvd3MgZXhjZXB0IHRoaXMgb25lLlxuXHQgKi9cblx0cHJpdmF0ZSBfdXBkYXRlTWV0YUluZm8oXG5cdFx0YXJyYXk6IEFycmF5PEd0Um93Pixcblx0XHRwcm9wZXJ0eTogc3RyaW5nLFxuXHRcdGFjdGl2ZTogYm9vbGVhbixcblx0XHRleGNlcHRpb24/OiBHdFJvd1xuXHQpIHtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAoIXRoaXMubWV0YUluZm9bYXJyYXlbaV0uJCRndFJvd0lkXSkge1xuXHRcdFx0XHR0aGlzLm1ldGFJbmZvW2FycmF5W2ldLiQkZ3RSb3dJZF0gPSB7fTtcblx0XHRcdH1cblx0XHRcdGlmIChleGNlcHRpb24gJiYgYXJyYXlbaV0uJCRndFJvd0lkID09PSBleGNlcHRpb24uJCRndFJvd0lkKSB7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLm1ldGFJbmZvW2FycmF5W2ldLiQkZ3RSb3dJZF1bcHJvcGVydHldID0gYWN0aXZlO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBQdXNoIHNlbGVjdGVkL2V4cGFuZGVkIGxhenkgbG9hZGVkIHJvd3MgdG8gYXJyYXkgd2l0aCBtZXRhIGRhdGEuXG5cdCAqIEBwYXJhbSB0YXJnZXQgLSBhcnJheSB0byB3aGljaCByb3dzIHNob3VsZCBiZSBhZGRlZC5cblx0ICogQHBhcmFtIHNvdXJjZSAtIGFycmF5IHRoYXQgaG9sZHMgcm93cyB0aGF0IHNob3VsZCBiZSBhZGRlZC5cblx0ICogQHJldHVybnMgYXJyYXkgd2l0aCBhZGRlZCByb3dzLlxuXHQgKi9cblx0cHJpdmF0ZSBfcHVzaExhenlSb3dzKFxuXHRcdHRhcmdldDogQXJyYXk8R3RSb3c+LFxuXHRcdHNvdXJjZTogQXJyYXk8R3RSb3c+XG5cdCk6IEFycmF5PEd0Um93PiB7XG5cdFx0Y29uc3QgVU5JUVVFX1JPV1MgPSB0YXJnZXQubWFwKHJvdyA9PiByb3cuJCRndFJvd0lkKTtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHNvdXJjZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0Ly8gb25seSBhZGQgaWYgbm90IGFscmVhZHkgaW4gbGlzdFxuXHRcdFx0aWYgKFVOSVFVRV9ST1dTLmluZGV4T2Yoc291cmNlW2ldLiQkZ3RSb3dJZCkgPT09IC0xKSB7XG5cdFx0XHRcdHRhcmdldC5wdXNoKHNvdXJjZVtpXSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0YXJnZXQ7XG5cdH1cblxuXHQvKipcblx0ICogVG9nZ2xlIG1ldGEgaW5mbyBmb3IgYWxsIHJvd3MsIGllLiBpc1NlbGVjdGVkLCBpc09wZW4uXG5cdCAqIEBwYXJhbSBwcm9wZXJ0eSAtIG5hbWUgb2YgcHJvcGVydHkgdGhhdCBzaG91bGQgYmUgY2hhbmdlZC90b2dnbGVkLlxuXHQgKiBAcGFyYW0gYWN0aXZlIC0gc2hvdWxkIHJvd3MgYmUgZXhwYW5kZWQvb3Blbiwgc2VsZWN0ZWQuXG5cdCAqL1xuXHRwcml2YXRlIF90b2dnbGVBbGxSb3dQcm9wZXJ0eShwcm9wZXJ0eTogc3RyaW5nLCBhY3RpdmU6IGJvb2xlYW4pIHtcblx0XHRsZXQgZXZlbnROYW1lOiBzdHJpbmc7XG5cdFx0bGV0IGV2ZW50VmFsdWU6IGFueTtcblx0XHRzd2l0Y2ggKHByb3BlcnR5KSB7XG5cdFx0XHRjYXNlICdpc09wZW4nOlxuXHRcdFx0XHQvLyBjaGVjayBpZiBtdWx0aXBsZSBleHBhbmRlZCByb3dzIGFyZSBhbGxvd2VkLi4uXG5cdFx0XHRcdGlmICh0aGlzLl9ndE9wdGlvbnMucm93RXhwYW5kQWxsb3dNdWx0aXBsZSA9PT0gZmFsc2UpIHtcblx0XHRcdFx0XHQvLyAuLi5pZiBub3QsIGV4aXQgZnVuY3Rpb25cblx0XHRcdFx0XHRjb25zb2xlLmxvZyhcblx0XHRcdFx0XHRcdCdmZWF0dXJlIGRpc2FibGVkOiBlbmFibGUgYnkgc2V0dGluZyBcInJvd0V4cGFuZEFsbG93TXVsdGlwbGUgPSB0cnVlXCInXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGFjdGl2ZSkge1xuXHRcdFx0XHRcdGV2ZW50TmFtZSA9ICdleHBhbmQtYWxsJztcblx0XHRcdFx0XHR0aGlzLm9wZW5Sb3dzID0gdGhpcy5fZ3RPcHRpb25zLmxhenlMb2FkXG5cdFx0XHRcdFx0XHQ/IHRoaXMuX3B1c2hMYXp5Um93cyhcblx0XHRcdFx0XHRcdFx0XHR0aGlzLm9wZW5Sb3dzLFxuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX2d0RGF0YVt0aGlzLmd0SW5mby5wYWdlQ3VycmVudCAtIDFdLnNsaWNlKClcblx0XHRcdFx0XHRcdCAgKVxuXHRcdFx0XHRcdFx0OiB0aGlzLl9ndERhdGEuc2xpY2UoKTtcblx0XHRcdFx0XHR0aGlzLl91cGRhdGVNZXRhSW5mbyh0aGlzLm9wZW5Sb3dzLCBwcm9wZXJ0eSwgYWN0aXZlKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRldmVudE5hbWUgPSAnY29sbGFwc2UtYWxsJztcblx0XHRcdFx0XHR0aGlzLl91cGRhdGVNZXRhSW5mbyh0aGlzLm9wZW5Sb3dzLCBwcm9wZXJ0eSwgYWN0aXZlKTtcblx0XHRcdFx0XHR0aGlzLm9wZW5Sb3dzID0gW107XG5cdFx0XHRcdH1cblx0XHRcdFx0ZXZlbnRWYWx1ZSA9IHtcblx0XHRcdFx0XHRleHBhbmRlZFJvd3M6IHRoaXMub3BlblJvd3MsXG5cdFx0XHRcdFx0Y2hhbmdlZFJvdzogJ2FsbCdcblx0XHRcdFx0fTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdpc1NlbGVjdGVkJzpcblx0XHRcdFx0Ly8gY2hlY2sgaWYgbXVsdGkgcm93IHNlbGVjdGlvbiBpcyBhbGxvd2VkLi4uXG5cdFx0XHRcdGlmICh0aGlzLl9ndE9wdGlvbnMucm93U2VsZWN0aW9uQWxsb3dNdWx0aXBsZSA9PT0gZmFsc2UpIHtcblx0XHRcdFx0XHQvLyAuLi5pZiBub3QsIGV4aXQgZnVuY3Rpb25cblx0XHRcdFx0XHRjb25zb2xlLmxvZyhcblx0XHRcdFx0XHRcdCdmZWF0dXJlIGRpc2FibGVkOiBlbmFibGUgYnkgc2V0dGluZyBcInJvd1NlbGVjdGlvbkFsbG93TXVsdGlwbGUgPSB0cnVlXCInXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGFjdGl2ZSkge1xuXHRcdFx0XHRcdGV2ZW50TmFtZSA9ICdzZWxlY3QtYWxsJztcblx0XHRcdFx0XHR0aGlzLnNlbGVjdGVkUm93cyA9IHRoaXMuX2d0T3B0aW9ucy5sYXp5TG9hZFxuXHRcdFx0XHRcdFx0PyB0aGlzLl9wdXNoTGF6eVJvd3MoXG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5zZWxlY3RlZFJvd3MsXG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fZ3REYXRhW3RoaXMuZ3RJbmZvLnBhZ2VDdXJyZW50IC0gMV0uc2xpY2UoKVxuXHRcdFx0XHRcdFx0ICApXG5cdFx0XHRcdFx0XHQ6IHRoaXMuX2d0RGF0YS5zbGljZSgpO1xuXHRcdFx0XHRcdHRoaXMuX3VwZGF0ZU1ldGFJbmZvKHRoaXMuc2VsZWN0ZWRSb3dzLCBwcm9wZXJ0eSwgYWN0aXZlKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRldmVudE5hbWUgPSAnZGVzZWxlY3QtYWxsJztcblx0XHRcdFx0XHR0aGlzLl91cGRhdGVNZXRhSW5mbyh0aGlzLnNlbGVjdGVkUm93cywgcHJvcGVydHksIGFjdGl2ZSk7XG5cdFx0XHRcdFx0dGhpcy5zZWxlY3RlZFJvd3MgPSBbXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRldmVudFZhbHVlID0ge1xuXHRcdFx0XHRcdHNlbGVjdGVkUm93czogdGhpcy5zZWxlY3RlZFJvd3MsXG5cdFx0XHRcdFx0Y2hhbmdlZFJvdzogJ2FsbCdcblx0XHRcdFx0fTtcblxuXHRcdFx0XHRicmVhaztcblx0XHR9XG5cdFx0dGhpcy5ndEV2ZW50LmVtaXQoe1xuXHRcdFx0bmFtZTogJ2d0LXJvdy0nICsgZXZlbnROYW1lLFxuXHRcdFx0dmFsdWU6IGV2ZW50VmFsdWVcblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBUb2dnbGUgbWV0YSBpbmZvIGZvciByb3csIGllLiBpc1NlbGVjdGVkLCBpc09wZW4uXG5cdCAqIEBwYXJhbSByb3cgLSByb3cgb2JqZWN0LlxuXHQgKiBAcGFyYW0gcHJvcGVydHkgLSBuYW1lIG9mIHByb3BlcnR5IHRoYXQgc2hvdWxkIGJlIGNoYW5nZWQvdG9nZ2xlZC5cblx0ICogQHBhcmFtIHByb3BlcnR5VmFsdWVzIC0gb3B0aW9uYWwgcHJvcGVydHkgdmFsdWVzIHRoYXQgY2FuIGJlIHBhc3NlZC5cblx0ICovXG5cdHByaXZhdGUgX3RvZ2dsZVJvd1Byb3BlcnR5KFxuXHRcdHJvdzogR3RSb3csXG5cdFx0cHJvcGVydHk6IHN0cmluZyxcblx0XHRwcm9wZXJ0eVZhbHVlcz86IGFueVxuXHQpIHtcblx0XHRsZXQgZXZlbnROYW1lOiBzdHJpbmc7XG5cdFx0bGV0IGV2ZW50VmFsdWU6IGFueTtcblx0XHQvLyBtYWtlIHN1cmUgZ3RSb3dJZCBleGlzdHMgb24gcm93IG9iamVjdFxuXHRcdGlmICh0eXBlb2Ygcm93LiQkZ3RSb3dJZCAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdC8vIGNoZWNrIGlmIG1ldGEgaW5mbyBleGlzdHMgZm9yIHJvd1xuXHRcdFx0aWYgKCF0aGlzLm1ldGFJbmZvW3Jvdy4kJGd0Um93SWRdKSB7XG5cdFx0XHRcdC8vIGlmIG5vdCwgYWRkIG9iamVjdCB0byBzdG9yZSBtZXRhIGluZm9cblx0XHRcdFx0dGhpcy5tZXRhSW5mb1tyb3cuJCRndFJvd0lkXSA9IHt9O1xuXHRcdFx0fVxuXG5cdFx0XHRzd2l0Y2ggKHByb3BlcnR5KSB7XG5cdFx0XHRcdGNhc2UgJ2lzT3Blbic6XG5cdFx0XHRcdFx0Y29uc3Qgb3BlbmVkID0gdGhpcy5tZXRhSW5mb1tyb3cuJCRndFJvd0lkXVtwcm9wZXJ0eV07XG5cblx0XHRcdFx0XHQvLyBjaGVjayBpZiBtdWx0aXBsZSBleHBhbmRlZCByb3dzIGFyZSBhbGxvd2VkLi4uXG5cdFx0XHRcdFx0aWYgKHRoaXMuX2d0T3B0aW9ucy5yb3dFeHBhbmRBbGxvd011bHRpcGxlID09PSBmYWxzZSkge1xuXHRcdFx0XHRcdFx0Ly8gLi4uaWYgbm90LCBjb2xsYXBzZSBhbGwgcm93cyBleGNlcHQgY3VycmVudCByb3dcblx0XHRcdFx0XHRcdHRoaXMuX3VwZGF0ZU1ldGFJbmZvKHRoaXMub3BlblJvd3MsIHByb3BlcnR5LCBmYWxzZSwgcm93KTtcblx0XHRcdFx0XHRcdHRoaXMub3BlblJvd3MgPSBbXTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBjaGVjayBpZiByb3cgaXMgZXhwYW5kZWRcblx0XHRcdFx0XHRpZiAoIW9wZW5lZCkge1xuXHRcdFx0XHRcdFx0ZXZlbnROYW1lID0gJ2V4cGFuZCc7XG5cdFx0XHRcdFx0XHQvLyBhZGQgcm93IHRvIGV4cGFuZGVkIHJvd3Ncblx0XHRcdFx0XHRcdHRoaXMub3BlblJvd3MucHVzaChyb3cpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRldmVudE5hbWUgPSAnY29sbGFwc2UnO1xuXHRcdFx0XHRcdFx0Ly8gbG9vcCB0aHJvdWdoIGV4cGFuZGVkIHJvd3MuLi5cblx0XHRcdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5vcGVuUm93cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0XHQvLyBpZiBleHBhbmRlZCByb3cgZXF1YWxzIHBhc3NlZCByb3cuLi5cblx0XHRcdFx0XHRcdFx0aWYgKHRoaXMub3BlblJvd3NbaV0uJCRndFJvd0lkID09PSByb3cuJCRndFJvd0lkKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gLi4ucmVtb3ZlIHJvdyBmcm9tIGV4cGFuZGVkIHJvd3MuLi5cblx0XHRcdFx0XHRcdFx0XHR0aGlzLm9wZW5Sb3dzLnNwbGljZShpLCAxKTtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIC4uLmFuZCBleGl0IGxvb3Bcblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRldmVudFZhbHVlID0ge1xuXHRcdFx0XHRcdFx0ZXhwYW5kZWRSb3dzOiB0aGlzLm9wZW5Sb3dzLFxuXHRcdFx0XHRcdFx0Y2hhbmdlZFJvdzogcm93XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAnaXNTZWxlY3RlZCc6XG5cdFx0XHRcdFx0Y29uc3Qgc2VsZWN0ZWQgPSB0aGlzLm1ldGFJbmZvW3Jvdy4kJGd0Um93SWRdW3Byb3BlcnR5XTtcblxuXHRcdFx0XHRcdC8vIGNoZWNrIGlmIG11bHRpIHJvdyBzZWxlY3Rpb24gaXMgYWxsb3dlZC4uLlxuXHRcdFx0XHRcdGlmICh0aGlzLl9ndE9wdGlvbnMucm93U2VsZWN0aW9uQWxsb3dNdWx0aXBsZSA9PT0gZmFsc2UpIHtcblx0XHRcdFx0XHRcdC8vIC4uLmlmIG5vdCwgZGVzZWxlY3QgYWxsIHJvd3MgZXhjZXB0IGN1cnJlbnQgcm93XG5cdFx0XHRcdFx0XHR0aGlzLl91cGRhdGVNZXRhSW5mbyh0aGlzLnNlbGVjdGVkUm93cywgcHJvcGVydHksIGZhbHNlLCByb3cpO1xuXHRcdFx0XHRcdFx0dGhpcy5zZWxlY3RlZFJvd3MgPSBbXTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBjaGVjayBpZiByb3cgaXMgc2VsZWN0ZWRcblx0XHRcdFx0XHRpZiAoIXNlbGVjdGVkKSB7XG5cdFx0XHRcdFx0XHRldmVudE5hbWUgPSAnc2VsZWN0Jztcblx0XHRcdFx0XHRcdC8vIGFkZCByb3cgdG8gc2VsZWN0ZWQgcm93c1xuXHRcdFx0XHRcdFx0dGhpcy5zZWxlY3RlZFJvd3MucHVzaChyb3cpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRpZiAodGhpcy5ndE9wdGlvbnMubGF6eUxvYWQgJiYgdGhpcy5sYXp5QWxsU2VsZWN0ZWQpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5sYXp5QWxsU2VsZWN0ZWQgPSBmYWxzZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGV2ZW50TmFtZSA9ICdkZXNlbGVjdCc7XG5cdFx0XHRcdFx0XHQvLyBsb29wIHRocm91Z2ggc2VsZWN0ZWQgcm93cy4uLlxuXHRcdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNlbGVjdGVkUm93cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0XHQvLyBpZiBzZWxlY3RlZCByb3cgZXF1YWxzIHBhc3NlZCByb3cuLi5cblx0XHRcdFx0XHRcdFx0aWYgKHRoaXMuc2VsZWN0ZWRSb3dzW2ldLiQkZ3RSb3dJZCA9PT0gcm93LiQkZ3RSb3dJZCkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIC4uLnJlbW92ZSByb3cgZnJvbSBzZWxlY3RlZCByb3dzLi4uXG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5zZWxlY3RlZFJvd3Muc3BsaWNlKGksIDEpO1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gLi4uYW5kIGV4aXQgbG9vcFxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGV2ZW50VmFsdWUgPSB7XG5cdFx0XHRcdFx0XHRzZWxlY3RlZFJvd3M6IHRoaXMuc2VsZWN0ZWRSb3dzLFxuXHRcdFx0XHRcdFx0Y2hhbmdlZFJvdzogcm93XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRjYXNlICdpc1VwZGF0ZWQnOlxuXHRcdFx0XHRcdGV2ZW50TmFtZSA9ICd1cGRhdGVkJztcblx0XHRcdFx0XHRjb25zdCBvbGRWYWx1ZSA9IHByb3BlcnR5VmFsdWVzO1xuXHRcdFx0XHRcdC8vIGNoZWNrIGlmIGVkaXQgb2JqZWN0IGV4aXN0cyBmb3Igcm93XG5cdFx0XHRcdFx0aWYgKHR5cGVvZiB0aGlzLm1ldGFJbmZvW3Jvdy4kJGd0Um93SWRdW3Byb3BlcnR5XSA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdFx0XHRcdHRoaXMubWV0YUluZm9bcm93LiQkZ3RSb3dJZF1bcHJvcGVydHldID0ge1xuXHRcdFx0XHRcdFx0XHRvcmlnaW5hbFZhbHVlOiBvbGRWYWx1ZSxcblx0XHRcdFx0XHRcdFx0b2xkVmFsdWU6IG9sZFZhbHVlLFxuXHRcdFx0XHRcdFx0XHRuZXdWYWx1ZTogcm93XG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0aGlzLm1ldGFJbmZvW3Jvdy4kJGd0Um93SWRdW3Byb3BlcnR5XS5vbGRWYWx1ZSA9IG9sZFZhbHVlO1xuXHRcdFx0XHRcdFx0dGhpcy5tZXRhSW5mb1tyb3cuJCRndFJvd0lkXVtwcm9wZXJ0eV0ubmV3VmFsdWUgPSByb3c7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGV2ZW50VmFsdWUgPSB0aGlzLm1ldGFJbmZvW3Jvdy4kJGd0Um93SWRdW3Byb3BlcnR5XTtcblx0XHRcdFx0XHR0aGlzLnJlZHJhdygpO1xuXHRcdFx0XHRcdHRoaXMuaW5saW5lRWRpdENhbmNlbChyb3cpO1xuXHRcdFx0XHRcdC8vIHRoaXMuZ3REYXRhID0gWy4uLnRoaXMuZ3REYXRhLm1hcCgocikgPT4geyByZXR1cm57Li4ucn07IH0pXTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdHRoaXMuZ3RFdmVudC5lbWl0KHtcblx0XHRcdFx0bmFtZTogJ2d0LXJvdy0nICsgZXZlbnROYW1lLFxuXHRcdFx0XHR2YWx1ZTogZXZlbnRWYWx1ZVxuXHRcdFx0fSk7XG5cdFx0XHRpZiAocHJvcGVydHkgIT09ICdpc1VwZGF0ZWQnKSB7XG5cdFx0XHRcdHRoaXMubWV0YUluZm9bcm93LiQkZ3RSb3dJZF1bcHJvcGVydHldID0gIXRoaXMubWV0YUluZm9bcm93LiQkZ3RSb3dJZF1bXG5cdFx0XHRcdFx0cHJvcGVydHlcblx0XHRcdFx0XTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogVXBkYXRlIGNvbHVtbi5cblx0ICogQHBhcmFtICRldmVudCAtIGtleSB1cCBldmVudC5cblx0ICogQHBhcmFtIHJvdyAtIHJvdyBvYmplY3QuXG5cdCAqIEBwYXJhbSBjb2x1bW4gLSBjb2x1bW4gb2JqZWN0LlxuXHQgKi9cblx0cHVibGljIGd0VXBkYXRlQ29sdW1uKFxuXHRcdCRldmVudDogS2V5Ym9hcmRFdmVudCxcblx0XHRyb3c6IEd0Um93LFxuXHRcdGNvbHVtbjogR3RSZW5kZXJGaWVsZDxhbnksIGFueT5cblx0KSB7XG5cdFx0dGhpcy5fZWRpdFJvdyhyb3csIGNvbHVtbik7XG5cdH1cblxuXHQvKipcblx0ICogRHJvcGRvd24gc2VsZWN0LlxuXHQgKiBAcGFyYW0gcm93IC0gcm93IG9iamVjdC5cblx0ICogQHBhcmFtIGNvbHVtbiAtIGNvbHVtbiBvYmplY3QuXG5cdCAqL1xuXHRwdWJsaWMgZ3REcm9wZG93blNlbGVjdChyb3c6IEd0Um93LCBjb2x1bW46IEd0UmVuZGVyRmllbGQ8YW55LCBhbnk+KSB7XG5cdFx0Y29uc3Qgb2xkVmFsdWUgPSB7IC4uLnJvdyB9O1xuXHRcdHJvd1tjb2x1bW4ub2JqZWN0S2V5XSA9IGNvbHVtbi5yZW5kZXJWYWx1ZTtcblx0XHR0aGlzLnVwZGF0ZVJvdyhyb3csIG9sZFZhbHVlKTtcblx0fVxuXG5cdHByaXZhdGUgX2VkaXRSb3cocm93OiBHdFJvdywgY29sdW1uOiBHdFJlbmRlckZpZWxkPGFueSwgYW55Pikge1xuXHRcdGNvbnN0IE9CSkVDVF9LRVkgPSBjb2x1bW4ub2JqZWN0S2V5OyAvLyBkZWNsYXJlIG9iamVjdCBrZXkgd2hpY2ggY29udGFpbnMgY2hhbmdlc1xuXG5cdFx0Ly8gY2hlY2sgaWYgY2VsbCBoYXMgY2hhbmdlZCB2YWx1ZVxuXHRcdGNvbHVtbi5lZGl0ZWQgPSByb3dbY29sdW1uLm9iamVjdEtleV0gIT09IGNvbHVtbi5yZW5kZXJWYWx1ZTtcblx0XHQvLyBjaGVjayBpZiByb3cgY29udGFpbnMgY2hhbmdlcy4uLlxuXHRcdGlmICghdGhpcy5lZGl0ZWRSb3dzW3Jvdy4kJGd0Um93SWRdKSB7XG5cdFx0XHQvLyBpZiBub3QsIGNyZWF0ZSBhbiBvYmplY3QgZm9yIHRoZSBjaGFuZ2VkIHJvd1xuXHRcdFx0dGhpcy5lZGl0ZWRSb3dzW3Jvdy4kJGd0Um93SWRdID0ge1xuXHRcdFx0XHRjaGFuZ2VzOiB7fSwgLy8gY3JlYXRlIHBsYWNlaG9sZGVyIGZvciBjaGFuZ2VzXG5cdFx0XHRcdHJvdzogcm93IC8vIHN0b3JlIHJlZmVyZW5jZSB0byB0aGUgcm93IHRoYXQgc2hvdWxkIGJlIHVwZGF0ZWRcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0Ly8gc3RvcmUgY2hhbmdlZCBjb2x1bW4gdW5kZXIgY2hhbmdlcyBpZiBpdCBoYXMgYmVlbiBlZGl0ZWRcblx0XHRpZiAoY29sdW1uLmVkaXRlZCkge1xuXHRcdFx0dGhpcy5lZGl0ZWRSb3dzW3Jvdy4kJGd0Um93SWRdLmNoYW5nZXNbT0JKRUNUX0tFWV0gPSBjb2x1bW47XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIGRlbGV0ZSBjaGFuZ2Ugb2JqZWN0IGlmIGNvbHVtbiBpcyB1bmNoYW5nZWRcblx0XHRcdGRlbGV0ZSB0aGlzLmVkaXRlZFJvd3Nbcm93LiQkZ3RSb3dJZF0uY2hhbmdlc1tPQkpFQ1RfS0VZXTtcblx0XHRcdC8vIGNoZWNrIGhvdyBtYW55IGNvbHVtbnMgaGF2ZSBiZWVuIGNoYW5nZWRcblx0XHRcdGNvbnN0IENIQU5HRURfQ09MVU1OUyA9IE9iamVjdC5rZXlzKFxuXHRcdFx0XHR0aGlzLmVkaXRlZFJvd3Nbcm93LiQkZ3RSb3dJZF0uY2hhbmdlc1xuXHRcdFx0KS5sZW5ndGg7XG5cdFx0XHRpZiAoQ0hBTkdFRF9DT0xVTU5TID09PSAwKSB7XG5cdFx0XHRcdC8vIGRlbGV0ZSByb3cgZnJvbSBlZGl0ZWQgcm93cyBpZiBubyBjb2x1bW5zIGhhdmUgYmVlbiBlZGl0ZWRcblx0XHRcdFx0ZGVsZXRlIHRoaXMuZWRpdGVkUm93c1tyb3cuJCRndFJvd0lkXTtcblx0XHRcdH1cblx0XHR9XG5cdFx0Ly8gaWYgbm8gbGlzdGVuZXIgaXMgcHJlc2VudC4uLlxuXHRcdGlmICghdGhpcy5nbG9iYWxJbmxpbmVFZGl0TGlzdGVuZXIpIHtcblx0XHRcdC8vIC4uLmxpc3RlbiBmb3IgdXBkYXRlIGV2ZW50XG5cdFx0XHR0aGlzLl9saXN0ZW5Gb3JLZXlkb3duRXZlbnQoKTtcblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogTGlzdGVuIGZvciBrZXkgZG93biBldmVudCAtIGxpc3RlbiBmb3Iga2V5IGRvd24gZXZlbnQgZHVyaW5nIGlubGluZSBlZGl0LlxuXHQgKi9cblx0cHJpdmF0ZSBfbGlzdGVuRm9yS2V5ZG93bkV2ZW50KCkge1xuXHRcdC8vIGFkZCBnbG9iYWwgbGlzdGVuZXIgZm9yIGtleSBkb3duIGV2ZW50c1xuXHRcdHRoaXMuZ2xvYmFsSW5saW5lRWRpdExpc3RlbmVyID0gdGhpcy5yZW5kZXJlci5saXN0ZW4oXG5cdFx0XHQnZG9jdW1lbnQnLFxuXHRcdFx0J2tleWRvd24nLFxuXHRcdFx0JGV2ZW50ID0+IHtcblx0XHRcdFx0c3dpdGNoICgkZXZlbnQua2V5KSB7XG5cdFx0XHRcdFx0Y2FzZSAnRW50ZXInOiAvLyB1cGRhdGUgZGF0YSBvYmplY3Rcblx0XHRcdFx0XHRcdHRoaXMuaW5saW5lRWRpdFVwZGF0ZSgpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0Y2FzZSAnRXNjYXBlJzogLy8gY2FuY2VsXG5cdFx0XHRcdFx0XHR0aGlzLmlubGluZUVkaXRDYW5jZWwoKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBJbmxpbmUgZWRpdCB1cGRhdGUgLSBhY2NlcHQgY2hhbmdlcyBhbmQgdXBkYXRlIHJvdyB2YWx1ZXMuXG5cdCAqL1xuXHRwdWJsaWMgaW5saW5lRWRpdFVwZGF0ZSgpIHtcblx0XHQvLyBsb29wIHRocm91Z2ggcm93cyB0aGF0IGhhdmUgYmVlbiBlZGl0ZWRcblx0XHRPYmplY3Qua2V5cyh0aGlzLmVkaXRlZFJvd3MpLm1hcChrZXkgPT4ge1xuXHRcdFx0Y29uc3QgUk9XID0gdGhpcy5lZGl0ZWRSb3dzW2tleV0ucm93OyAvLyByb3cgdG8gdXBkYXRlXG5cdFx0XHRjb25zdCBDSEFOR0VTID0gdGhpcy5lZGl0ZWRSb3dzW2tleV0uY2hhbmdlczsgLy8gY2hhbmdlcyB0byB0aGUgcm93XG5cblx0XHRcdC8vIGxvb3AgdGhyb3VnaCBjaGFuZ2VzIGluIHJvd1xuXHRcdFx0T2JqZWN0LmtleXMoQ0hBTkdFUykubWFwKG9iamVjdEtleSA9PiB7XG5cdFx0XHRcdGNvbnN0IG9sZFZhbHVlID0geyAuLi5ST1cgfTtcblx0XHRcdFx0Uk9XW29iamVjdEtleV0gPSBDSEFOR0VTW29iamVjdEtleV0ucmVuZGVyVmFsdWU7IC8vIHVwZGF0ZSBkYXRhIHZhbHVlXG5cdFx0XHRcdHRoaXMudXBkYXRlUm93KFJPVywgb2xkVmFsdWUpOyAvLyB1cGRhdGUgbWV0YSBpbmZvIGZvciByb3cgYW5kIHNlbmQgZXZlbnRcblx0XHRcdFx0Q0hBTkdFU1tvYmplY3RLZXldLmVkaXRlZCA9IGZhbHNlOyAvLyBkaXNhYmxlIGVkaXQgbW9kZVxuXHRcdFx0fSk7XG5cdFx0fSk7XG5cdFx0Ly8gY2xlYXIgcm93cyBtYXJrZWQgYXMgZWRpdGVkIGFzIHRoZSByb3dzIGhhdmUgYmVlbiB1cGRhdGVkXG5cdFx0dGhpcy5lZGl0ZWRSb3dzID0ge307XG5cdFx0Ly8gcmVtb3ZlIGxpc3RlbmVyXG5cdFx0dGhpcy5fc3RvcExpc3RlbmluZ0ZvcktleWRvd25FdmVudCgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIElubGluZSBlZGl0IGNhbmNlbCAtIGNhbmNlbCBhbmQgcmVzZXQgaW5saW5lIGVkaXRzLlxuXHQgKi9cblx0cHVibGljIGlubGluZUVkaXRDYW5jZWwocm93PzogR3RSb3cpIHtcblx0XHRpZiAocm93KSB7XG5cdFx0XHRkZWxldGUgdGhpcy5lZGl0ZWRSb3dzW3Jvdy4kJGd0Um93SWRdO1xuXHRcdFx0Ly8gcmVtb3ZlIGxpc3RlbmVyXG5cdFx0XHR0aGlzLl9zdG9wTGlzdGVuaW5nRm9yS2V5ZG93bkV2ZW50KCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gbG9vcCB0aHJvdWdoIHJvd3MgdGhhdCBoYXZlIGJlZW4gZWRpdGVkXG5cdFx0T2JqZWN0LmtleXModGhpcy5lZGl0ZWRSb3dzKS5tYXAoa2V5ID0+IHtcblx0XHRcdGNvbnN0IFJPVyA9IHRoaXMuZWRpdGVkUm93c1trZXldLnJvdzsgLy8gcm93IHRvIHVwZGF0ZVxuXHRcdFx0Y29uc3QgQ0hBTkdFUyA9IHRoaXMuZWRpdGVkUm93c1trZXldLmNoYW5nZXM7IC8vIGNoYW5nZXMgdG8gdGhlIHJvd1xuXG5cdFx0XHQvLyBsb29wIHRocm91Z2ggY2hhbmdlcyBpbiByb3dcblx0XHRcdE9iamVjdC5rZXlzKENIQU5HRVMpLm1hcChvYmplY3RLZXkgPT4ge1xuXHRcdFx0XHRDSEFOR0VTW29iamVjdEtleV0ucmVuZGVyVmFsdWUgPSBST1dbb2JqZWN0S2V5XTsgLy8gcmVzZXQgcmVuZGVyZWQgdmFsdWVcblx0XHRcdFx0Q0hBTkdFU1tvYmplY3RLZXldLmVkaXRlZCA9IGZhbHNlOyAvLyBkaXNhYmxlIGVkaXQgbW9kZVxuXHRcdFx0fSk7XG5cdFx0fSk7XG5cdFx0Ly8gY2xlYXIgcm93cyBtYXJrZWQgYXMgZWRpdGVkIGFzIHRoZSByb3dzIGhhdmUgYmVlbiB1cGRhdGVkXG5cdFx0dGhpcy5lZGl0ZWRSb3dzID0ge307XG5cdFx0Ly8gcmVtb3ZlIGxpc3RlbmVyXG5cdFx0dGhpcy5fc3RvcExpc3RlbmluZ0ZvcktleWRvd25FdmVudCgpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFN0b3AgbGlzdGVuaW5nIGZvciBrZXkgZG93biBldmVudCAtIHN0b3AgbGlzdGVuaW5nIGZvciBrZXkgZG93biBldmVudHMgcGFzc2VkIGR1cmluZyBpbmxpbmUgZWRpdC5cblx0ICovXG5cdHByaXZhdGUgX3N0b3BMaXN0ZW5pbmdGb3JLZXlkb3duRXZlbnQoKSB7XG5cdFx0aWYgKHRoaXMuZ2xvYmFsSW5saW5lRWRpdExpc3RlbmVyKSB7XG5cdFx0XHR0aGlzLmdsb2JhbElubGluZUVkaXRMaXN0ZW5lcigpO1xuXHRcdFx0dGhpcy5nbG9iYWxJbmxpbmVFZGl0TGlzdGVuZXIgPSBudWxsO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBBcHBseSBmaWx0ZXIocykuXG5cdCAqIEBwYXJhbSBmaWx0ZXIgLSBvYmplY3QgY29udGFpbmluZyBrZXkgdmFsdWUgcGFpcnMsIHdoZXJlIHZhbHVlIHNob3VsZCBiZSBhcnJheSBvZiB2YWx1ZXMuXG5cdCAqL1xuXHRwdWJsaWMgZ3RBcHBseUZpbHRlcihmaWx0ZXI6IE9iamVjdCkge1xuXHRcdHRoaXMuZ3RJbmZvLmZpbHRlciA9IGZpbHRlcjtcblx0XHQvLyBnbyB0byBmaXJzdCBwYWdlXG5cdFx0dGhpcy5nb1RvUGFnZSgxKTtcblx0XHR0aGlzLnVwZGF0ZVRvdGFscygpO1xuXHR9XG5cblx0LyoqIENsZWFyL3JlbW92ZSBhcHBsaWVkIGZpbHRlcihzKS4gKi9cblx0cHVibGljIGd0Q2xlYXJGaWx0ZXIoKSB7XG5cdFx0dGhpcy5ndEluZm8uZmlsdGVyID0gZmFsc2U7XG5cdFx0dGhpcy51cGRhdGVUb3RhbHMoKTtcblx0XHQvLyB0aGlzLnVwZGF0ZVJlY29yZFJhbmdlKCk7XG5cdH1cblxuXHQvKipcblx0ICogU2VhcmNoXG5cdCAqIEBwYXJhbSB2YWx1ZSAtIHN0cmluZyBjb250YWluaW5nIG9uZSBvciBtb3JlIHdvcmRzXG5cdCAqL1xuXHRwdWJsaWMgZ3RTZWFyY2godmFsdWU6IHN0cmluZykge1xuXHRcdHRoaXMuZ3RJbmZvLnNlYXJjaFRlcm1zID0gdmFsdWU7XG5cdFx0Ly8gYWx3YXlzIGdvIHRvIGZpcnN0IHBhZ2Ugd2hlbiBzZWFyY2hpbmdcblx0XHR0aGlzLmdvVG9QYWdlKDEpO1xuXHRcdHRoaXMudXBkYXRlVG90YWxzKCk7XG5cdH1cblxuXHQvKipcblx0ICogQWRkIHJvd3Ncblx0ICogQHBhcmFtIHJvd3MgLSByb3dzIHRvIGFkZFxuXHQgKiBAcmV0dXJucyBuZXcgZGF0YSBhcnJheS5cblx0ICovXG5cdHB1YmxpYyBndEFkZChyb3dzOiBBcnJheTxSPik6IFJlYWRvbmx5QXJyYXk8Uj4ge1xuXHRcdHRoaXMuZ3REYXRhID0gWy4uLnRoaXMuZ3REYXRhLCAuLi5yb3dzXTtcblx0XHRyZXR1cm4gWy4uLnRoaXMuZ3REYXRhXTtcblx0fVxuXG5cdC8qKlxuXHQgKiBEZWxldGUgcm93XG5cdCAqIEBwYXJhbSBvYmplY3RLZXkgLSBvYmplY3Qga2V5IHlvdSB3YW50IHRvIGZpbmQgbWF0Y2ggd2l0aFxuXHQgKiBAcGFyYW0gdmFsdWUgLSB0aGUgdmFsdWUgdGhhdCBzaG91bGQgYmUgZGVsZXRlZFxuXHQgKiBAcGFyYW0gbWF0Y2ggLSBhbGw6IGRlbGV0ZSBhbGwgbWF0Y2hlcywgZmlyc3Q6IGRlbGV0ZSBmaXJzdCBtYXRjaCAoZGVmYXVsdClcblx0ICogQHJldHVybnMgbmV3IGRhdGEgYXJyYXkuXG5cdCAqL1xuXHRwdWJsaWMgZ3REZWxldGUoXG5cdFx0b2JqZWN0S2V5OiBzdHJpbmcsXG5cdFx0dmFsdWU6IHN0cmluZyB8IG51bWJlcixcblx0XHRtYXRjaDogJ2ZpcnN0JyB8ICdhbGwnID0gJ2ZpcnN0J1xuXHQpOiBSZWFkb25seUFycmF5PFI+IHtcblx0XHRpZiAobWF0Y2ggPT09ICdmaXJzdCcpIHtcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5ndERhdGEubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKHRoaXMuZ3REYXRhW2ldW29iamVjdEtleV0gPT09IHZhbHVlKSB7XG5cdFx0XHRcdFx0aWYgKHRoaXMuaXNSb3dTZWxlY3RlZCh0aGlzLmd0RGF0YVtpXSkpIHtcblx0XHRcdFx0XHRcdHRoaXMudG9nZ2xlU2VsZWN0KHRoaXMuZ3REYXRhW2ldKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5ndERhdGEuc3BsaWNlKGksIDEpO1xuXHRcdFx0XHRcdHRoaXMuZ3REYXRhID0gWy4uLnRoaXMuZ3REYXRhXTtcblx0XHRcdFx0XHRpZiAobWF0Y2ggPT09ICdmaXJzdCcpIHtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKGxldCBpID0gdGhpcy5ndERhdGEubGVuZ3RoOyBpID4gMDsgaS0tKSB7XG5cdFx0XHRcdGlmICh0aGlzLmd0RGF0YVtpIC0gMV1bb2JqZWN0S2V5XSA9PT0gdmFsdWUpIHtcblx0XHRcdFx0XHRpZiAodGhpcy5pc1Jvd1NlbGVjdGVkKHRoaXMuZ3REYXRhW2kgLSAxXSkpIHtcblx0XHRcdFx0XHRcdHRoaXMudG9nZ2xlU2VsZWN0KHRoaXMuZ3REYXRhW2kgLSAxXSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRoaXMuZ3REYXRhLnNwbGljZShpIC0gMSwgMSk7XG5cdFx0XHRcdFx0dGhpcy5ndERhdGEgPSBbLi4udGhpcy5ndERhdGFdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBbLi4udGhpcy5ndERhdGFdO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZSBzdG9yZSB0byBob2xkIHByZXZpb3VzbHkgbG9hZGVkIHJlY29yZHMuXG5cdCAqIEBwYXJhbSByZWNvcmRzIC0gdG90YWwgbnVtYmVyIG9mIHJlY29yZHMgaW4gc3RvcmUuXG5cdCAqIEBwYXJhbSBwZXJQYWdlIC0gaG93IG1hbnkgcmVjb3JkcyB0byBzaG93IHBlciBwYWdlLlxuXHQgKiBAcmV0dXJucyBhIG5lc3RlZCBhcnJheSB0byBob2xkIHJlY29yZHMgcGVyIHBhZ2UuXG5cdCAqL1xuXHRwcml2YXRlIGNyZWF0ZVN0b3JlKHJlY29yZHM6IG51bWJlciwgcGVyUGFnZTogbnVtYmVyKTogQXJyYXk8QXJyYXk8YW55Pj4ge1xuXHRcdGNvbnN0IHN0b3JlcyA9IE1hdGguY2VpbChyZWNvcmRzIC8gcGVyUGFnZSk7XG5cdFx0Y29uc3Qgc3RvcmU6IEFycmF5PEFycmF5PGFueT4+ID0gW107XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBzdG9yZXM7IGkrKykge1xuXHRcdFx0c3RvcmVbaV0gPSBbXTtcblx0XHR9XG5cdFx0cmV0dXJuIHN0b3JlO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZSBwbGFjZWhvbGRlcnMgZm9yIHJvd3Mgd2hpbGUgbG9hZGluZyBkYXRhIGZyb20gYmFjay1lbmQuXG5cdCAqIEBwYXJhbSBwZXJQYWdlIC0gaG93IG1hbnkgcmVjb3JkcyB0byBzaG93IHBlciBwYWdlLlxuXHQgKiBAcmV0dXJucyBhbiBhcnJheSBjb250YWluaW5nIGVtcHR5IHJlY29yZHMgdG8gYmUgcHJlc2VudGVkIHdoaWxlIGZldGNoaW5nIHJlYWwgZGF0YS5cblx0ICovXG5cdHByaXZhdGUgbG9hZGluZ0NvbnRlbnQocGVyUGFnZTogbnVtYmVyKSB7XG5cdFx0Ly8gY3JlYXRlIHJvdyBvYmplY3Rcblx0XHRjb25zdCByb3dPYmplY3Q6IE9iamVjdCA9IHtcblx0XHRcdCQkbG9hZGluZzogdHJ1ZVxuXHRcdH07XG5cdFx0bGV0IG9yZGVyID0gMDtcblxuXHRcdC8vIHNvcnQgc2V0dGluZ3MgYnkgY29sdW1uIG9yZGVyXG5cdFx0dGhpcy5fZ3RTZXR0aW5ncy5zb3J0KHRoaXMuZ2V0Q29sdW1uT3JkZXIpO1xuXG5cdFx0Ly8gbG9vcCB0aHJvdWdoIGFsbCBzZXR0aW5ncyBvYmplY3RzLi4uXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9ndFNldHRpbmdzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRjb25zdCBzZXR0aW5nID0gdGhpcy5fZ3RTZXR0aW5nc1tpXTtcblxuXHRcdFx0Ly8gLi4uaWYgY29sdW1uIGlzIHZpc2libGUgYW5kIGVuYWJsZWQuLi5cblx0XHRcdGlmIChzZXR0aW5nLnZpc2libGUgIT09IGZhbHNlICYmIHNldHRpbmcuZW5hYmxlZCAhPT0gZmFsc2UpIHtcblx0XHRcdFx0Ly8gLi4uaWYgZmlyc3QgY29sdW1uLCBzZXQgdmFsdWUgdG8gbG9hZGluZyB0ZXh0IG90aGVyd2lzZSBsZWF2ZSBpdCBlbXB0eVxuXHRcdFx0XHRpZiAob3JkZXIgPT09IDApIHtcblx0XHRcdFx0XHRyb3dPYmplY3Rbc2V0dGluZy5vYmplY3RLZXldID0gdGhpcy5ndFRleHRzLmxvYWRpbmc7XG5cdFx0XHRcdFx0dGhpcy5sb2FkaW5nUHJvcGVydHkgPSBzZXR0aW5nLm9iamVjdEtleTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyb3dPYmplY3Rbc2V0dGluZy5vYmplY3RLZXldID0gJyc7XG5cdFx0XHRcdH1cblx0XHRcdFx0b3JkZXIrKztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJvd09iamVjdFtzZXR0aW5nLm9iamVjdEtleV0gPSAnJztcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBjcmVhdGUgY29udGVudCBwbGFjZWhvbGRlclxuXHRcdGNvbnN0IGNvbnRlbnRQbGFjZWhvbGRlcjogQXJyYXk8YW55PiA9IFtdO1xuXG5cdFx0Ly8gY3JlYXRlIGVxdWFsIG51bWJlciBvZiByb3dzIGFzIHJvd3MgcGVyIHBhZ2Vcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHBlclBhZ2U7IGkrKykge1xuXHRcdFx0Ly8gLi4uYWRkIHRlbXBvcmFyeSByb3cgb2JqZWN0XG5cdFx0XHRjb250ZW50UGxhY2Vob2xkZXIucHVzaChyb3dPYmplY3QpO1xuXHRcdH1cblx0XHRyZXR1cm4gY29udGVudFBsYWNlaG9sZGVyO1xuXHR9XG5cblx0Ly8gVE9ETzogbW92ZSB0byBoZWxwZXIgZnVuY3Rpb25zXG5cdC8qKiBTb3J0IGJ5IHNvcnQgb3JkZXIgKi9cblx0cHJpdmF0ZSBnZXRTb3J0T3JkZXIgPSBmdW5jdGlvbihhOiBHdENvbmZpZ1NldHRpbmcsIGI6IEd0Q29uZmlnU2V0dGluZykge1xuXHRcdGlmIChhLnNvcnRPcmRlciA8IGIuc29ydE9yZGVyKSB7XG5cdFx0XHRyZXR1cm4gLTE7XG5cdFx0fVxuXHRcdGlmIChhLnNvcnRPcmRlciA+IGIuc29ydE9yZGVyIHx8IHR5cGVvZiBhLnNvcnRPcmRlciA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdHJldHVybiAxO1xuXHRcdH1cblx0XHRyZXR1cm4gMDtcblx0fTtcblxuXHQvLyBUT0RPOiBtb3ZlIHRvIGhlbHBlciBmdW5jdGlvbnNcblx0LyoqIFNvcnQgYnkgY29sdW1uIG9yZGVyICovXG5cdHByaXZhdGUgZ2V0Q29sdW1uT3JkZXIgPSBmdW5jdGlvbihhOiBHdENvbmZpZ1NldHRpbmcsIGI6IEd0Q29uZmlnU2V0dGluZykge1xuXHRcdGlmIChhLmNvbHVtbk9yZGVyID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHJldHVybiAtMTtcblx0XHR9XG5cdFx0aWYgKGEuY29sdW1uT3JkZXIgPCBiLmNvbHVtbk9yZGVyKSB7XG5cdFx0XHRyZXR1cm4gLTE7XG5cdFx0fVxuXHRcdGlmIChhLmNvbHVtbk9yZGVyID4gYi5jb2x1bW5PcmRlcikge1xuXHRcdFx0cmV0dXJuIDE7XG5cdFx0fVxuXHRcdHJldHVybiAwO1xuXHR9O1xuXG5cdC8vIFRPRE86IG1vdmUgdG8gaGVscGVyIGZ1bmN0aW9uc1xuXHQvKiogQ3JlYXRlIGEgZGVlcCBjb3B5IG9mIGRhdGEgKi9cblx0cHJpdmF0ZSBjbG9uZURlZXAgPSBmdW5jdGlvbihvOiBhbnkpIHtcblx0XHRyZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvKSk7XG5cdH07XG5cblx0LyoqIEV4cG9ydCBkYXRhIGFzIENTVlxuXHQgKiBAcGFyYW0gZmlsZU5hbWUgLSBvcHRpb25hbCBmaWxlIG5hbWUgKG92ZXJyaWRlcyBkZWZhdWx0IGZpbGUgbmFtZSkuXG5cdCAqIEBwYXJhbSB1c2VCT00gLSB1c2UgQk9NIChieXRlIG9yZGVyIG1hcmtlcikuXG5cdCAqL1xuXHRwdWJsaWMgZXhwb3J0Q1NWKGZpbGVOYW1lPzogc3RyaW5nLCB1c2VCT006IGJvb2xlYW4gPSBmYWxzZSkge1xuXHRcdGNvbnN0IGRhdGEgPSB0aGlzLmRhdGEuZXhwb3J0RGF0YTtcblx0XHRsZXQgY3N2ID0gJyc7XG5cdFx0Y29uc3QgQk9NID0gJ1xcdUZFRkYnO1xuXG5cdFx0Ly8gY3N2IGV4cG9ydCBoZWFkZXJzXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9ndFNldHRpbmdzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAodGhpcy5fZ3RTZXR0aW5nc1tpXS5leHBvcnQgIT09IGZhbHNlKSB7XG5cdFx0XHRcdC8vIGdldCBmaWVsZCBzZXR0aW5nc1xuXHRcdFx0XHRjb25zdCBmaWVsZFNldHRpbmcgPSB0aGlzLmdldFByb3BlcnR5KFxuXHRcdFx0XHRcdHRoaXMuX2d0RmllbGRzLFxuXHRcdFx0XHRcdHRoaXMuX2d0U2V0dGluZ3NbaV0ub2JqZWN0S2V5XG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0Ly8gZ2V0IGV4cG9ydCB2YWx1ZSwgaWYgZXhwb3J0SGVhZGVyIHN0cmluZyBpcyBkZWZpbmVkIHVzZSBpdCBvdGhlcndpc2UgcmV0dXJucyBuYW1lXG5cdFx0XHRcdGNvbnN0IGV4cG9ydFZhbHVlOiBzdHJpbmcgPSBmaWVsZFNldHRpbmcuZXhwb3J0SGVhZGVyXG5cdFx0XHRcdFx0PyBmaWVsZFNldHRpbmcuZXhwb3J0SGVhZGVyXG5cdFx0XHRcdFx0OiBmaWVsZFNldHRpbmcubmFtZTtcblxuXHRcdFx0XHRjc3YgKz0gdGhpcy5lc2NhcGVDU1ZEZWxpbWl0ZXIoZXhwb3J0VmFsdWUpO1xuXG5cdFx0XHRcdGNzdiArPSB0aGlzLmdldFByb3BlcnR5KHRoaXMuX2d0RmllbGRzLCB0aGlzLl9ndFNldHRpbmdzW2ldLm9iamVjdEtleSlcblx0XHRcdFx0XHQubmFtZTtcblxuXHRcdFx0XHRpZiAoaSA8IHRoaXMuX2d0U2V0dGluZ3MubGVuZ3RoIC0gMSkge1xuXHRcdFx0XHRcdGNzdiArPSB0aGlzLl9ndE9wdGlvbnMuY3N2RGVsaW1pdGVyO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gY3N2IGV4cG9ydCBib2R5XG5cdFx0ZGF0YS5mb3JFYWNoKHJvdyA9PiB7XG5cdFx0XHRjc3YgKz0gJ1xcbic7XG5cdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2d0U2V0dGluZ3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKHRoaXMuX2d0U2V0dGluZ3NbaV0uZXhwb3J0ICE9PSBmYWxzZSkge1xuXHRcdFx0XHRcdC8vIGdldCBmaWVsZCBzZXR0aW5nc1xuXHRcdFx0XHRcdGNvbnN0IGZpZWxkU2V0dGluZyA9IHRoaXMuZ2V0UHJvcGVydHkoXG5cdFx0XHRcdFx0XHR0aGlzLl9ndEZpZWxkcyxcblx0XHRcdFx0XHRcdHRoaXMuX2d0U2V0dGluZ3NbaV0ub2JqZWN0S2V5XG5cdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdC8vIGdldCBleHBvcnQgdmFsdWUsIGlmIGV4cG9ydCBmdW5jdGlvbiBpcyBkZWZpbmVkIHVzZSBpdCBvdGhlcndpc2UgY2hlY2sgZm9yIHZhbHVlIGZ1bmN0aW9uIGFuZCBhcyBhIGxhc3QgcmVzb3J0IGV4cG9ydCByYXcgZGF0YVxuXHRcdFx0XHRcdGNvbnN0IGV4cG9ydFZhbHVlOiBzdHJpbmcgPVxuXHRcdFx0XHRcdFx0ZmllbGRTZXR0aW5nLmV4cG9ydCAmJiB0eXBlb2YgZmllbGRTZXR0aW5nLmV4cG9ydCA9PT0gJ2Z1bmN0aW9uJ1xuXHRcdFx0XHRcdFx0XHQ/IGZpZWxkU2V0dGluZy5leHBvcnQocm93KVxuXHRcdFx0XHRcdFx0XHQ6IGZpZWxkU2V0dGluZy52YWx1ZSAmJiB0eXBlb2YgZmllbGRTZXR0aW5nLnZhbHVlID09PSAnZnVuY3Rpb24nXG5cdFx0XHRcdFx0XHRcdFx0PyBmaWVsZFNldHRpbmcudmFsdWUocm93KVxuXHRcdFx0XHRcdFx0XHRcdDogcm93W3RoaXMuX2d0U2V0dGluZ3NbaV0ub2JqZWN0S2V5XTtcblxuXHRcdFx0XHRcdGNzdiArPSB0aGlzLmVzY2FwZUNTVkRlbGltaXRlcihleHBvcnRWYWx1ZSk7XG5cblx0XHRcdFx0XHRpZiAoaSA8IHRoaXMuX2d0U2V0dGluZ3MubGVuZ3RoIC0gMSkge1xuXHRcdFx0XHRcdFx0Y3N2ICs9IHRoaXMuX2d0T3B0aW9ucy5jc3ZEZWxpbWl0ZXI7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRjb25zdCBibG9iID0gbmV3IEJsb2IoWyh1c2VCT00gPyBCT00gOiAnJykgKyBjc3ZdLCB7XG5cdFx0XHR0eXBlOiAndGV4dC9jc3Y7Y2hhcnNldD11dGYtOCdcblx0XHR9KTtcblxuXHRcdGlmICh3aW5kb3cubmF2aWdhdG9yLm1zU2F2ZU9yT3BlbkJsb2IpIHtcblx0XHRcdG5hdmlnYXRvci5tc1NhdmVPck9wZW5CbG9iKFxuXHRcdFx0XHRibG9iLFxuXHRcdFx0XHRmaWxlTmFtZSA/IGZpbGVOYW1lICsgJy5jc3YnIDogdGhpcy5ndFRleHRzLmNzdkRvd25sb2FkICsgJy5jc3YnXG5cdFx0XHQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb25zdCBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuXHRcdFx0bGluay5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuXHRcdFx0ZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChsaW5rKTtcblx0XHRcdGlmIChsaW5rLmRvd25sb2FkICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0bGluay5zZXRBdHRyaWJ1dGUoXG5cdFx0XHRcdFx0J2hyZWYnLFxuXHRcdFx0XHRcdCdkYXRhOnRleHQvY3N2O2NoYXJzZXQ9dXRmLTgsJyArXG5cdFx0XHRcdFx0XHRlbmNvZGVVUklDb21wb25lbnQoKHVzZUJPTSA/IEJPTSA6ICcnKSArIGNzdilcblx0XHRcdFx0KTsgLy8gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKSk7XG5cdFx0XHRcdGxpbmsuc2V0QXR0cmlidXRlKFxuXHRcdFx0XHRcdCdkb3dubG9hZCcsXG5cdFx0XHRcdFx0ZmlsZU5hbWUgPyBmaWxlTmFtZSArICcuY3N2JyA6IHRoaXMuZ3RUZXh0cy5jc3ZEb3dubG9hZCArICcuY3N2J1xuXHRcdFx0XHQpO1xuXHRcdFx0XHRkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGxpbmspO1xuXHRcdFx0XHRsaW5rLmNsaWNrKCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjc3YgPSAnZGF0YTp0ZXh0L2NzdjtjaGFyc2V0PXV0Zi04LCcgKyAodXNlQk9NID8gQk9NIDogJycpICsgY3N2O1xuXHRcdFx0XHR3aW5kb3cub3BlbihlbmNvZGVVUklDb21wb25lbnQoY3N2KSk7XG5cdFx0XHR9XG5cdFx0XHRkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKGxpbmspO1xuXHRcdH1cblxuXHRcdC8vIGVtaXQgZXhwb3J0IGV2ZW50XG5cdFx0dGhpcy5ndEV2ZW50LmVtaXQoe1xuXHRcdFx0bmFtZTogJ2d0LWV4cG9ydGVkLWNzdicsXG5cdFx0XHR2YWx1ZTogZmlsZU5hbWUgPyBmaWxlTmFtZSA6IHRoaXMuZ3RUZXh0cy5jc3ZEb3dubG9hZCArICcuY3N2J1xuXHRcdH0pO1xuXHR9XG5cblx0LyoqIFJldHVybiBwcm9wZXJ0eSAqL1xuXHRwcml2YXRlIGdldFByb3BlcnR5ID0gZnVuY3Rpb24oYXJyYXk6IEFycmF5PGFueT4sIGtleTogc3RyaW5nKSB7XG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKGFycmF5W2ldLm9iamVjdEtleSA9PT0ga2V5KSB7XG5cdFx0XHRcdHJldHVybiBhcnJheVtpXTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0cHJpdmF0ZSByZXN0cnVjdHVyZVNvcnRpbmcgPSBmdW5jdGlvbigpIHtcblx0XHQvKiogQ2hlY2sgYW5kIHN0b3JlIHNvcnQgb3JkZXIgdXBvbiBpbml0aWFsaXphdGlvbi5cblx0XHQgKiAgVGhpcyBpcyBkb25lIGJ5IGNoZWNraW5nIHNvcnQgcHJvcGVydGllcyBpbiB0aGUgc2V0dGluZ3MgYXJyYXkgb2YgdGhlIHRhYmxlLCBpZiBubyBzb3J0aW5nIGlzIGRlZmluZWRcblx0XHQgKiAgd2UnbGwgc29ydCB0aGUgZGF0YSBieSB0aGUgZmlyc3QgdmlzaWJsZSBhbmQgZW5hYmxlZCBjb2x1bW4gaW4gdGhlIHRhYmxlKGFzY2VuZGluZykuIFBsZWFzZSBub3RlIHRoYXQgYWN0dWFsbHlcblx0XHQgKiAgc29ydGluZyBoYXZlIHRvIGJlIGRvbmUgc2VydmVyIHNpZGUgd2hlbiBsYXp5IGxvYWRpbmcgZGF0YSBmb3Igb2J2aW91cyByZWFzb25zLiAgKi9cblx0XHQvLyBjcmVhdGUgc29ydGluZyBhcnJheVxuXHRcdGNvbnN0IHNvcnRpbmcgPSBbXTtcblx0XHRpZiAodGhpcy5fZ3RTZXR0aW5ncykge1xuXHRcdFx0Ly8gLi4uc29ydCBzZXR0aW5ncyBieSBzb3J0IG9yZGVyXG5cdFx0XHR0aGlzLl9ndFNldHRpbmdzLnNvcnQodGhpcy5nZXRTb3J0T3JkZXIpO1xuXG5cdFx0XHQvLyAuLi5sb29wIHRocm91Z2ggc2V0dGluZ3Ncblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fZ3RTZXR0aW5ncy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRjb25zdCBzZXR0aW5nID0gdGhpcy5fZ3RTZXR0aW5nc1tpXTtcblxuXHRcdFx0XHQvLyAuLi5pZiBzb3J0ZWQgYXNjZW5kaW5nLi4uXG5cdFx0XHRcdGlmIChzZXR0aW5nLnNvcnQgPT09ICdhc2MnKSB7XG5cdFx0XHRcdFx0Ly8gLi4uIGFkZCB0byBzb3J0aW5nXG5cdFx0XHRcdFx0c29ydGluZy5wdXNoKHNldHRpbmcub2JqZWN0S2V5KTtcblx0XHRcdFx0fSBlbHNlIGlmIChzZXR0aW5nLnNvcnQgPT09ICdkZXNjJykge1xuXHRcdFx0XHRcdC8qIC4uLmVsc2UgaWYgc29ydGVkIGRlc2NlbmRpbmcuLi4gKi8gLy8gLi4uIGFkZCB0byBzb3J0aW5nXG5cdFx0XHRcdFx0c29ydGluZy5wdXNoKCctJyArIHNldHRpbmcub2JqZWN0S2V5KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Ly8gLi4uaWYgbm8gc29ydGluZyBhcHBsaWVkLi4uXG5cdFx0XHRpZiAoc29ydGluZy5sZW5ndGggPT09IDApIHtcblx0XHRcdFx0c29ydGluZy5wdXNoKCckJGd0Um93SWQnKTtcblx0XHRcdFx0LyovLyAuLi5zb3J0IHNldHRpbmdzIGJ5IGNvbHVtbiBvcmRlclxuXHRcdFx0XHR0aGlzLl9ndFNldHRpbmdzLnNvcnQodGhpcy5nZXRDb2x1bW5PcmRlcik7XG5cblx0XHRcdFx0Ly8gLi4ubG9vcCB0aHJvdWdoIHNldHRpbmdzXG5cdFx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fZ3RTZXR0aW5ncy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGNvbnN0IHNldHRpbmcgPSB0aGlzLl9ndFNldHRpbmdzW2ldO1xuXG5cdFx0XHRcdFx0Ly8gLi4uaWYgY29sdW1uIGlzIGVuYWJsZWQgYW5kIHZpc2libGUuLi5cblx0XHRcdFx0XHRpZiAoc2V0dGluZy5lbmFibGVkICE9PSBmYWxzZSAmJiBzZXR0aW5nLnZpc2libGUgIT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0XHQvLyAuLi5hZGQgZmlyc3QgbWF0Y2ggYW5kIGV4aXQgZnVuY3Rpb25cblx0XHRcdFx0XHRcdHRoaXMuc29ydE9yZGVyID0gW3RoaXMuX2d0U2V0dGluZ3NbaV0ub2JqZWN0S2V5XTtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0qL1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICh0aGlzLnNvcnRPcmRlci5sZW5ndGggPT09IDApIHtcblx0XHRcdHRoaXMuc29ydE9yZGVyID0gc29ydGluZztcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEVzY2FwZSBleHBvcnQgdmFsdWUgdXNpbmcgZG91YmxlIHF1b3RlcyAoXCIpIGlmIGV4cG9ydCB2YWx1ZSBjb250YWlucyBkZWxpbWl0ZXJcblx0ICogQHBhcmFtIHZhbHVlIFZhbHVlIHRvIGJlIGVzY2FwZWRcblx0ICovXG5cdHByaXZhdGUgZXNjYXBlQ1NWRGVsaW1pdGVyKHZhbHVlKSB7XG5cdFx0cmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgJiZcblx0XHRcdHZhbHVlLmluZGV4T2YodGhpcy5fZ3RPcHRpb25zLmNzdkRlbGltaXRlcikgIT09IC0xXG5cdFx0XHQ/ICdcIicgKyB2YWx1ZSArICdcIidcblx0XHRcdDogdmFsdWU7XG5cdH1cblxuXHRuZ09uSW5pdCgpIHtcblx0XHQvLyBpZiBudW1iZXIgb2Ygcm93IHRvIGRpc3BsYXkgZnJvbSBzdGFydCBpcyBzZXQgdG8gbnVsbCBvciAwLi4uXG5cdFx0aWYgKCF0aGlzLmd0T3B0aW9ucy5udW1iZXJPZlJvd3MpIHtcblx0XHRcdC8vIC4uLmNoYW5nZSByb3cgbGVuZ3RoXG5cdFx0XHR0aGlzLmNoYW5nZVJvd0xlbmd0aCh0aGlzLmd0T3B0aW9ucy5udW1iZXJPZlJvd3MpO1xuXHRcdH1cblx0XHR0aGlzLnJlc3RydWN0dXJlU29ydGluZygpO1xuXHR9XG5cblx0LyoqXG5cdCAqICBFeHRlbmQgb2JqZWN0IGZ1bmN0aW9uLlxuXHQgKi9cblx0cHJpdmF0ZSBleHRlbmQgPSBmdW5jdGlvbihhOiBPYmplY3QsIGI6IE9iamVjdCkge1xuXHRcdGZvciAoY29uc3Qga2V5IGluIGIpIHtcblx0XHRcdGlmIChiLmhhc093blByb3BlcnR5KGtleSkpIHtcblx0XHRcdFx0YVtrZXldID0gYltrZXldO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gYTtcblx0fTtcblxuXHRuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKSB7XG5cdFx0Ly8gaWYgZ3QgdGV4dHMgaGF2ZSBjaGFuZ2VkLi4uXG5cdFx0aWYgKGNoYW5nZXNbJ2d0VGV4dHMnXSkge1xuXHRcdFx0Ly8gLi4uZXh0ZW5kIGd0T3B0aW9ucyBkZWZhdWx0IHZhbHVlcyB3aXRoIHZhbHVlcyBwYXNzZWQgaW50byBjb21wb25lbnRcblx0XHRcdHRoaXMuZ3RUZXh0cyA9IDxHdFRleHRzPnRoaXMuZXh0ZW5kKHRoaXMuZ3REZWZhdWx0VGV4dHMsIHRoaXMuZ3RUZXh0cyk7XG5cdFx0fVxuXG5cdFx0Ly8gaWYgbGF6eSBsb2FkaW5nIGRhdGEgYW5kIHBhZ2luZyBpbmZvcm1hdGlvbiBpcyBhdmFpbGFibGUuLi5cblx0XHRpZiAodGhpcy5ndE9wdGlvbnMubGF6eUxvYWQgJiYgdGhpcy5ndEluZm8pIHtcblx0XHRcdC8vIC4uLmNhbGN1bGF0ZSB0b3RhbCBudW1iZXIgb2YgcGFnZXNcblx0XHRcdHRoaXMuZ3RJbmZvLnBhZ2VUb3RhbCA9IE1hdGguY2VpbChcblx0XHRcdFx0dGhpcy5ndEluZm8ucmVjb3Jkc0FmdGVyU2VhcmNoIC8gdGhpcy5ndEluZm8ucmVjb3JkTGVuZ3RoXG5cdFx0XHQpO1xuXG5cdFx0XHQvLyAuLi5kZWNsYXJlIHN0b3JlIHBvc2l0aW9uXG5cdFx0XHRjb25zdCBzdG9yZVBvc2l0aW9uID0gdGhpcy5ndEluZm8ucGFnZUN1cnJlbnQgLSAxO1xuXG5cdFx0XHQvLyAuLi5hbmQgaWYgc3RvcmUgaXMgZW1wdHkgb3IgcGFnZSBsZW5ndGggaGFzIGNoYW5nZWQuLi5cblx0XHRcdGlmIChcblx0XHRcdFx0dGhpcy5zdG9yZS5sZW5ndGggPT09IDAgfHxcblx0XHRcdFx0dGhpcy5zdG9yZVswXS5sZW5ndGggIT09IHRoaXMuZ3RJbmZvLnJlY29yZExlbmd0aFxuXHRcdFx0KSB7XG5cdFx0XHRcdC8vIC4uLmNyZWF0ZSBzdG9yZVxuXHRcdFx0XHR0aGlzLnN0b3JlID0gdGhpcy5jcmVhdGVTdG9yZShcblx0XHRcdFx0XHR0aGlzLmd0SW5mby5yZWNvcmRzQWZ0ZXJTZWFyY2gsXG5cdFx0XHRcdFx0dGhpcy5ndEluZm8ucmVjb3JkTGVuZ3RoXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIC4uLnN0b3JlIHJldHJpZXZlZCBkYXRhIGluIHN0b3JlIGF0IHN0b3JlIHBvc2l0aW9uXG5cdFx0XHR0aGlzLnN0b3JlW3N0b3JlUG9zaXRpb25dID0gdGhpcy5ndERhdGE7XG5cdFx0XHR0aGlzLmd0SW5mby52aXNpYmxlUmVjb3JkcyA9IFsuLi50aGlzLmd0RGF0YV07IC8vIGFkZCB2aXNpYmxlIHJvd3NcblxuXHRcdFx0Ly8gcmVwbGFjZSBkYXRhIHdpdGggc3RvcmVcblx0XHRcdHRoaXMuX2d0RGF0YSA9IHRoaXMuc3RvcmU7XG5cdFx0XHR0aGlzLmxvYWRpbmcgPSBmYWxzZTtcblx0XHRcdHRoaXMudXBkYXRlUmVjb3JkUmFuZ2UoKTtcblx0XHRcdHRoaXMuZ3RFdmVudC5lbWl0KHtcblx0XHRcdFx0bmFtZTogJ2d0LWluZm8nLFxuXHRcdFx0XHR2YWx1ZTogdGhpcy5ndEluZm9cblx0XHRcdH0pO1xuXHRcdH0gZWxzZSBpZiAoXG5cdFx0XHR0aGlzLl9ndERhdGEgJiZcblx0XHRcdHRoaXMuX2d0RGF0YS5sZW5ndGggPj0gMCAmJlxuXHRcdFx0Y2hhbmdlc1snZ3REYXRhJ10gJiZcblx0XHRcdGNoYW5nZXNbJ2d0RGF0YSddLnByZXZpb3VzVmFsdWVcblx0XHQpIHtcblx0XHRcdHRoaXMubG9hZGluZyA9IGZhbHNlO1xuXHRcdH0gZWxzZSBpZiAoXG5cdFx0XHRjaGFuZ2VzWydndERhdGEnXSAmJlxuXHRcdFx0Y2hhbmdlc1snZ3REYXRhJ10uZmlyc3RDaGFuZ2UgJiZcblx0XHRcdHRoaXMuX2d0RGF0YSAmJlxuXHRcdFx0dGhpcy5fZ3REYXRhLmxlbmd0aCA+IDBcblx0XHQpIHtcblx0XHRcdHRoaXMubG9hZGluZyA9IGZhbHNlO1xuXHRcdH1cblx0fVxuXG5cdHRyYWNrQnlGbihpbmRleDogbnVtYmVyLCBpdGVtOiBHdFJvdykge1xuXHRcdHJldHVybiBpdGVtLiQkZ3RSb3dJZDtcblx0fVxuXG5cdHRyYWNrQnlDb2x1bW5GbihpbmRleDogbnVtYmVyLCBpdGVtOiBHdENvbmZpZ0ZpZWxkPGFueSwgYW55Pikge1xuXHRcdHJldHVybiBpdGVtLm9iamVjdEtleTtcblx0fVxuXG5cdG5nT25EZXN0cm95KCkge1xuXHRcdC8vIHJlbW92ZSBsaXN0ZW5lclxuXHRcdHRoaXMuX3N0b3BMaXN0ZW5pbmdGb3JLZXlkb3duRXZlbnQoKTtcblx0fVxufVxuIl19