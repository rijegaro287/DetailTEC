/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Component, EventEmitter, Input, Output, Renderer2, Type } from '@angular/core';
import { GtMetaPipe } from '../pipes/gt-meta.pipe';
// unsupported: template constraints.
// unsupported: template constraints.
/**
 * @template R, C
 */
var GenericTableComponent = /** @class */ (function () {
    function GenericTableComponent(renderer, gtMetaPipe) {
        var _this = this;
        this.renderer = renderer;
        this.gtMetaPipe = gtMetaPipe;
        this.columnWidth = {};
        this.sortOrder = [];
        this.metaInfo = {};
        this.selectedRows = [];
        this.openRows = [];
        this._gtSettings = [];
        this._gtFields = [];
        this.gtDefaultTexts = {
            loading: 'Loading...',
            noData: 'No data',
            noMatchingData: 'No data matching results found',
            noVisibleColumnsHeading: 'No visible columns',
            noVisibleColumns: 'Please select at least one column to be visible.',
            tableInfo: 'Showing #recordFrom to #recordTo of #recordsAfterSearch entries.',
            tableInfoAfterSearch: 'Showing  #recordFrom to #recordTo of #recordsAfterSearch entries (filtered from a total of #recordsAll entries).',
            csvDownload: 'download',
            sortLabel: 'Sort:',
            paginateNext: 'Next page',
            paginatePrevious: 'Previous page',
            inlineEditEdited: 'Press enter to save'
        };
        this.gtTexts = this.gtDefaultTexts;
        this.gtEvent = new EventEmitter();
        this.gtDefaultOptions = {
            csvDelimiter: ';',
            stack: false,
            lazyLoad: false,
            cache: false,
            debounceTime: 200,
            highlightSearch: false,
            rowSelection: false,
            rowSelectionAllowMultiple: true,
            rowExpandAllowMultiple: true,
            numberOfRows: 10,
            reportColumnWidth: false,
            allowUnsorted: true,
            mutateData: true
        };
        this._gtOptions = this.gtDefaultOptions;
        this.store = [];
        this.loading = true;
        this.debounceTimer = null;
        this.lazyAllSelected = false;
        this.gtInfo = {
            pageCurrent: 1,
            pageTotal: 0,
            recordFrom: 0,
            recordTo: 0,
            recordLength: this.gtOptions.numberOfRows,
            recordsAll: 0,
            recordsAfterFilter: 0,
            recordsAfterSearch: 0
        };
        this.refreshPipe = false;
        this.refreshTotals = false;
        this.refreshSorting = false;
        this.refreshFilter = false;
        this.refreshPageArray = false;
        this.editedRows = {};
        this.data = { exportData: [] };
        /**
         * Sort table by object key.
         * @param objectKey - name of key to sort on.
         * @param event - such as key press during sorting.
         */
        this.gtSort = function (objectKey, event) {
            this.inlineEditCancel(); // cancel inline editing
            // loop through current settings
            for (var /** @type {?} */ i = 0; i < this._gtSettings.length; i++) {
                if (this._gtSettings[i].objectKey === objectKey) {
                    // check if sorting is disabled...
                    if (this._gtSettings[i].sort &&
                        this._gtSettings[i].sort.indexOf('disable') !== -1) {
                        // ...if so, exit function without applying any sorting
                        return;
                    }
                    else if (/* check if sorting is undefined... */ typeof this._gtSettings[i]
                        .sort === 'undefined') {
                        // ...is so, set sorting property to enable
                        this._gtSettings[i].sort = 'enable';
                    }
                }
            }
            // check length
            var /** @type {?} */ ctrlKey = event.metaKey || event.ctrlKey;
            var /** @type {?} */ sort = this.sortOrder.slice(0);
            var /** @type {?} */ match = -1;
            var /** @type {?} */ matchDesc = -1;
            var /** @type {?} */ pos = -1;
            // check if property already exits
            for (var /** @type {?} */ i = 0; i < sort.length; i++) {
                var /** @type {?} */ hit = sort[i].indexOf(objectKey);
                if (hit !== -1) {
                    match = this.sortOrder.indexOf(objectKey);
                    matchDesc =
                        match === -1 ? this.sortOrder.indexOf('-' + objectKey) : match;
                    pos = Math.max(match, matchDesc);
                }
            }
            // if ctrl key or meta key is press together with sort...
            if (ctrlKey) {
                if (this.sortOrder[this.sortOrder.length - 1] === '$$gtInitialRowIndex') {
                    this.sortOrder.pop();
                }
                switch (pos) {
                    // ...and property is not sorted before...
                    case -1:
                        // ...add property to sorting
                        this.sortOrder.push(objectKey);
                        break;
                    default:
                        // ...and property is sorted before...
                        if (match !== -1) {
                            // ...change from asc to desc if sorted asc
                            this.sortOrder[pos] = '-' + objectKey;
                        }
                        else if (this.sortOrder.length > 1) {
                            // ...remove sorting if sorted desc
                            if (ctrlKey) {
                                this.sortOrder[pos] = objectKey;
                            }
                            else {
                                this.sortOrder.splice(pos, 1);
                            }
                        }
                        else if (this.sortOrder.length === 1) {
                            // ...set sorting to asc if only sorted property
                            this.sortOrder[pos] = objectKey;
                        }
                        break;
                }
            }
            else {
                /* if ctrl key or meta key is not press together with sort... */
                switch (pos) {
                    // ...and property is not sorted before...
                    case -1:
                        // ...sort by property
                        this.sortOrder = [objectKey];
                        break;
                    default:
                        // ...change from desc to asc and vise versa
                        this.sortOrder =
                            match !== -1
                                ? ['-' + objectKey]
                                : ctrlKey || !this.gtOptions.allowUnsorted
                                    ? [objectKey]
                                    : [];
                        break;
                }
            }
            // update settings object with new sorting information
            for (var /** @type {?} */ i = 0; i < this._gtSettings.length; i++) {
                if (this._gtSettings[i].objectKey === objectKey) {
                    switch (this._gtSettings[i].sort) {
                        // if sorted asc...
                        case 'asc':
                            // ...change to desc
                            this._gtSettings[i].sort = 'desc';
                            break;
                        // if sorted desc...
                        case 'desc':
                            // ...change to asc if it's the only sorted property otherwise remove sorting
                            this._gtSettings[i].sort =
                                (this.sortOrder.length === 1 && sort.length < 2) ||
                                    ctrlKey ||
                                    !this.gtOptions.allowUnsorted
                                    ? 'asc'
                                    : 'enable';
                            break;
                        // if sorting enabled...
                        case 'enable':
                            // ...change to asc
                            this._gtSettings[i].sort = 'asc';
                            break;
                    }
                    this._gtSettings[i].sortOrder =
                        this._gtSettings[i].sort === 'enable'
                            ? this._gtSettings.length - 1
                            : this.sortOrder.indexOf(objectKey) === -1
                                ? this.sortOrder.indexOf('-' + objectKey)
                                : this.sortOrder.indexOf(objectKey);
                }
                else if (this._gtSettings[i].sort &&
                    this._gtSettings[i].sort.indexOf('disable') === -1 &&
                    this.sortOrder.indexOf(this._gtSettings[i].objectKey) === -1 &&
                    this.sortOrder.indexOf('-' + this._gtSettings[i].objectKey) === -1) {
                    this._gtSettings[i].sort = 'enable';
                    this._gtSettings[i].sortOrder = this._gtSettings.length - 1;
                }
            }
            // refresh sorting pipe
            this.refreshSorting = !this.refreshSorting;
            this.refreshPageArray = !this.refreshPageArray;
            // sort by initial sort order as last resort
            this.sortOrder.push('$$gtInitialRowIndex');
            // emit sort event
            this.gtEvent.emit({
                name: 'gt-sorting-applied',
                value: this.sortOrder
            });
        };
        /**
         * Change number of rows to be displayed.
         * @param rowLength - total number of rows.
         * @param reset - should page be reset to first page.
         */
        this.changeRowLength = function (rowLength, reset) {
            var /** @type {?} */ lengthValue = isNaN(parseInt(rowLength, 10))
                ? 0
                : parseInt(rowLength, 10);
            var /** @type {?} */ newPosition = 1;
            if (!lengthValue && this.gtData) {
                lengthValue = this.gtData.length;
            }
            // if reset is not true and we're not lazy loading data...
            if (reset !== true && this._gtOptions.lazyLoad !== true) {
                // ...get current position in record set
                var /** @type {?} */ currentRecord = this.gtInfo.recordLength * (this.gtInfo.pageCurrent - 1);
                var /** @type {?} */ currentPosition = this._gtData.indexOf(this._gtData[currentRecord]) + 1;
                // ...get new position
                newPosition = Math.ceil(currentPosition / lengthValue);
            }
            // change row length
            this.gtInfo.recordLength = lengthValue;
            // go to new position
            this.gtInfo.pageCurrent = newPosition;
            // if lazy loading data...
            if (this._gtOptions.lazyLoad) {
                // ...replace data with place holders for new data
                this._gtData[0] = this.loadingContent(lengthValue);
                // ...empty current store
                this.store = [];
            }
            // this.updateRecordRange();
            this.gtEvent.emit({
                name: 'gt-row-length-changed',
                value: lengthValue
            });
        };
        /**
         * Force a redraw of table rows.
         * As the table uses pure pipes, we need to force a redraw if an object in the array is changed to see the changes.
         */
        this.redraw = function ($event) {
            this.refreshSorting = !this.refreshSorting;
            this.refreshPageArray = !this.refreshPageArray;
            this.refreshPipe = !this.refreshPipe;
        };
        /**
         * Go to next page.
         */
        this.nextPage = function () {
            var /** @type {?} */ page = this.gtInfo.pageCurrent === this.gtInfo.pageTotal
                ? this.gtInfo.pageTotal
                : this.gtInfo.pageCurrent + 1;
            this.goToPage(page);
        };
        /**
         * Go to previous page.
         */
        this.previousPage = function () {
            var /** @type {?} */ page = this.gtInfo.pageCurrent === 1 ? 1 : this.gtInfo.pageCurrent - 1;
            this.goToPage(page);
        };
        /**
         * Request more data (used when lazy loading)
         */
        this.getData = function () {
            // ...emit event requesting for more data
            this.gtEvent.emit({
                name: 'gt-page-changed-lazy',
                value: {
                    pageCurrent: this.gtInfo.pageCurrent,
                    recordLength: this.gtInfo.recordLength
                }
            });
        };
        /**
         * Go to specific page.
         * @param page - page number.
         */
        this.goToPage = function (page) {
            var _this = this;
            var /** @type {?} */ previousPage = this.gtInfo.pageCurrent;
            this.gtInfo.pageCurrent = page;
            this.inlineEditCancel(); // cancel inline edit
            // if lazy loading and if page contains no records...
            if (this._gtOptions.lazyLoad) {
                // ...if data for current page contains no entries...
                if (this._gtOptions.cache === false ||
                    this._gtData[this.gtInfo.pageCurrent - 1].length === 0) {
                    // ...create temporary content while waiting for data
                    this._gtData[this.gtInfo.pageCurrent - 1] = this.loadingContent(this.gtInfo.recordLength);
                    this.loading = true; // loading true
                }
                // ...if first entry in current page equals our loading placeholder...
                if (this._gtData[this.gtInfo.pageCurrent - 1][0][this.loadingProperty] ===
                    this.gtTexts.loading) {
                    // ...get data
                    clearTimeout(this.debounceTimer);
                    this.debounceTimer = setTimeout(function () {
                        _this.getData();
                    }, this._gtOptions.debounceTime);
                }
            }
            // this.updateRecordRange();
            // ...emit page change event
            if (previousPage !== page) {
                this.gtEvent.emit({
                    name: 'gt-page-changed',
                    value: {
                        pageCurrent: this.gtInfo.pageCurrent,
                        pagePrevious: previousPage,
                        recordLength: this.gtInfo.recordLength
                    }
                });
            }
        };
        /**
         * Sort by sort order
         */
        this.getSortOrder = function (a, b) {
            if (a.sortOrder < b.sortOrder) {
                return -1;
            }
            if (a.sortOrder > b.sortOrder || typeof a.sortOrder === 'undefined') {
                return 1;
            }
            return 0;
        };
        /**
         * Sort by column order
         */
        this.getColumnOrder = function (a, b) {
            if (a.columnOrder === undefined) {
                return -1;
            }
            if (a.columnOrder < b.columnOrder) {
                return -1;
            }
            if (a.columnOrder > b.columnOrder) {
                return 1;
            }
            return 0;
        };
        /**
         * Create a deep copy of data
         */
        this.cloneDeep = function (o) {
            return JSON.parse(JSON.stringify(o));
        };
        /**
         * Return property
         */
        this.getProperty = function (array, key) {
            for (var /** @type {?} */ i = 0; i < array.length; i++) {
                if (array[i].objectKey === key) {
                    return array[i];
                }
            }
        };
        this.restructureSorting = function () {
            /**
             * Check and store sort order upon initialization.
             *  This is done by checking sort properties in the settings array of the table, if no sorting is defined
             *  we'll sort the data by the first visible and enabled column in the table(ascending). Please note that actually
             *  sorting have to be done server side when lazy loading data for obvious reasons.
             */
            var /** @type {?} */ sorting = [];
            if (this._gtSettings) {
                // ...sort settings by sort order
                this._gtSettings.sort(this.getSortOrder);
                // ...loop through settings
                for (var /** @type {?} */ i = 0; i < this._gtSettings.length; i++) {
                    var /** @type {?} */ setting = this._gtSettings[i];
                    // ...if sorted ascending...
                    if (setting.sort === 'asc') {
                        // ... add to sorting
                        sorting.push(setting.objectKey);
                    }
                    else if (setting.sort === 'desc') {
                        /* ...else if sorted descending... */ 
                        // ... add to sorting
                        sorting.push('-' + setting.objectKey);
                    }
                }
                // ...if no sorting applied...
                if (sorting.length === 0) {
                    sorting.push('$$gtRowId');
                    /*// ...sort settings by column order
                                    this._gtSettings.sort(this.getColumnOrder);
                    
                                    // ...loop through settings
                                    for (let i = 0; i < this._gtSettings.length; i++) {
                                        const setting = this._gtSettings[i];
                    
                                        // ...if column is enabled and visible...
                                        if (setting.enabled !== false && setting.visible !== false) {
                                            // ...add first match and exit function
                                            this.sortOrder = [this._gtSettings[i].objectKey];
                                            return;
                                        }
                                    }*/
                }
            }
            if (this.sortOrder.length === 0) {
                this.sortOrder = sorting;
            }
        };
        /**
         *  Extend object function.
         */
        this.extend = function (a, b) {
            for (var /** @type {?} */ key in b) {
                if (b.hasOwnProperty(key)) {
                    a[key] = b[key];
                }
            }
            return a;
        };
        this.gtEvent.subscribe(function ($event) {
            if ($event.name === 'gt-info') {
                _this.updateRecordRange();
            }
            if ($event.name === 'gt-row-updated') {
                _this.updateTotals();
            }
        });
    }
    Object.defineProperty(GenericTableComponent.prototype, "gtRowComponent", {
        get: /**
         * @return {?}
         */
        function () {
            return this._gtRowComponent;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            console.warn('GtRowComponent has been deprecated and support will be removed in a future release, see https://github.com/hjalmers/angular-generic-table/issues/34');
            this._gtRowComponent = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GenericTableComponent.prototype, "hasEdits", {
        get: /**
         * @return {?}
         */
        function () {
            return Object.keys(this.editedRows).length > 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GenericTableComponent.prototype, "gtOptions", {
        get: /**
         * @return {?}
         */
        function () {
            return this._gtOptions;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._gtOptions = value;
            // if number of rows is passed and if number of rows differs from current record length...
            if (this.gtOptions.numberOfRows &&
                this.gtInfo.recordLength !== this.gtOptions.numberOfRows) {
                // ...update record length and redraw table
                this.gtInfo.recordLength = this.gtOptions.numberOfRows;
                this.redraw();
            }
            // ...extend gtOptions default values with values passed into component
            this._gtOptions = /** @type {?} */ (this.extend(this.gtDefaultOptions, this._gtOptions));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GenericTableComponent.prototype, "gtTotals", {
        get: /**
         * @return {?}
         */
        function () {
            return this._gtTotals;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._gtTotals = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GenericTableComponent.prototype, "gtFields", {
        get: /**
         * @return {?}
         */
        function () {
            return this._gtFields;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._gtFields = value;
            var /** @type {?} */ COLUMNS_WITH_CLASS_NAMES = this._gtFields
                .map(function (column) { return column; })
                .filter(function (column) { return column.classNames; });
            // TODO: remove deprecated warning when setting has been removed
            if (COLUMNS_WITH_CLASS_NAMES.length > 0) {
                console.warn('Field setting "classNames" have been deprecated in favor for "columnClass" and will be removed in the future, please update field settings for column with object key: ' +
                    COLUMNS_WITH_CLASS_NAMES[0].objectKey);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GenericTableComponent.prototype, "gtSettings", {
        get: /**
         * @return {?}
         */
        function () {
            return this._gtSettings;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._gtSettings = value;
            // loop through current settings
            for (var /** @type {?} */ i = 0; i < this._gtSettings.length; i++) {
                // set sort enabled/disabled setting
                this._gtSettings[i].sortEnabled =
                    this._gtSettings[i].sortEnabled !== false
                        ? (this._gtSettings[i].sortEnabled = !(this._gtSettings[i].sort &&
                            this._gtSettings[i].sort.indexOf('disable') !== -1))
                        : false;
                // check if sorting is undefined...
                if (typeof this._gtSettings[i].sort === 'undefined') {
                    // ...is so, set sorting property to enable
                    this._gtSettings[i].sort = 'enable';
                }
                // check if column order is undefined...
                if (typeof this._gtSettings[i].columnOrder === 'undefined' &&
                    this._gtSettings[i].enabled !== false) {
                    // ...is so, set sorting property to enable
                    this._gtSettings[i].columnOrder = this._gtSettings[i - 1]
                        ? this._gtSettings[i - 1].columnOrder + 1
                        : 0;
                }
                // check if column lock settings are undefined...
                if (typeof this._gtSettings[i].lockSettings === 'undefined') {
                    // ...if so, set lock settings to false unless field is disabled (enable === false)
                    this._gtSettings[i].lockSettings =
                        this._gtSettings[i].enabled === false || false;
                }
            }
            this.restructureSorting();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GenericTableComponent.prototype, "gtData", {
        get: /**
         * @return {?}
         */
        function () {
            return this._gtData;
        },
        set: /**
         * @param {?} initialData
         * @return {?}
         */
        function (initialData) {
            var _this = this;
            var /** @type {?} */ data = this._gtOptions.mutateData
                ? tslib_1.__spread(initialData) : this.cloneDeep(initialData);
            if (this.gtOptions.lazyLoad && this.gtInfo) {
                this.gtMetaPipe.transform(data, this.gtOptions.rowIndex, this.gtInfo.pageCurrent - 1, this.gtInfo.recordLength);
                if (this.lazyAllSelected) {
                    var /** @type {?} */ UNIQUE_ROWS_1 = this.selectedRows.map(function (row) { return row.$$gtRowId; });
                    data.map(function (row) {
                        if (UNIQUE_ROWS_1.indexOf(row.$$gtRowId) === -1) {
                            _this.selectedRows.push(row);
                        }
                    });
                    this._updateMetaInfo(this.selectedRows, 'isSelected', true);
                }
            }
            else {
                this.gtMetaPipe.transform(data, this.gtOptions.rowIndex);
            }
            if (this.gtOptions.rowSelectionInitialState) {
                data.map(function (row) {
                    var /** @type {?} */ selected = typeof _this.gtOptions.rowSelectionInitialState === 'function'
                        ? _this.gtOptions.rowSelectionInitialState(row)
                        : _this.gtOptions.rowSelectionInitialState;
                    if (selected) {
                        if (typeof _this.metaInfo[row.$$gtRowId] === 'undefined') {
                            _this.metaInfo[row.$$gtRowId] = { isSelected: true };
                        }
                        else {
                            _this.metaInfo[row.$$gtRowId].isSelected = true;
                        }
                        _this.selectedRows.push(row);
                    }
                });
            }
            if (this.gtOptions.rowExpandInitialState &&
                this.gtOptions.rowExpandInitialComponent) {
                data.map(function (row) {
                    var /** @type {?} */ expanded = typeof _this.gtOptions.rowExpandInitialState === 'function'
                        ? _this.gtOptions.rowExpandInitialState(row)
                        : _this.gtOptions.rowExpandInitialState;
                    _this.expandedRow = _this.gtOptions.rowExpandInitialComponent;
                    if (expanded) {
                        if (typeof _this.metaInfo[row.$$gtRowId] === 'undefined') {
                            _this.metaInfo[row.$$gtRowId] = { isOpen: true };
                        }
                        else {
                            _this.metaInfo[row.$$gtRowId].isOpen = true;
                        }
                    }
                });
            }
            this._gtData = data;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Update record range.
     * @return {?}
     */
    GenericTableComponent.prototype.updateRecordRange = /**
     * Update record range.
     * @return {?}
     */
    function () {
        this.gtInfo.recordFrom =
            this.gtInfo.recordsAfterSearch === 0
                ? 0
                : (this.gtInfo.pageCurrent - 1) * this.gtInfo.recordLength + 1;
        this.gtInfo.recordTo =
            this.gtInfo.recordsAfterSearch <
                this.gtInfo.pageCurrent * this.gtInfo.recordLength
                ? this.gtInfo.recordsAfterSearch
                : this.gtInfo.pageCurrent * this.gtInfo.recordLength;
    };
    /**
     * Update totals.
     * @return {?}
     */
    GenericTableComponent.prototype.updateTotals = /**
     * Update totals.
     * @return {?}
     */
    function () {
        this.refreshTotals = !this.refreshTotals;
    };
    /**
     * Get meta data for row.
     * @param {?} row
     * @return {?}
     */
    GenericTableComponent.prototype.getRowState = /**
     * Get meta data for row.
     * @param {?} row
     * @return {?}
     */
    function (row) {
        return typeof this.metaInfo[row.$$gtRowId] === 'undefined'
            ? null
            : this.metaInfo[row.$$gtRowId];
    };
    /**
     * Expand all rows.
     * @param {?} expandedRow - component to render when rows are expanded.
     * @return {?}
     */
    GenericTableComponent.prototype.expandAllRows = /**
     * Expand all rows.
     * @param {?} expandedRow - component to render when rows are expanded.
     * @return {?}
     */
    function (expandedRow) {
        this.expandedRow = expandedRow;
        this._toggleAllRowProperty('isOpen', true);
    };
    /**
     * Collapse all rows.
     * @return {?}
     */
    GenericTableComponent.prototype.collapseAllRows = /**
     * Collapse all rows.
     * @return {?}
     */
    function () {
        this._toggleAllRowProperty('isOpen', false);
    };
    /**
     * Select all rows.
     * @return {?}
     */
    GenericTableComponent.prototype.selectAllRows = /**
     * Select all rows.
     * @return {?}
     */
    function () {
        this._toggleAllRowProperty('isSelected', true);
    };
    /**
     * Deselect all rows.
     * @return {?}
     */
    GenericTableComponent.prototype.deselectAllRows = /**
     * Deselect all rows.
     * @return {?}
     */
    function () {
        this._toggleAllRowProperty('isSelected', false);
    };
    /**
     * Toggle all rows.
     * @return {?}
     */
    GenericTableComponent.prototype.toggleAllRows = /**
     * Toggle all rows.
     * @return {?}
     */
    function () {
        if (this._gtOptions.lazyLoad) {
            if (!this.lazyAllSelected || this.selectedRows.length === 0) {
                this.selectAllRows();
                this.lazyAllSelected = true;
            }
            else {
                this.deselectAllRows();
                this.lazyAllSelected = false;
            }
        }
        else {
            if (this.selectedRows.length !== this.gtData.length) {
                this.selectAllRows();
            }
            else {
                this.deselectAllRows();
            }
        }
    };
    /**
     * Toggle row collapsed state ie. expanded/open or collapsed/closed.
     * @param {?} row - row object that should be expanded/collapsed.
     * @param {?=} expandedRow - component to render when row is expanded.
     * @return {?}
     */
    GenericTableComponent.prototype.toggleCollapse = /**
     * Toggle row collapsed state ie. expanded/open or collapsed/closed.
     * @param {?} row - row object that should be expanded/collapsed.
     * @param {?=} expandedRow - component to render when row is expanded.
     * @return {?}
     */
    function (row, expandedRow) {
        if (expandedRow) {
            this.expandedRow = expandedRow;
        }
        this._toggleRowProperty(row, 'isOpen');
    };
    /**
     * Toggle row selected state ie. selected or not.
     * @param {?} row - row object that should be selected/deselected.
     * @return {?}
     */
    GenericTableComponent.prototype.toggleSelect = /**
     * Toggle row selected state ie. selected or not.
     * @param {?} row - row object that should be selected/deselected.
     * @return {?}
     */
    function (row) {
        this._toggleRowProperty(row, 'isSelected');
    };
    /**
     * @param {?} row
     * @param {?} $event
     * @return {?}
     */
    GenericTableComponent.prototype.rowClick = /**
     * @param {?} row
     * @param {?} $event
     * @return {?}
     */
    function (row, $event) {
        this.gtEvent.emit({
            name: 'gt-row-clicked',
            value: { row: row, event: $event }
        });
    };
    /**
     * Update row data.
     * @param {?} row - row object that has been edited.
     * @param {?} oldValue - row object before edit.
     * @return {?}
     */
    GenericTableComponent.prototype.updateRow = /**
     * Update row data.
     * @param {?} row - row object that has been edited.
     * @param {?} oldValue - row object before edit.
     * @return {?}
     */
    function (row, oldValue) {
        this._toggleRowProperty(row, 'isUpdated', oldValue);
    };
    /**
     * removes a row from the table
     * @param {?} row - the row object to remove
     * @return {?}
     */
    GenericTableComponent.prototype.removeRow = /**
     * removes a row from the table
     * @param {?} row - the row object to remove
     * @return {?}
     */
    function (row) {
        if (this.isRowSelected(row)) {
            this.toggleSelect(row);
        }
        var /** @type {?} */ index = this._gtData.indexOf(row);
        this._gtData.splice(index, 1);
    };
    /**
     * check if a row is selected
     * @param {?} row - row object
     * @return {?}
     */
    GenericTableComponent.prototype.isRowSelected = /**
     * check if a row is selected
     * @param {?} row - row object
     * @return {?}
     */
    function (row) {
        return (this.metaInfo[row.$$gtRowId] && this.metaInfo[row.$$gtRowId].isSelected);
    };
    /**
     * Update meta info for all rows, ie. isSelected, isOpen.
     * @param {?} array - array that holds rows that need to be updated.
     * @param {?} property - name of property that should be changed/toggled.
     * @param {?} active - should rows be expanded/open, selected.
     * @param {?=} exception - update all rows except this one.
     * @return {?}
     */
    GenericTableComponent.prototype._updateMetaInfo = /**
     * Update meta info for all rows, ie. isSelected, isOpen.
     * @param {?} array - array that holds rows that need to be updated.
     * @param {?} property - name of property that should be changed/toggled.
     * @param {?} active - should rows be expanded/open, selected.
     * @param {?=} exception - update all rows except this one.
     * @return {?}
     */
    function (array, property, active, exception) {
        for (var /** @type {?} */ i = 0; i < array.length; i++) {
            if (!this.metaInfo[array[i].$$gtRowId]) {
                this.metaInfo[array[i].$$gtRowId] = {};
            }
            if (exception && array[i].$$gtRowId === exception.$$gtRowId) {
            }
            else {
                this.metaInfo[array[i].$$gtRowId][property] = active;
            }
        }
    };
    /**
     * Push selected/expanded lazy loaded rows to array with meta data.
     * @param {?} target - array to which rows should be added.
     * @param {?} source - array that holds rows that should be added.
     * @return {?} array with added rows.
     */
    GenericTableComponent.prototype._pushLazyRows = /**
     * Push selected/expanded lazy loaded rows to array with meta data.
     * @param {?} target - array to which rows should be added.
     * @param {?} source - array that holds rows that should be added.
     * @return {?} array with added rows.
     */
    function (target, source) {
        var /** @type {?} */ UNIQUE_ROWS = target.map(function (row) { return row.$$gtRowId; });
        for (var /** @type {?} */ i = 0; i < source.length; i++) {
            // only add if not already in list
            if (UNIQUE_ROWS.indexOf(source[i].$$gtRowId) === -1) {
                target.push(source[i]);
            }
        }
        return target;
    };
    /**
     * Toggle meta info for all rows, ie. isSelected, isOpen.
     * @param {?} property - name of property that should be changed/toggled.
     * @param {?} active - should rows be expanded/open, selected.
     * @return {?}
     */
    GenericTableComponent.prototype._toggleAllRowProperty = /**
     * Toggle meta info for all rows, ie. isSelected, isOpen.
     * @param {?} property - name of property that should be changed/toggled.
     * @param {?} active - should rows be expanded/open, selected.
     * @return {?}
     */
    function (property, active) {
        var /** @type {?} */ eventName;
        var /** @type {?} */ eventValue;
        switch (property) {
            case 'isOpen':
                // check if multiple expanded rows are allowed...
                if (this._gtOptions.rowExpandAllowMultiple === false) {
                    // ...if not, exit function
                    console.log('feature disabled: enable by setting "rowExpandAllowMultiple = true"');
                    return;
                }
                if (active) {
                    eventName = 'expand-all';
                    this.openRows = this._gtOptions.lazyLoad
                        ? this._pushLazyRows(this.openRows, this._gtData[this.gtInfo.pageCurrent - 1].slice())
                        : this._gtData.slice();
                    this._updateMetaInfo(this.openRows, property, active);
                }
                else {
                    eventName = 'collapse-all';
                    this._updateMetaInfo(this.openRows, property, active);
                    this.openRows = [];
                }
                eventValue = {
                    expandedRows: this.openRows,
                    changedRow: 'all'
                };
                break;
            case 'isSelected':
                // check if multi row selection is allowed...
                if (this._gtOptions.rowSelectionAllowMultiple === false) {
                    // ...if not, exit function
                    console.log('feature disabled: enable by setting "rowSelectionAllowMultiple = true"');
                    return;
                }
                if (active) {
                    eventName = 'select-all';
                    this.selectedRows = this._gtOptions.lazyLoad
                        ? this._pushLazyRows(this.selectedRows, this._gtData[this.gtInfo.pageCurrent - 1].slice())
                        : this._gtData.slice();
                    this._updateMetaInfo(this.selectedRows, property, active);
                }
                else {
                    eventName = 'deselect-all';
                    this._updateMetaInfo(this.selectedRows, property, active);
                    this.selectedRows = [];
                }
                eventValue = {
                    selectedRows: this.selectedRows,
                    changedRow: 'all'
                };
                break;
        }
        this.gtEvent.emit({
            name: 'gt-row-' + eventName,
            value: eventValue
        });
    };
    /**
     * Toggle meta info for row, ie. isSelected, isOpen.
     * @param {?} row - row object.
     * @param {?} property - name of property that should be changed/toggled.
     * @param {?=} propertyValues - optional property values that can be passed.
     * @return {?}
     */
    GenericTableComponent.prototype._toggleRowProperty = /**
     * Toggle meta info for row, ie. isSelected, isOpen.
     * @param {?} row - row object.
     * @param {?} property - name of property that should be changed/toggled.
     * @param {?=} propertyValues - optional property values that can be passed.
     * @return {?}
     */
    function (row, property, propertyValues) {
        var /** @type {?} */ eventName;
        var /** @type {?} */ eventValue;
        // make sure gtRowId exists on row object
        if (typeof row.$$gtRowId !== 'undefined') {
            // check if meta info exists for row
            if (!this.metaInfo[row.$$gtRowId]) {
                // if not, add object to store meta info
                this.metaInfo[row.$$gtRowId] = {};
            }
            switch (property) {
                case 'isOpen':
                    var /** @type {?} */ opened = this.metaInfo[row.$$gtRowId][property];
                    // check if multiple expanded rows are allowed...
                    if (this._gtOptions.rowExpandAllowMultiple === false) {
                        // ...if not, collapse all rows except current row
                        this._updateMetaInfo(this.openRows, property, false, row);
                        this.openRows = [];
                    }
                    // check if row is expanded
                    if (!opened) {
                        eventName = 'expand';
                        // add row to expanded rows
                        this.openRows.push(row);
                    }
                    else {
                        eventName = 'collapse';
                        // loop through expanded rows...
                        for (var /** @type {?} */ i = 0; i < this.openRows.length; i++) {
                            // if expanded row equals passed row...
                            if (this.openRows[i].$$gtRowId === row.$$gtRowId) {
                                // ...remove row from expanded rows...
                                this.openRows.splice(i, 1);
                                // ...and exit loop
                                break;
                            }
                        }
                    }
                    eventValue = {
                        expandedRows: this.openRows,
                        changedRow: row
                    };
                    break;
                case 'isSelected':
                    var /** @type {?} */ selected = this.metaInfo[row.$$gtRowId][property];
                    // check if multi row selection is allowed...
                    if (this._gtOptions.rowSelectionAllowMultiple === false) {
                        // ...if not, deselect all rows except current row
                        this._updateMetaInfo(this.selectedRows, property, false, row);
                        this.selectedRows = [];
                    }
                    // check if row is selected
                    if (!selected) {
                        eventName = 'select';
                        // add row to selected rows
                        this.selectedRows.push(row);
                    }
                    else {
                        if (this.gtOptions.lazyLoad && this.lazyAllSelected) {
                            this.lazyAllSelected = false;
                        }
                        eventName = 'deselect';
                        // loop through selected rows...
                        for (var /** @type {?} */ i = 0; i < this.selectedRows.length; i++) {
                            // if selected row equals passed row...
                            if (this.selectedRows[i].$$gtRowId === row.$$gtRowId) {
                                // ...remove row from selected rows...
                                this.selectedRows.splice(i, 1);
                                // ...and exit loop
                                break;
                            }
                        }
                    }
                    eventValue = {
                        selectedRows: this.selectedRows,
                        changedRow: row
                    };
                    break;
                case 'isUpdated':
                    eventName = 'updated';
                    var /** @type {?} */ oldValue = propertyValues;
                    // check if edit object exists for row
                    if (typeof this.metaInfo[row.$$gtRowId][property] === 'undefined') {
                        this.metaInfo[row.$$gtRowId][property] = {
                            originalValue: oldValue,
                            oldValue: oldValue,
                            newValue: row
                        };
                    }
                    else {
                        this.metaInfo[row.$$gtRowId][property].oldValue = oldValue;
                        this.metaInfo[row.$$gtRowId][property].newValue = row;
                    }
                    eventValue = this.metaInfo[row.$$gtRowId][property];
                    this.redraw();
                    this.inlineEditCancel(row);
                    // this.gtData = [...this.gtData.map((r) => { return{...r}; })];
                    break;
            }
            this.gtEvent.emit({
                name: 'gt-row-' + eventName,
                value: eventValue
            });
            if (property !== 'isUpdated') {
                this.metaInfo[row.$$gtRowId][property] = !this.metaInfo[row.$$gtRowId][property];
            }
        }
    };
    /**
     * Update column.
     * @param {?} $event - key up event.
     * @param {?} row - row object.
     * @param {?} column - column object.
     * @return {?}
     */
    GenericTableComponent.prototype.gtUpdateColumn = /**
     * Update column.
     * @param {?} $event - key up event.
     * @param {?} row - row object.
     * @param {?} column - column object.
     * @return {?}
     */
    function ($event, row, column) {
        this._editRow(row, column);
    };
    /**
     * Dropdown select.
     * @param {?} row - row object.
     * @param {?} column - column object.
     * @return {?}
     */
    GenericTableComponent.prototype.gtDropdownSelect = /**
     * Dropdown select.
     * @param {?} row - row object.
     * @param {?} column - column object.
     * @return {?}
     */
    function (row, column) {
        var /** @type {?} */ oldValue = tslib_1.__assign({}, row);
        row[column.objectKey] = column.renderValue;
        this.updateRow(row, oldValue);
    };
    /**
     * @param {?} row
     * @param {?} column
     * @return {?}
     */
    GenericTableComponent.prototype._editRow = /**
     * @param {?} row
     * @param {?} column
     * @return {?}
     */
    function (row, column) {
        var /** @type {?} */ OBJECT_KEY = column.objectKey; // declare object key which contains changes
        // check if cell has changed value
        column.edited = row[column.objectKey] !== column.renderValue;
        // check if row contains changes...
        if (!this.editedRows[row.$$gtRowId]) {
            // if not, create an object for the changed row
            this.editedRows[row.$$gtRowId] = {
                changes: {},
                // create placeholder for changes
                row: row // store reference to the row that should be updated
            };
        }
        // store changed column under changes if it has been edited
        if (column.edited) {
            this.editedRows[row.$$gtRowId].changes[OBJECT_KEY] = column;
        }
        else {
            // delete change object if column is unchanged
            delete this.editedRows[row.$$gtRowId].changes[OBJECT_KEY];
            // check how many columns have been changed
            var /** @type {?} */ CHANGED_COLUMNS = Object.keys(this.editedRows[row.$$gtRowId].changes).length;
            if (CHANGED_COLUMNS === 0) {
                // delete row from edited rows if no columns have been edited
                delete this.editedRows[row.$$gtRowId];
            }
        }
        // if no listener is present...
        if (!this.globalInlineEditListener) {
            // ...listen for update event
            this._listenForKeydownEvent();
        }
    };
    /**
     * Listen for key down event - listen for key down event during inline edit.
     * @return {?}
     */
    GenericTableComponent.prototype._listenForKeydownEvent = /**
     * Listen for key down event - listen for key down event during inline edit.
     * @return {?}
     */
    function () {
        var _this = this;
        // add global listener for key down events
        this.globalInlineEditListener = this.renderer.listen('document', 'keydown', function ($event) {
            switch ($event.key) {
                case 'Enter':
                    // update data object
                    _this.inlineEditUpdate();
                    break;
                case 'Escape':
                    // cancel
                    _this.inlineEditCancel();
                    break;
            }
        });
    };
    /**
     * Inline edit update - accept changes and update row values.
     * @return {?}
     */
    GenericTableComponent.prototype.inlineEditUpdate = /**
     * Inline edit update - accept changes and update row values.
     * @return {?}
     */
    function () {
        var _this = this;
        // loop through rows that have been edited
        Object.keys(this.editedRows).map(function (key) {
            var /** @type {?} */ ROW = _this.editedRows[key].row; // row to update
            var /** @type {?} */ CHANGES = _this.editedRows[key].changes; // changes to the row
            // loop through changes in row
            Object.keys(CHANGES).map(function (objectKey) {
                var /** @type {?} */ oldValue = tslib_1.__assign({}, ROW);
                ROW[objectKey] = CHANGES[objectKey].renderValue; // update data value
                _this.updateRow(ROW, oldValue); // update meta info for row and send event
                CHANGES[objectKey].edited = false; // disable edit mode
            });
        });
        // clear rows marked as edited as the rows have been updated
        this.editedRows = {};
        // remove listener
        this._stopListeningForKeydownEvent();
    };
    /**
     * Inline edit cancel - cancel and reset inline edits.
     * @param {?=} row
     * @return {?}
     */
    GenericTableComponent.prototype.inlineEditCancel = /**
     * Inline edit cancel - cancel and reset inline edits.
     * @param {?=} row
     * @return {?}
     */
    function (row) {
        var _this = this;
        if (row) {
            delete this.editedRows[row.$$gtRowId];
            // remove listener
            this._stopListeningForKeydownEvent();
            return;
        }
        // loop through rows that have been edited
        Object.keys(this.editedRows).map(function (key) {
            var /** @type {?} */ ROW = _this.editedRows[key].row; // row to update
            var /** @type {?} */ CHANGES = _this.editedRows[key].changes; // changes to the row
            // loop through changes in row
            Object.keys(CHANGES).map(function (objectKey) {
                CHANGES[objectKey].renderValue = ROW[objectKey]; // reset rendered value
                CHANGES[objectKey].edited = false; // disable edit mode
            });
        });
        // clear rows marked as edited as the rows have been updated
        this.editedRows = {};
        // remove listener
        this._stopListeningForKeydownEvent();
    };
    /**
     * Stop listening for key down event - stop listening for key down events passed during inline edit.
     * @return {?}
     */
    GenericTableComponent.prototype._stopListeningForKeydownEvent = /**
     * Stop listening for key down event - stop listening for key down events passed during inline edit.
     * @return {?}
     */
    function () {
        if (this.globalInlineEditListener) {
            this.globalInlineEditListener();
            this.globalInlineEditListener = null;
        }
    };
    /**
     * Apply filter(s).
     * @param {?} filter - object containing key value pairs, where value should be array of values.
     * @return {?}
     */
    GenericTableComponent.prototype.gtApplyFilter = /**
     * Apply filter(s).
     * @param {?} filter - object containing key value pairs, where value should be array of values.
     * @return {?}
     */
    function (filter) {
        this.gtInfo.filter = filter;
        // go to first page
        this.goToPage(1);
        this.updateTotals();
    };
    /**
     * Clear/remove applied filter(s).
     * @return {?}
     */
    GenericTableComponent.prototype.gtClearFilter = /**
     * Clear/remove applied filter(s).
     * @return {?}
     */
    function () {
        this.gtInfo.filter = false;
        this.updateTotals();
        // this.updateRecordRange();
    };
    /**
     * Search
     * @param {?} value - string containing one or more words
     * @return {?}
     */
    GenericTableComponent.prototype.gtSearch = /**
     * Search
     * @param {?} value - string containing one or more words
     * @return {?}
     */
    function (value) {
        this.gtInfo.searchTerms = value;
        // always go to first page when searching
        this.goToPage(1);
        this.updateTotals();
    };
    /**
     * Add rows
     * @param {?} rows - rows to add
     * @return {?} new data array.
     */
    GenericTableComponent.prototype.gtAdd = /**
     * Add rows
     * @param {?} rows - rows to add
     * @return {?} new data array.
     */
    function (rows) {
        this.gtData = tslib_1.__spread(this.gtData, rows);
        return tslib_1.__spread(this.gtData);
    };
    /**
     * Delete row
     * @param {?} objectKey - object key you want to find match with
     * @param {?} value - the value that should be deleted
     * @param {?=} match - all: delete all matches, first: delete first match (default)
     * @return {?} new data array.
     */
    GenericTableComponent.prototype.gtDelete = /**
     * Delete row
     * @param {?} objectKey - object key you want to find match with
     * @param {?} value - the value that should be deleted
     * @param {?=} match - all: delete all matches, first: delete first match (default)
     * @return {?} new data array.
     */
    function (objectKey, value, match) {
        if (match === void 0) { match = 'first'; }
        if (match === 'first') {
            for (var /** @type {?} */ i = 0; i < this.gtData.length; i++) {
                if (this.gtData[i][objectKey] === value) {
                    if (this.isRowSelected(this.gtData[i])) {
                        this.toggleSelect(this.gtData[i]);
                    }
                    this.gtData.splice(i, 1);
                    this.gtData = tslib_1.__spread(this.gtData);
                    if (match === 'first') {
                        break;
                    }
                }
            }
        }
        else {
            for (var /** @type {?} */ i = this.gtData.length; i > 0; i--) {
                if (this.gtData[i - 1][objectKey] === value) {
                    if (this.isRowSelected(this.gtData[i - 1])) {
                        this.toggleSelect(this.gtData[i - 1]);
                    }
                    this.gtData.splice(i - 1, 1);
                    this.gtData = tslib_1.__spread(this.gtData);
                }
            }
        }
        return tslib_1.__spread(this.gtData);
    };
    /**
     * Create store to hold previously loaded records.
     * @param {?} records - total number of records in store.
     * @param {?} perPage - how many records to show per page.
     * @return {?} a nested array to hold records per page.
     */
    GenericTableComponent.prototype.createStore = /**
     * Create store to hold previously loaded records.
     * @param {?} records - total number of records in store.
     * @param {?} perPage - how many records to show per page.
     * @return {?} a nested array to hold records per page.
     */
    function (records, perPage) {
        var /** @type {?} */ stores = Math.ceil(records / perPage);
        var /** @type {?} */ store = [];
        for (var /** @type {?} */ i = 0; i < stores; i++) {
            store[i] = [];
        }
        return store;
    };
    /**
     * Create placeholders for rows while loading data from back-end.
     * @param {?} perPage - how many records to show per page.
     * @return {?} an array containing empty records to be presented while fetching real data.
     */
    GenericTableComponent.prototype.loadingContent = /**
     * Create placeholders for rows while loading data from back-end.
     * @param {?} perPage - how many records to show per page.
     * @return {?} an array containing empty records to be presented while fetching real data.
     */
    function (perPage) {
        // create row object
        var /** @type {?} */ rowObject = {
            $$loading: true
        };
        var /** @type {?} */ order = 0;
        // sort settings by column order
        this._gtSettings.sort(this.getColumnOrder);
        // loop through all settings objects...
        for (var /** @type {?} */ i = 0; i < this._gtSettings.length; i++) {
            var /** @type {?} */ setting = this._gtSettings[i];
            // ...if column is visible and enabled...
            if (setting.visible !== false && setting.enabled !== false) {
                // ...if first column, set value to loading text otherwise leave it empty
                if (order === 0) {
                    rowObject[setting.objectKey] = this.gtTexts.loading;
                    this.loadingProperty = setting.objectKey;
                }
                else {
                    rowObject[setting.objectKey] = '';
                }
                order++;
            }
            else {
                rowObject[setting.objectKey] = '';
            }
        }
        // create content placeholder
        var /** @type {?} */ contentPlaceholder = [];
        // create equal number of rows as rows per page
        for (var /** @type {?} */ i = 0; i < perPage; i++) {
            // ...add temporary row object
            contentPlaceholder.push(rowObject);
        }
        return contentPlaceholder;
    };
    /**
     * Export data as CSV
     * @param {?=} fileName - optional file name (overrides default file name).
     * @param {?=} useBOM - use BOM (byte order marker).
     * @return {?}
     */
    GenericTableComponent.prototype.exportCSV = /**
     * Export data as CSV
     * @param {?=} fileName - optional file name (overrides default file name).
     * @param {?=} useBOM - use BOM (byte order marker).
     * @return {?}
     */
    function (fileName, useBOM) {
        var _this = this;
        if (useBOM === void 0) { useBOM = false; }
        var /** @type {?} */ data = this.data.exportData;
        var /** @type {?} */ csv = '';
        var /** @type {?} */ BOM = '\uFEFF';
        // csv export headers
        for (var /** @type {?} */ i = 0; i < this._gtSettings.length; i++) {
            if (this._gtSettings[i].export !== false) {
                // get field settings
                var /** @type {?} */ fieldSetting = this.getProperty(this._gtFields, this._gtSettings[i].objectKey);
                // get export value, if exportHeader string is defined use it otherwise returns name
                var /** @type {?} */ exportValue = fieldSetting.exportHeader
                    ? fieldSetting.exportHeader
                    : fieldSetting.name;
                csv += this.escapeCSVDelimiter(exportValue);
                csv += this.getProperty(this._gtFields, this._gtSettings[i].objectKey)
                    .name;
                if (i < this._gtSettings.length - 1) {
                    csv += this._gtOptions.csvDelimiter;
                }
            }
        }
        // csv export body
        data.forEach(function (row) {
            csv += '\n';
            for (var /** @type {?} */ i = 0; i < _this._gtSettings.length; i++) {
                if (_this._gtSettings[i].export !== false) {
                    // get field settings
                    var /** @type {?} */ fieldSetting = _this.getProperty(_this._gtFields, _this._gtSettings[i].objectKey);
                    // get export value, if export function is defined use it otherwise check for value function and as a last resort export raw data
                    var /** @type {?} */ exportValue = fieldSetting.export && typeof fieldSetting.export === 'function'
                        ? fieldSetting.export(row)
                        : fieldSetting.value && typeof fieldSetting.value === 'function'
                            ? fieldSetting.value(row)
                            : row[_this._gtSettings[i].objectKey];
                    csv += _this.escapeCSVDelimiter(exportValue);
                    if (i < _this._gtSettings.length - 1) {
                        csv += _this._gtOptions.csvDelimiter;
                    }
                }
            }
        });
        var /** @type {?} */ blob = new Blob([(useBOM ? BOM : '') + csv], {
            type: 'text/csv;charset=utf-8'
        });
        if (window.navigator.msSaveOrOpenBlob) {
            navigator.msSaveOrOpenBlob(blob, fileName ? fileName + '.csv' : this.gtTexts.csvDownload + '.csv');
        }
        else {
            var /** @type {?} */ link = document.createElement('a');
            link.style.display = 'none';
            document.body.appendChild(link);
            if (link.download !== undefined) {
                link.setAttribute('href', 'data:text/csv;charset=utf-8,' +
                    encodeURIComponent((useBOM ? BOM : '') + csv)); // URL.createObjectURL(blob));
                link.setAttribute('download', fileName ? fileName + '.csv' : this.gtTexts.csvDownload + '.csv');
                document.body.appendChild(link);
                link.click();
            }
            else {
                csv = 'data:text/csv;charset=utf-8,' + (useBOM ? BOM : '') + csv;
                window.open(encodeURIComponent(csv));
            }
            document.body.removeChild(link);
        }
        // emit export event
        this.gtEvent.emit({
            name: 'gt-exported-csv',
            value: fileName ? fileName : this.gtTexts.csvDownload + '.csv'
        });
    };
    /**
     * Escape export value using double quotes (") if export value contains delimiter
     * @param {?} value Value to be escaped
     * @return {?}
     */
    GenericTableComponent.prototype.escapeCSVDelimiter = /**
     * Escape export value using double quotes (") if export value contains delimiter
     * @param {?} value Value to be escaped
     * @return {?}
     */
    function (value) {
        return typeof value === 'string' &&
            value.indexOf(this._gtOptions.csvDelimiter) !== -1
            ? '"' + value + '"'
            : value;
    };
    /**
     * @return {?}
     */
    GenericTableComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        // if number of row to display from start is set to null or 0...
        if (!this.gtOptions.numberOfRows) {
            // ...change row length
            this.changeRowLength(this.gtOptions.numberOfRows);
        }
        this.restructureSorting();
    };
    /**
     * @param {?} changes
     * @return {?}
     */
    GenericTableComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        // if gt texts have changed...
        if (changes['gtTexts']) {
            // ...extend gtOptions default values with values passed into component
            this.gtTexts = /** @type {?} */ (this.extend(this.gtDefaultTexts, this.gtTexts));
        }
        // if lazy loading data and paging information is available...
        if (this.gtOptions.lazyLoad && this.gtInfo) {
            // ...calculate total number of pages
            this.gtInfo.pageTotal = Math.ceil(this.gtInfo.recordsAfterSearch / this.gtInfo.recordLength);
            // ...declare store position
            var /** @type {?} */ storePosition = this.gtInfo.pageCurrent - 1;
            // ...and if store is empty or page length has changed...
            if (this.store.length === 0 ||
                this.store[0].length !== this.gtInfo.recordLength) {
                // ...create store
                this.store = this.createStore(this.gtInfo.recordsAfterSearch, this.gtInfo.recordLength);
            }
            // ...store retrieved data in store at store position
            this.store[storePosition] = this.gtData;
            this.gtInfo.visibleRecords = tslib_1.__spread(this.gtData); // add visible rows
            // replace data with store
            this._gtData = this.store;
            this.loading = false;
            this.updateRecordRange();
            this.gtEvent.emit({
                name: 'gt-info',
                value: this.gtInfo
            });
        }
        else if (this._gtData &&
            this._gtData.length >= 0 &&
            changes['gtData'] &&
            changes['gtData'].previousValue) {
            this.loading = false;
        }
        else if (changes['gtData'] &&
            changes['gtData'].firstChange &&
            this._gtData &&
            this._gtData.length > 0) {
            this.loading = false;
        }
    };
    /**
     * @param {?} index
     * @param {?} item
     * @return {?}
     */
    GenericTableComponent.prototype.trackByFn = /**
     * @param {?} index
     * @param {?} item
     * @return {?}
     */
    function (index, item) {
        return item.$$gtRowId;
    };
    /**
     * @param {?} index
     * @param {?} item
     * @return {?}
     */
    GenericTableComponent.prototype.trackByColumnFn = /**
     * @param {?} index
     * @param {?} item
     * @return {?}
     */
    function (index, item) {
        return item.objectKey;
    };
    /**
     * @return {?}
     */
    GenericTableComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        // remove listener
        this._stopListeningForKeydownEvent();
    };
    GenericTableComponent.decorators = [
        { type: Component, args: [{
                    selector: 'generic-table',
                    template: "<table class=\"table\" ngClass=\"{{gtClasses}} {{gtOptions.stack ? 'table-stacked':''}}\"\n       *ngIf=\"gtFields && gtSettings && (gtFields | gtVisible:gtSettings:refreshPipe).length > 0\">\n  <thead>\n  <tr>\n    <th class=\"gt-sort-label\" *ngIf=\"gtOptions.stack\">{{gtTexts.sortLabel}}</th>\n    <th *ngFor=\"let column of gtSettings | gtVisible:gtSettings:refreshPipe\"\n        ngClass=\"{{column.objectKey +'-column' | dashCase}} {{gtFields | gtProperty:column.objectKey:'classNames'}} {{column.sortEnabled ? 'sort-'+column.sort:''}} {{column.sortEnabled && column.sortOrder >= 0  ? 'sort-order-'+column.sortOrder:''}} {{ gtFields | gtColumnClass:column }}\"\n        (click)=\"column.sortEnabled ? gtSort(column.objectKey,$event):'';\">\n      <span *ngIf=\"!(gtFields | gtProperty:column.objectKey:'header')\">{{gtFields | gtProperty:column.objectKey:'name'}}</span>\n      <gt-custom-component-factory *ngIf=\"(gtFields | gtProperty:column.objectKey:'header')\"\n                                   [type]=\"(gtFields | gtProperty:column.objectKey:'header')?.type\"\n                                   [injector]=\"(gtFields | gtProperty:column.objectKey:'header')?.injector\"\n                                   [column]=\"gtFields | gtProperty:column.objectKey:'name'\"></gt-custom-component-factory>\n      <gt-checkbox *ngIf=\"(gtFields | gtProperty:column.objectKey:'columnComponent')?.type === 'checkbox'\" [checked]=\"(gtOptions.lazyLoad ? lazyAllSelected:selectedRows.length === gtData.length)\" (changed)=\"toggleAllRows()\"></gt-checkbox>\n    </th>\n  </tr>\n  </thead>\n  <ng-template\n    [ngIf]=\"gtTotals && (gtOptions.lazyLoad === false ? (gtData | gtFilter:gtInfo.filter:gtInfo:refreshFilter:gtData.length | gtSearch:gtInfo.searchTerms:gtInfo:gtSettings:gtFields:gtData.length).length > 0 : gtData.length > 0)\">\n    <thead class=\"gt-totals\">\n    <tr *ngFor=\"let total of gtTotals | gtTotalsPosition\">\n      <td *ngFor=\"let column of gtSettings | gtVisible:gtSettings:refreshPipe;let i = index;\"\n          ngClass=\"{{column.objectKey +'-totals-column' | dashCase}} {{gtFields | gtProperty:column.objectKey:'classNames'}} {{ gtFields | gtColumnClass:column }}\">\n        <span *ngIf=\"i === 0\" class=\"float-left\">{{total.name}}</span><span\n        [innerHTML]=\"total.fields[column.objectKey] | gtTotals:(total.update === false || gtOptions.lazyLoad === true) ? gtData:(gtData | gtFilter:gtInfo.filter:gtInfo:refreshFilter:gtData.length | gtSearch:gtInfo.searchTerms:gtInfo:gtSettings:gtFields:gtData.length):column.objectKey:refreshTotals\"></span>\n      </td>\n    </tr>\n    </thead>\n    <tfoot class=\"gt-totals\">\n    <tr *ngFor=\"let total of gtTotals | gtTotalsPosition:'footer'\">\n      <td *ngFor=\"let column of gtSettings | gtVisible:gtSettings:refreshPipe;let i = index;\"\n          ngClass=\"{{column.objectKey +'-totals-column' | dashCase}} {{gtFields | gtProperty:column.objectKey:'classNames'}} {{ gtFields | gtColumnClass:column }}\">\n        <span *ngIf=\"i === 0\" class=\"float-left\">{{total.name}}</span><span\n        [innerHTML]=\"total.fields[column.objectKey] | gtTotals:(total.update === false || gtOptions.lazyLoad === true) ? gtData:(gtData | gtFilter:gtInfo.filter:gtInfo:refreshFilter:gtData.length | gtSearch:gtInfo.searchTerms:gtInfo:gtSettings:gtFields:gtData.length):column.objectKey:refreshTotals\"></span>\n      </td>\n    </tr>\n    </tfoot>\n  </ng-template>\n  <tbody *ngIf=\"gtData && gtInfo\">\n  <ng-template class=\"table-rows\" ngFor let-row let-last=\"last\" [ngForTrackBy]=\"trackByFn\"\n               [ngForOf]=\"gtOptions.lazyLoad && gtInfo ? (gtData[gtInfo.pageCurrent-1]) : (gtData | gtFilter:gtInfo.filter:gtInfo:refreshFilter:gtData.length | gtSearch:gtInfo.searchTerms:gtInfo:gtSettings:gtFields:gtData.length | gtOrderBy:sortOrder:gtFields:refreshSorting:gtData.length | gtChunk:gtInfo:gtInfo.recordLength:gtInfo.pageCurrent:refreshPageArray:gtData.length:gtEvent:data | gtRowClass:gtFields)\">\n    <tr [ngClass]=\"{'row-selected':metaInfo[row.$$gtRowId]?.isSelected, 'row-open':metaInfo[row.$$gtRowId]?.isOpen, 'row-loading':loading, 'row-expandable':gtRowComponent}\"\n        class=\"{{row.$$gtRowClass}}\"\n        (click)=\"gtOptions.rowSelection ? toggleSelect(row):rowClick(row, $event)\">\n      <td *ngFor=\"let column of row | gtRender:gtSettings:gtFields:refreshPipe:loading:gtOptions.highlightSearch:gtInfo.searchTerms;trackBy:trackByColumnFn\"\n          ngClass=\"{{column.objectKey +'-column' | dashCase}} {{gtFields | gtProperty:column.objectKey:'classNames'}} {{(gtFields | gtProperty:column.objectKey:'inlineEdit') ? 'gt-inline-edit':''}} {{column.edited ? 'gt-edited':''}} {{ gtFields | gtColumnClass:column:row }}\">\n                        <span class=\"gt-row-label\"\n                              *ngIf=\"gtOptions.stack\">{{(gtFields | gtProperty:column.objectKey:'stackedHeading') ? (gtFields | gtProperty:column.objectKey:'stackedHeading') : (gtFields | gtProperty:column.objectKey:'name')}}</span>\n        <gt-custom-component-factory *ngIf=\"column.columnComponent && column.columnComponent.type !== 'checkbox'\" class=\"gt-row-content\"\n                                     [type]=\"column.columnComponent.type\"\n                                     [injector]=\"column.columnComponent.injector\" [row]=\"row\"\n                                     [column]=\"column\" (redrawEvent)=\"redraw($event)\"\n                                     [searchTerms]=\"gtInfo.searchTerms\"  (searchEvent)=\"redraw($event)\"\n                                     (click)=\"column.click ? column.click(row,column,$event):'';column.expand ? toggleCollapse(row, column.expand):''\"></gt-custom-component-factory>\n        <span *ngIf=\"!column.columnComponent && (!(gtFields | gtProperty:column.objectKey:'inlineEdit') || ((gtFields | gtProperty:column.objectKey:'inlineEdit')?.active | gtIsObservable) && !((gtFields | gtProperty:column.objectKey:'inlineEdit')?.active | async) || (!((gtFields | gtProperty:column.objectKey:'inlineEdit')?.active | gtIsObservable) && !((gtFields | gtProperty:column.objectKey:'inlineEdit')?.active | gtIsEditable:row:refreshPipe)))\"\n              class=\"gt-row-content\" [innerHTML]=\"column.renderValue\"\n              (click)=\"column.click ? column.click(row,column,$event):'';column.expand ? toggleCollapse(row, column.expand):''\"></span>\n        <ng-template\n          [ngIf]=\"!column.columnComponent && (((gtFields | gtProperty:column.objectKey:'inlineEdit')?.active | gtIsObservable) && ((gtFields | gtProperty:column.objectKey:'inlineEdit')?.active | async) || ((gtFields | gtProperty:column.objectKey:'inlineEdit')?.active | gtIsEditable:row:refreshPipe))\">\n          <ng-template [ngIf]=\"([true,'email','number','password', 'text'].indexOf((gtFields | gtProperty:column.objectKey:'inlineEdit').type) !== -1) || !(gtFields | gtProperty:column.objectKey:'inlineEdit').type\">\n            <input class=\"inline-edit\" [attr.type]=\"!(gtFields | gtProperty:column.objectKey:'inlineEdit').type ? 'text' : !((gtFields | gtProperty:column.objectKey:'inlineEdit').type | gtIsObservable) ? (gtFields | gtProperty:column.objectKey:'inlineEdit').type:(gtFields | gtProperty:column.objectKey:'inlineEdit').type | async\" [(ngModel)]=\"column.renderValue\"\n                   (input)=\"gtUpdateColumn($event,row, column)\">\n            <span class=\"gt-inline-edit-notice\">{{gtTexts.inlineEditEdited}}</span>\n          </ng-template>\n          <gt-dropdown\n            *ngIf=\"(((gtFields | gtProperty:column.objectKey:'inlineEdit').type) && ((gtFields | gtProperty:column.objectKey:'inlineEdit').type).length > 0) || ((gtFields | gtProperty:column.objectKey:'inlineEdit').type | gtIsObservable)\"\n            [options]=\"!((gtFields | gtProperty:column.objectKey:'inlineEdit').type | gtIsObservable) ? (gtFields | gtProperty:column.objectKey:'inlineEdit').type : (gtFields | gtProperty:column.objectKey:'inlineEdit').type | async\"\n            [id]=\"'_' + row.$$gtRowId + '_' + column.objectKey\"\n            [(selected)]=\"column.renderValue\" (selectedChange)=\"gtDropdownSelect(row, column)\">Add\n            inline editing module\n          </gt-dropdown>\n        </ng-template>\n        <ng-template [ngIf]=\"!column.columnComponent && !((gtFields | gtProperty:column.objectKey:'inlineEdit')?.active) \">\n          <ng-template\n            [ngIf]=\"[true,'email','number','password'].indexOf(gtFields | gtProperty:column.objectKey:'inlineEdit') !== -1\">\n            <input class=\"inline-edit\" [attr.type]=\"(gtFields | gtProperty:column.objectKey:'inlineEdit') === true ? 'text':(gtFields | gtProperty:column.objectKey:'inlineEdit')\" [(ngModel)]=\"column.renderValue\"\n                   (input)=\"gtUpdateColumn($event,row, column)\">\n            <span class=\"gt-inline-edit-notice\">{{gtTexts.inlineEditEdited}}</span>\n          </ng-template>\n          <gt-dropdown\n            *ngIf=\"(gtFields | gtProperty:column.objectKey:'inlineEdit') && [true,'email','number','password'].indexOf(gtFields | gtProperty:column.objectKey:'inlineEdit') === -1\"\n            [options]=\"gtFields | gtProperty:column.objectKey:'inlineEdit'\"\n            [id]=\"'_' + row.$$gtRowId + '_' + column.objectKey\"\n            [(selected)]=\"column.renderValue\" (selectedChange)=\"gtDropdownSelect(row, column)\">Add\n            inline editing module\n          </gt-dropdown>\n        </ng-template>\n        <gt-checkbox *ngIf=\"column.columnComponent && column.columnComponent.type === 'checkbox'\" [checked]=\"metaInfo[row.$$gtRowId]?.isSelected\" (changed)=\"toggleSelect(row)\"></gt-checkbox>\n      </td>\n    </tr>\n    <tr class=\"row-expanded\" *ngIf=\"metaInfo[row.$$gtRowId]?.isOpen\">\n      <td [attr.colspan]=\"(gtFields | gtVisible:gtSettings:refreshPipe).length\">\n        <gt-expanding-row [row]=\"row\"\n                          [type]=\"expandedRow.component ? expandedRow.component:gtRowComponent\"\n                          [columnWidth]=\"columnWidth\"\n                          [gtFields]=\"gtFields\"\n                          [gtOptions]=\"gtOptions\"\n                          [gtEvent]=\"gtEvent\"\n                          [gtInfo]=\"gtInfo\"\n                          [gtSettings]=\"gtSettings\"\n                          [data]=\"expandedRow.data ? expandedRow.data:row\"\n                          (redrawEvent)=\"redraw($event)\"\n                          (toggleRowEvent)=\"toggleCollapse($event)\"></gt-expanding-row>\n      </td>\n    </tr>\n    <tr *ngIf=\"gtOptions.reportColumnWidth && last\">\n      <td style=\"padding: 0; border:none;\"\n          *ngFor=\"let column of gtSettings | gtVisible:gtSettings:refreshPipe\" gtColumnWidth\n          [objectKey]=\"column.objectKey\" [widths]=\"columnWidth\"></td>\n    </tr>\n  </ng-template>\n  <tr *ngIf=\"gtInfo.pageTotal === 0 && (gtInfo.searchTerms || gtInfo.filter) && !loading\">\n    <td class=\"gt-no-matching-results\" [attr.colspan]=\"(gtFields | gtVisible:gtSettings).length\">\n      {{gtTexts.noMatchingData}}\n    </td>\n  </tr>\n  <tr *ngIf=\"gtInfo.pageTotal === 0 && !(gtInfo.searchTerms || gtInfo.filter) && !loading\">\n    <td class=\"gt-no-results\" [attr.colspan]=\"(gtFields | gtVisible:gtSettings).length\">{{gtTexts.noData}}\n    </td>\n  </tr>\n  <tr *ngIf=\"gtInfo.pageTotal === 0 && loading\">\n    <td class=\"gt-loading-data\" [attr.colspan]=\"(gtFields | gtVisible:gtSettings).length\">{{gtTexts.loading}}</td>\n  </tr>\n  </tbody>\n</table>\n<table class=\"table\" ngClass=\"{{gtClasses}} {{gtOptions.stack ? 'table-stacked':''}}\"\n       *ngIf=\"gtFields && gtSettings && (gtFields | gtVisible:gtSettings:refreshPipe).length === 0\">\n  <thead>\n  <tr>\n    <th class=\"gt-no-visible-columns\">{{gtTexts.noVisibleColumnsHeading}}</th>\n  </tr>\n  </thead>\n  <tbody>\n  <tr>\n    <td class=\"gt-no-visible-columns\">{{gtTexts.noVisibleColumns}}</td>\n  </tr>\n  </tbody>\n</table>\n<table class=\"table\" ngClass=\"{{gtClasses}} {{gtOptions.stack ? 'table-stacked':''}}\"\n       *ngIf=\"!gtFields || !gtSettings\">\n  <thead>\n  <tr>\n    <th class=\"gt-loading-config\">&nbsp;</th>\n  </tr>\n  </thead>\n  <tbody>\n  <tr>\n    <td class=\"gt-loading-config\">&nbsp;</td>\n  </tr>\n  </tbody>\n</table>\n"
                },] },
    ];
    /** @nocollapse */
    GenericTableComponent.ctorParameters = function () { return [
        { type: Renderer2, },
        { type: GtMetaPipe, },
    ]; };
    GenericTableComponent.propDecorators = {
        "gtOptions": [{ type: Input },],
        "gtTotals": [{ type: Input },],
        "gtFields": [{ type: Input },],
        "gtSettings": [{ type: Input },],
        "gtData": [{ type: Input },],
        "gtRowComponent": [{ type: Input },],
        "gtTexts": [{ type: Input },],
        "gtClasses": [{ type: Input },],
        "gtEvent": [{ type: Output },],
        "gtInfo": [{ type: Input },],
    };
    return GenericTableComponent;
}());
export { GenericTableComponent };
function GenericTableComponent_tsickle_Closure_declarations() {
    /** @type {!Array<{type: !Function, args: (undefined|!Array<?>)}>} */
    GenericTableComponent.decorators;
    /**
     * @nocollapse
     * @type {function(): !Array<(null|{type: ?, decorators: (undefined|!Array<{type: !Function, args: (undefined|!Array<?>)}>)})>}
     */
    GenericTableComponent.ctorParameters;
    /** @type {!Object<string,!Array<{type: !Function, args: (undefined|!Array<?>)}>>} */
    GenericTableComponent.propDecorators;
    /** @type {?} */
    GenericTableComponent.prototype.columnWidth;
    /** @type {?} */
    GenericTableComponent.prototype.configObject;
    /** @type {?} */
    GenericTableComponent.prototype.sortOrder;
    /** @type {?} */
    GenericTableComponent.prototype.metaInfo;
    /** @type {?} */
    GenericTableComponent.prototype.selectedRows;
    /** @type {?} */
    GenericTableComponent.prototype.openRows;
    /** @type {?} */
    GenericTableComponent.prototype._gtSettings;
    /** @type {?} */
    GenericTableComponent.prototype._gtFields;
    /** @type {?} */
    GenericTableComponent.prototype._gtData;
    /** @type {?} */
    GenericTableComponent.prototype._gtTotals;
    /** @type {?} */
    GenericTableComponent.prototype._gtRowComponent;
    /** @type {?} */
    GenericTableComponent.prototype.expandedRow;
    /** @type {?} */
    GenericTableComponent.prototype.gtDefaultTexts;
    /** @type {?} */
    GenericTableComponent.prototype.gtTexts;
    /** @type {?} */
    GenericTableComponent.prototype.gtClasses;
    /** @type {?} */
    GenericTableComponent.prototype.gtEvent;
    /** @type {?} */
    GenericTableComponent.prototype.gtDefaultOptions;
    /** @type {?} */
    GenericTableComponent.prototype._gtOptions;
    /** @type {?} */
    GenericTableComponent.prototype.store;
    /** @type {?} */
    GenericTableComponent.prototype.loading;
    /** @type {?} */
    GenericTableComponent.prototype.debounceTimer;
    /** @type {?} */
    GenericTableComponent.prototype.loadingProperty;
    /** @type {?} */
    GenericTableComponent.prototype.lazyAllSelected;
    /** @type {?} */
    GenericTableComponent.prototype.gtInfo;
    /** @type {?} */
    GenericTableComponent.prototype.refreshPipe;
    /** @type {?} */
    GenericTableComponent.prototype.refreshTotals;
    /** @type {?} */
    GenericTableComponent.prototype.refreshSorting;
    /** @type {?} */
    GenericTableComponent.prototype.refreshFilter;
    /** @type {?} */
    GenericTableComponent.prototype.refreshPageArray;
    /** @type {?} */
    GenericTableComponent.prototype.globalInlineEditListener;
    /** @type {?} */
    GenericTableComponent.prototype.editedRows;
    /** @type {?} */
    GenericTableComponent.prototype.data;
    /**
     * Sort table by object key.
     * \@param objectKey - name of key to sort on.
     * \@param event - such as key press during sorting.
     * @type {?}
     */
    GenericTableComponent.prototype.gtSort;
    /**
     * Change number of rows to be displayed.
     * \@param rowLength - total number of rows.
     * \@param reset - should page be reset to first page.
     * @type {?}
     */
    GenericTableComponent.prototype.changeRowLength;
    /**
     * Force a redraw of table rows.
     * As the table uses pure pipes, we need to force a redraw if an object in the array is changed to see the changes.
     * @type {?}
     */
    GenericTableComponent.prototype.redraw;
    /**
     * Go to next page.
     * @type {?}
     */
    GenericTableComponent.prototype.nextPage;
    /**
     * Go to previous page.
     * @type {?}
     */
    GenericTableComponent.prototype.previousPage;
    /**
     * Request more data (used when lazy loading)
     * @type {?}
     */
    GenericTableComponent.prototype.getData;
    /**
     * Go to specific page.
     * \@param page - page number.
     * @type {?}
     */
    GenericTableComponent.prototype.goToPage;
    /**
     * Sort by sort order
     * @type {?}
     */
    GenericTableComponent.prototype.getSortOrder;
    /**
     * Sort by column order
     * @type {?}
     */
    GenericTableComponent.prototype.getColumnOrder;
    /**
     * Create a deep copy of data
     * @type {?}
     */
    GenericTableComponent.prototype.cloneDeep;
    /**
     * Return property
     * @type {?}
     */
    GenericTableComponent.prototype.getProperty;
    /** @type {?} */
    GenericTableComponent.prototype.restructureSorting;
    /**
     *  Extend object function.
     * @type {?}
     */
    GenericTableComponent.prototype.extend;
    /** @type {?} */
    GenericTableComponent.prototype.renderer;
    /** @type {?} */
    GenericTableComponent.prototype.gtMetaPipe;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2VuZXJpYy10YWJsZS5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AYW5ndWxhci1nZW5lcmljLXRhYmxlL2NvcmUvIiwic291cmNlcyI6WyJjb21wb25lbnRzL2dlbmVyaWMtdGFibGUuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQUEsT0FBTyxFQUNOLFNBQVMsRUFDVCxZQUFZLEVBQ1osS0FBSyxFQUlMLE1BQU0sRUFDTixTQUFTLEVBRVQsSUFBSSxFQUNKLE1BQU0sZUFBZSxDQUFDO0FBY3ZCLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSx1QkFBdUIsQ0FBQzs7Ozs7OztJQXdhbEQsK0JBQW9CLFFBQW1CLEVBQVUsVUFBc0I7UUFBdkUsaUJBU0M7UUFUbUIsYUFBUSxHQUFSLFFBQVEsQ0FBVztRQUFVLGVBQVUsR0FBVixVQUFVLENBQVk7MkJBbkYxQyxFQUFFO3lCQUVBLEVBQUU7d0JBQ21CLEVBQUU7NEJBQ2xCLEVBQUU7d0JBQ04sRUFBRTsyQkFDTyxFQUFFO3lCQUNFLEVBQUU7OEJBUWQ7WUFDaEMsT0FBTyxFQUFFLFlBQVk7WUFDckIsTUFBTSxFQUFFLFNBQVM7WUFDakIsY0FBYyxFQUFFLGdDQUFnQztZQUNoRCx1QkFBdUIsRUFBRSxvQkFBb0I7WUFDN0MsZ0JBQWdCLEVBQUUsa0RBQWtEO1lBQ3BFLFNBQVMsRUFDUixrRUFBa0U7WUFDbkUsb0JBQW9CLEVBQ25CLGtIQUFrSDtZQUNuSCxXQUFXLEVBQUUsVUFBVTtZQUN2QixTQUFTLEVBQUUsT0FBTztZQUNsQixZQUFZLEVBQUUsV0FBVztZQUN6QixnQkFBZ0IsRUFBRSxlQUFlO1lBQ2pDLGdCQUFnQixFQUFFLHFCQUFxQjtTQUN2Qzt1QkFDMkIsSUFBSSxDQUFDLGNBQWM7dUJBRUosSUFBSSxZQUFZLEVBQUU7Z0NBQ3hCO1lBQ3BDLFlBQVksRUFBRSxHQUFHO1lBQ2pCLEtBQUssRUFBRSxLQUFLO1lBQ1osUUFBUSxFQUFFLEtBQUs7WUFDZixLQUFL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QkFLTCxLQUFLOytCQWVMLEtBQUs7MkJBMENMLEtBQUs7bUNBK0RMLEtBQUs7NEJBdUNMLEtBQUs7OEJBQ0wsS0FBSzs0QkFDTCxNQUFNOzJCQXVCTixLQUFLOztnQ0F0YVA7O1NBc0xhLHFCQUFxQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG5cdENvbXBvbmVudCxcblx0RXZlbnRFbWl0dGVyLFxuXHRJbnB1dCxcblx0T25DaGFuZ2VzLFxuXHRPbkRlc3Ryb3ksXG5cdE9uSW5pdCxcblx0T3V0cHV0LFxuXHRSZW5kZXJlcjIsXG5cdFNpbXBsZUNoYW5nZXMsXG5cdFR5cGVcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge1xuXHRHdENvbmZpZyxcblx0R3RDb25maWdGaWVsZCxcblx0R3RDb25maWdTZXR0aW5nLFxuXHRHdEV2ZW50LFxuXHRHdEV4cGFuZGVkUm93LFxuXHRHdEluZm9ybWF0aW9uLFxuXHRHdE9wdGlvbnMsXG5cdEd0UmVuZGVyRmllbGQsXG5cdEd0Um93LFxuXHRHdFJvd01ldGEsXG5cdEd0VGV4dHNcbn0gZnJvbSAnLi4nO1xuaW1wb3J0IHsgR3RNZXRhUGlwZSB9IGZyb20gJy4uL3BpcGVzL2d0LW1ldGEucGlwZSc7XG5cbkBDb21wb25lbnQoe1xuXHRzZWxlY3RvcjogJ2dlbmVyaWMtdGFibGUnLFxuXHR0ZW1wbGF0ZTogYDx0YWJsZSBjbGFzcz1cInRhYmxlXCIgbmdDbGFzcz1cInt7Z3RDbGFzc2VzfX0ge3tndE9wdGlvbnMuc3RhY2sgPyAndGFibGUtc3RhY2tlZCc6Jyd9fVwiXG4gICAgICAgKm5nSWY9XCJndEZpZWxkcyAmJiBndFNldHRpbmdzICYmIChndEZpZWxkcyB8IGd0VmlzaWJsZTpndFNldHRpbmdzOnJlZnJlc2hQaXBlKS5sZW5ndGggPiAwXCI+XG4gIDx0aGVhZD5cbiAgPHRyPlxuICAgIDx0aCBjbGFzcz1cImd0LXNvcnQtbGFiZWxcIiAqbmdJZj1cImd0T3B0aW9ucy5zdGFja1wiPnt7Z3RUZXh0cy5zb3J0TGFiZWx9fTwvdGg+XG4gICAgPHRoICpuZ0Zvcj1cImxldCBjb2x1bW4gb2YgZ3RTZXR0aW5ncyB8IGd0VmlzaWJsZTpndFNldHRpbmdzOnJlZnJlc2hQaXBlXCJcbiAgICAgICAgbmdDbGFzcz1cInt7Y29sdW1uLm9iamVjdEtleSArJy1jb2x1bW4nIHwgZGFzaENhc2V9fSB7e2d0RmllbGRzIHwgZ3RQcm9wZXJ0eTpjb2x1bW4ub2JqZWN0S2V5OidjbGFzc05hbWVzJ319IHt7Y29sdW1uLnNvcnRFbmFibGVkID8gJ3NvcnQtJytjb2x1bW4uc29ydDonJ319IHt7Y29sdW1uLnNvcnRFbmFibGVkICYmIGNvbHVtbi5zb3J0T3JkZXIgPj0gMCAgPyAnc29ydC1vcmRlci0nK2NvbHVtbi5zb3J0T3JkZXI6Jyd9fSB7eyBndEZpZWxkcyB8IGd0Q29sdW1uQ2xhc3M6Y29sdW1uIH19XCJcbiAgICAgICAgKGNsaWNrKT1cImNvbHVtbi5zb3J0RW5hYmxlZCA/IGd0U29ydChjb2x1bW4ub2JqZWN0S2V5LCRldmVudCk6Jyc7XCI+XG4gICAgICA8c3BhbiAqbmdJZj1cIiEoZ3RGaWVsZHMgfCBndFByb3BlcnR5OmNvbHVtbi5vYmplY3RLZXk6J2hlYWRlcicpXCI+e3tndEZpZWxkcyB8IGd0UHJvcGVydHk6Y29sdW1uLm9iamVjdEtleTonbmFtZSd9fTwvc3Bhbj5cbiAgICAgIDxndC1jdXN0b20tY29tcG9uZW50LWZhY3RvcnkgKm5nSWY9XCIoZ3RGaWVsZHMgfCBndFByb3BlcnR5OmNvbHVtbi5vYmplY3RLZXk6J2hlYWRlcicpXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW3R5cGVdPVwiKGd0RmllbGRzIHwgZ3RQcm9wZXJ0eTpjb2x1bW4ub2JqZWN0S2V5OidoZWFkZXInKT8udHlwZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtpbmplY3Rvcl09XCIoZ3RGaWVsZHMgfCBndFByb3BlcnR5OmNvbHVtbi5vYmplY3RLZXk6J2hlYWRlcicpPy5pbmplY3RvclwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtjb2x1bW5dPVwiZ3RGaWVsZHMgfCBndFByb3BlcnR5OmNvbHVtbi5vYmplY3RLZXk6J25hbWUnXCI+PC9ndC1jdXN0b20tY29tcG9uZW50LWZhY3Rvcnk+XG4gICAgICA8Z3QtY2hlY2tib3ggKm5nSWY9XCIoZ3RGaWVsZHMgfCBndFByb3BlcnR5OmNvbHVtbi5vYmplY3RLZXk6J2NvbHVtbkNvbXBvbmVudCcpPy50eXBlID09PSAnY2hlY2tib3gnXCIgW2NoZWNrZWRdPVwiKGd0T3B0aW9ucy5sYXp5TG9hZCA/IGxhenlBbGxTZWxlY3RlZDpzZWxlY3RlZFJvd3MubGVuZ3RoID09PSBndERhdGEubGVuZ3RoKVwiIChjaGFuZ2VkKT1cInRvZ2dsZUFsbFJvd3MoKVwiPjwvZ3QtY2hlY2tib3g+XG4gICAgPC90aD5cbiAgPC90cj5cbiAgPC90aGVhZD5cbiAgPG5nLXRlbXBsYXRlXG4gICAgW25nSWZdPVwiZ3RUb3RhbHMgJiYgKGd0T3B0aW9ucy5sYXp5TG9hZCA9PT0gZmFsc2UgPyAoZ3REYXRhIHwgZ3RGaWx0ZXI6Z3RJbmZvLmZpbHRlcjpndEluZm86cmVmcmVzaEZpbHRlcjpndERhdGEubGVuZ3RoIHwgZ3RTZWFyY2g6Z3RJbmZvLnNlYXJjaFRlcm1zOmd0SW5mbzpndFNldHRpbmdzOmd0RmllbGRzOmd0RGF0YS5sZW5ndGgpLmxlbmd0aCA+IDAgOiBndERhdGEubGVuZ3RoID4gMClcIj5cbiAgICA8dGhlYWQgY2xhc3M9XCJndC10b3RhbHNcIj5cbiAgICA8dHIgKm5nRm9yPVwibGV0IHRvdGFsIG9mIGd0VG90YWxzIHwgZ3RUb3RhbHNQb3NpdGlvblwiPlxuICAgICAgPHRkICpuZ0Zvcj1cImxldCBjb2x1bW4gb2YgZ3RTZXR0aW5ncyB8IGd0VmlzaWJsZTpndFNldHRpbmdzOnJlZnJlc2hQaXBlO2xldCBpID0gaW5kZXg7XCJcbiAgICAgICAgICBuZ0NsYXNzPVwie3tjb2x1bW4ub2JqZWN0S2V5ICsnLXRvdGFscy1jb2x1bW4nIHwgZGFzaENhc2V9fSB7e2d0RmllbGRzIHwgZ3RQcm9wZXJ0eTpjb2x1bW4ub2JqZWN0S2V5OidjbGFzc05hbWVzJ319IHt7IGd0RmllbGRzIHwgZ3RDb2x1bW5DbGFzczpjb2x1bW4gfX1cIj5cbiAgICAgICAgPHNwYW4gKm5nSWY9XCJpID09PSAwXCIgY2xhc3M9XCJmbG9hdC1sZWZ0XCI+e3t0b3RhbC5uYW1lfX08L3NwYW4+PHNwYW5cbiAgICAgICAgW2lubmVySFRNTF09XCJ0b3RhbC5maWVsZHNbY29sdW1uLm9iamVjdEtleV0gfCBndFRvdGFsczoodG90YWwudXBkYXRlID09PSBmYWxzZSB8fCBndE9wdGlvbnMubGF6eUxvYWQgPT09IHRydWUpID8gZ3REYXRhOihndERhdGEgfCBndEZpbHRlcjpndEluZm8uZmlsdGVyOmd0SW5mbzpyZWZyZXNoRmlsdGVyOmd0RGF0YS5sZW5ndGggfCBndFNlYXJjaDpndEluZm8uc2VhcmNoVGVybXM6Z3RJbmZvOmd0U2V0dGluZ3M6Z3RGaWVsZHM6Z3REYXRhLmxlbmd0aCk6Y29sdW1uLm9iamVjdEtleTpyZWZyZXNoVG90YWxzXCI+PC9zcGFuPlxuICAgICAgPC90ZD5cbiAgICA8L3RyPlxuICAgIDwvdGhlYWQ+XG4gICAgPHRmb290IGNsYXNzPVwiZ3QtdG90YWxzXCI+XG4gICAgPHRyICpuZ0Zvcj1cImxldCB0b3RhbCBvZiBndFRvdGFscyB8IGd0VG90YWxzUG9zaXRpb246J2Zvb3RlcidcIj5cbiAgICAgIDx0ZCAqbmdGb3I9XCJsZXQgY29sdW1uIG9mIGd0U2V0dGluZ3MgfCBndFZpc2libGU6Z3RTZXR0aW5nczpyZWZyZXNoUGlwZTtsZXQgaSA9IGluZGV4O1wiXG4gICAgICAgICAgbmdDbGFzcz1cInt7Y29sdW1uLm9iamVjdEtleSArJy10b3RhbHMtY29sdW1uJyB8IGRhc2hDYXNlfX0ge3tndEZpZWxkcyB8IGd0UHJvcGVydHk6Y29sdW1uLm9iamVjdEtleTonY2xhc3NOYW1lcyd9fSB7eyBndEZpZWxkcyB8IGd0Q29sdW1uQ2xhc3M6Y29sdW1uIH19XCI+XG4gICAgICAgIDxzcGFuICpuZ0lmPVwiaSA9PT0gMFwiIGNsYXNzPVwiZmxvYXQtbGVmdFwiPnt7dG90YWwubmFtZX19PC9zcGFuPjxzcGFuXG4gICAgICAgIFtpbm5lckhUTUxdPVwidG90YWwuZmllbGRzW2NvbHVtbi5vYmplY3RLZXldIHwgZ3RUb3RhbHM6KHRvdGFsLnVwZGF0ZSA9PT0gZmFsc2UgfHwgZ3RPcHRpb25zLmxhenlMb2FkID09PSB0cnVlKSA/IGd0RGF0YTooZ3REYXRhIHwgZ3RGaWx0ZXI6Z3RJbmZvLmZpbHRlcjpndEluZm86cmVmcmVzaEZpbHRlcjpndERhdGEubGVuZ3RoIHwgZ3RTZWFyY2g6Z3RJbmZvLnNlYXJjaFRlcm1zOmd0SW5mbzpndFNldHRpbmdzOmd0RmllbGRzOmd0RGF0YS5sZW5ndGgpOmNvbHVtbi5vYmplY3RLZXk6cmVmcmVzaFRvdGFsc1wiPjwvc3Bhbj5cbiAgICAgIDwvdGQ+XG4gICAgPC90cj5cbiAgICA8L3Rmb290PlxuICA8L25nLXRlbXBsYXRlPlxuICA8dGJvZHkgKm5nSWY9XCJndERhdGEgJiYgZ3RJbmZvXCI+XG4gIDxuZy10ZW1wbGF0ZSBjbGFzcz1cInRhYmxlLXJvd3NcIiBuZ0ZvciBsZXQtcm93IGxldC1sYXN0PVwibGFzdFwiIFtuZ0ZvclRyYWNrQnldPVwidHJhY2tCeUZuXCJcbiAgICAgICAgICAgICAgIFtuZ0Zvck9mXT1cImd0T3B0aW9ucy5sYXp5TG9hZCAmJiBndEluZm8gPyAoZ3REYXRhW2d0SW5mby5wYWdlQ3VycmVudC0xXSkgOiAoZ3REYXRhIHwgZ3RGaWx0ZXI6Z3RJbmZvLmZpbHRlcjpndEluZm86cmVmcmVzaEZpbHRlcjpndERhdGEubGVuZ3RoIHwgZ3RTZWFyY2g6Z3RJbmZvLnNlYXJjaFRlcm1zOmd0SW5mbzpndFNldHRpbmdzOmd0RmllbGRzOmd0RGF0YS5sZW5ndGggfCBndE9yZGVyQnk6c29ydE9yZGVyOmd0RmllbGRzOnJlZnJlc2hTb3J0aW5nOmd0RGF0YS5sZW5ndGggfCBndENodW5rOmd0SW5mbzpndEluZm8ucmVjb3JkTGVuZ3RoOmd0SW5mby5wYWdlQ3VycmVudDpyZWZyZXNoUGFnZUFycmF5Omd0RGF0YS5sZW5ndGg6Z3RFdmVudDpkYXRhIHwgZ3RSb3dDbGFzczpndEZpZWxkcylcIj5cbiAgICA8dHIgW25nQ2xhc3NdPVwieydyb3ctc2VsZWN0ZWQnOm1ldGFJbmZvW3Jvdy4kJGd0Um93SWRdPy5pc1NlbGVjdGVkLCAncm93LW9wZW4nOm1ldGFJbmZvW3Jvdy4kJGd0Um93SWRdPy5pc09wZW4sICdyb3ctbG9hZGluZyc6bG9hZGluZywgJ3Jvdy1leHBhbmRhYmxlJzpndFJvd0NvbXBvbmVudH1cIlxuICAgICAgICBjbGFzcz1cInt7cm93LiQkZ3RSb3dDbGFzc319XCJcbiAgICAgICAgKGNsaWNrKT1cImd0T3B0aW9ucy5yb3dTZWxlY3Rpb24gPyB0b2dnbGVTZWxlY3Qocm93KTpyb3dDbGljayhyb3csICRldmVudClcIj5cbiAgICAgIDx0ZCAqbmdGb3I9XCJsZXQgY29sdW1uIG9mIHJvdyB8IGd0UmVuZGVyOmd0U2V0dGluZ3M6Z3RGaWVsZHM6cmVmcmVzaFBpcGU6bG9hZGluZzpndE9wdGlvbnMuaGlnaGxpZ2h0U2VhcmNoOmd0SW5mby5zZWFyY2hUZXJtczt0cmFja0J5OnRyYWNrQnlDb2x1bW5GblwiXG4gICAgICAgICAgbmdDbGFzcz1cInt7Y29sdW1uLm9iamVjdEtleSArJy1jb2x1bW4nIHwgZGFzaENhc2V9fSB7e2d0RmllbGRzIHwgZ3RQcm9wZXJ0eTpjb2x1bW4ub2JqZWN0S2V5OidjbGFzc05hbWVzJ319IHt7KGd0RmllbGRzIHwgZ3RQcm9wZXJ0eTpjb2x1bW4ub2JqZWN0S2V5OidpbmxpbmVFZGl0JykgPyAnZ3QtaW5saW5lLWVkaXQnOicnfX0ge3tjb2x1bW4uZWRpdGVkID8gJ2d0LWVkaXRlZCc6Jyd9fSB7eyBndEZpZWxkcyB8IGd0Q29sdW1uQ2xhc3M6Y29sdW1uOnJvdyB9fVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJndC1yb3ctbGFiZWxcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKm5nSWY9XCJndE9wdGlvbnMuc3RhY2tcIj57eyhndEZpZWxkcyB8IGd0UHJvcGVydHk6Y29sdW1uLm9iamVjdEtleTonc3RhY2tlZEhlYWRpbmcnKSA/IChndEZpZWxkcyB8IGd0UHJvcGVydHk6Y29sdW1uLm9iamVjdEtleTonc3RhY2tlZEhlYWRpbmcnKSA6IChndEZpZWxkcyB8IGd0UHJvcGVydHk6Y29sdW1uLm9iamVjdEtleTonbmFtZScpfX08L3NwYW4+XG4gICAgICAgIDxndC1jdXN0b20tY29tcG9uZW50LWZhY3RvcnkgKm5nSWY9XCJjb2x1bW4uY29sdW1uQ29tcG9uZW50ICYmIGNvbHVtbi5jb2x1bW5Db21wb25lbnQudHlwZSAhPT0gJ2NoZWNrYm94J1wiIGNsYXNzPVwiZ3Qtcm93LWNvbnRlbnRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFt0eXBlXT1cImNvbHVtbi5jb2x1bW5Db21wb25lbnQudHlwZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW2luamVjdG9yXT1cImNvbHVtbi5jb2x1bW5Db21wb25lbnQuaW5qZWN0b3JcIiBbcm93XT1cInJvd1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW2NvbHVtbl09XCJjb2x1bW5cIiAocmVkcmF3RXZlbnQpPVwicmVkcmF3KCRldmVudClcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtzZWFyY2hUZXJtc109XCJndEluZm8uc2VhcmNoVGVybXNcIiAgKHNlYXJjaEV2ZW50KT1cInJlZHJhdygkZXZlbnQpXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoY2xpY2spPVwiY29sdW1uLmNsaWNrID8gY29sdW1uLmNsaWNrKHJvdyxjb2x1bW4sJGV2ZW50KTonJztjb2x1bW4uZXhwYW5kID8gdG9nZ2xlQ29sbGFwc2Uocm93LCBjb2x1bW4uZXhwYW5kKTonJ1wiPjwvZ3QtY3VzdG9tLWNvbXBvbmVudC1mYWN0b3J5PlxuICAgICAgICA8c3BhbiAqbmdJZj1cIiFjb2x1bW4uY29sdW1uQ29tcG9uZW50ICYmICghKGd0RmllbGRzIHwgZ3RQcm9wZXJ0eTpjb2x1bW4ub2JqZWN0S2V5OidpbmxpbmVFZGl0JykgfHwgKChndEZpZWxkcyB8IGd0UHJvcGVydHk6Y29sdW1uLm9iamVjdEtleTonaW5saW5lRWRpdCcpPy5hY3RpdmUgfCBndElzT2JzZXJ2YWJsZSkgJiYgISgoZ3RGaWVsZHMgfCBndFByb3BlcnR5OmNvbHVtbi5vYmplY3RLZXk6J2lubGluZUVkaXQnKT8uYWN0aXZlIHwgYXN5bmMpIHx8ICghKChndEZpZWxkcyB8IGd0UHJvcGVydHk6Y29sdW1uLm9iamVjdEtleTonaW5saW5lRWRpdCcpPy5hY3RpdmUgfCBndElzT2JzZXJ2YWJsZSkgJiYgISgoZ3RGaWVsZHMgfCBndFByb3BlcnR5OmNvbHVtbi5vYmplY3RLZXk6J2lubGluZUVkaXQnKT8uYWN0aXZlIHwgZ3RJc0VkaXRhYmxlOnJvdzpyZWZyZXNoUGlwZSkpKVwiXG4gICAgICAgICAgICAgIGNsYXNzPVwiZ3Qtcm93LWNvbnRlbnRcIiBbaW5uZXJIVE1MXT1cImNvbHVtbi5yZW5kZXJWYWx1ZVwiXG4gICAgICAgICAgICAgIChjbGljayk9XCJjb2x1bW4uY2xpY2sgPyBjb2x1bW4uY2xpY2socm93LGNvbHVtbiwkZXZlbnQpOicnO2NvbHVtbi5leHBhbmQgPyB0b2dnbGVDb2xsYXBzZShyb3csIGNvbHVtbi5leHBhbmQpOicnXCI+PC9zcGFuPlxuICAgICAgICA8bmctdGVtcGxhdGVcbiAgICAgICAgICBbbmdJZl09XCIhY29sdW1uLmNvbHVtbkNvbXBvbmVudCAmJiAoKChndEZpZWxkcyB8IGd0UHJvcGVydHk6Y29sdW1uLm9iamVjdEtleTonaW5saW5lRWRpdCcpPy5hY3RpdmUgfCBndElzT2JzZXJ2YWJsZSkgJiYgKChndEZpZWxkcyB8IGd0UHJvcGVydHk6Y29sdW1uLm9iamVjdEtleTonaW5saW5lRWRpdCcpPy5hY3RpdmUgfCBhc3luYykgfHwgKChndEZpZWxkcyB8IGd0UHJvcGVydHk6Y29sdW1uLm9iamVjdEtleTonaW5saW5lRWRpdCcpPy5hY3RpdmUgfCBndElzRWRpdGFibGU6cm93OnJlZnJlc2hQaXBlKSlcIj5cbiAgICAgICAgICA8bmctdGVtcGxhdGUgW25nSWZdPVwiKFt0cnVlLCdlbWFpbCcsJ251bWJlcicsJ3Bhc3N3b3JkJywgJ3RleHQnXS5pbmRleE9mKChndEZpZWxkcyB8IGd0UHJvcGVydHk6Y29sdW1uLm9iamVjdEtleTonaW5saW5lRWRpdCcpLnR5cGUpICE9PSAtMSkgfHwgIShndEZpZWxkcyB8IGd0UHJvcGVydHk6Y29sdW1uLm9iamVjdEtleTonaW5saW5lRWRpdCcpLnR5cGVcIj5cbiAgICAgICAgICAgIDxpbnB1dCBjbGFzcz1cImlubGluZS1lZGl0XCIgW2F0dHIudHlwZV09XCIhKGd0RmllbGRzIHwgZ3RQcm9wZXJ0eTpjb2x1bW4ub2JqZWN0S2V5OidpbmxpbmVFZGl0JykudHlwZSA/ICd0ZXh0JyA6ICEoKGd0RmllbGRzIHwgZ3RQcm9wZXJ0eTpjb2x1bW4ub2JqZWN0S2V5OidpbmxpbmVFZGl0JykudHlwZSB8IGd0SXNPYnNlcnZhYmxlKSA/IChndEZpZWxkcyB8IGd0UHJvcGVydHk6Y29sdW1uLm9iamVjdEtleTonaW5saW5lRWRpdCcpLnR5cGU6KGd0RmllbGRzIHwgZ3RQcm9wZXJ0eTpjb2x1bW4ub2JqZWN0S2V5OidpbmxpbmVFZGl0JykudHlwZSB8IGFzeW5jXCIgWyhuZ01vZGVsKV09XCJjb2x1bW4ucmVuZGVyVmFsdWVcIlxuICAgICAgICAgICAgICAgICAgIChpbnB1dCk9XCJndFVwZGF0ZUNvbHVtbigkZXZlbnQscm93LCBjb2x1bW4pXCI+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cImd0LWlubGluZS1lZGl0LW5vdGljZVwiPnt7Z3RUZXh0cy5pbmxpbmVFZGl0RWRpdGVkfX08L3NwYW4+XG4gICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgICA8Z3QtZHJvcGRvd25cbiAgICAgICAgICAgICpuZ0lmPVwiKCgoZ3RGaWVsZHMgfCBndFByb3BlcnR5OmNvbHVtbi5vYmplY3RLZXk6J2lubGluZUVkaXQnKS50eXBlKSAmJiAoKGd0RmllbGRzIHwgZ3RQcm9wZXJ0eTpjb2x1bW4ub2JqZWN0S2V5OidpbmxpbmVFZGl0JykudHlwZSkubGVuZ3RoID4gMCkgfHwgKChndEZpZWxkcyB8IGd0UHJvcGVydHk6Y29sdW1uLm9iamVjdEtleTonaW5saW5lRWRpdCcpLnR5cGUgfCBndElzT2JzZXJ2YWJsZSlcIlxuICAgICAgICAgICAgW29wdGlvbnNdPVwiISgoZ3RGaWVsZHMgfCBndFByb3BlcnR5OmNvbHVtbi5vYmplY3RLZXk6J2lubGluZUVkaXQnKS50eXBlIHwgZ3RJc09ic2VydmFibGUpID8gKGd0RmllbGRzIHwgZ3RQcm9wZXJ0eTpjb2x1bW4ub2JqZWN0S2V5OidpbmxpbmVFZGl0JykudHlwZSA6IChndEZpZWxkcyB8IGd0UHJvcGVydHk6Y29sdW1uLm9iamVjdEtleTonaW5saW5lRWRpdCcpLnR5cGUgfCBhc3luY1wiXG4gICAgICAgICAgICBbaWRdPVwiJ18nICsgcm93LiQkZ3RSb3dJZCArICdfJyArIGNvbHVtbi5vYmplY3RLZXlcIlxuICAgICAgICAgICAgWyhzZWxlY3RlZCldPVwiY29sdW1uLnJlbmRlclZhbHVlXCIgKHNlbGVjdGVkQ2hhbmdlKT1cImd0RHJvcGRvd25TZWxlY3Qocm93LCBjb2x1bW4pXCI+QWRkXG4gICAgICAgICAgICBpbmxpbmUgZWRpdGluZyBtb2R1bGVcbiAgICAgICAgICA8L2d0LWRyb3Bkb3duPlxuICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgICAgICA8bmctdGVtcGxhdGUgW25nSWZdPVwiIWNvbHVtbi5jb2x1bW5Db21wb25lbnQgJiYgISgoZ3RGaWVsZHMgfCBndFByb3BlcnR5OmNvbHVtbi5vYmplY3RLZXk6J2lubGluZUVkaXQnKT8uYWN0aXZlKSBcIj5cbiAgICAgICAgICA8bmctdGVtcGxhdGVcbiAgICAgICAgICAgIFtuZ0lmXT1cIlt0cnVlLCdlbWFpbCcsJ251bWJlcicsJ3Bhc3N3b3JkJ10uaW5kZXhPZihndEZpZWxkcyB8IGd0UHJvcGVydHk6Y29sdW1uLm9iamVjdEtleTonaW5saW5lRWRpdCcpICE9PSAtMVwiPlxuICAgICAgICAgICAgPGlucHV0IGNsYXNzPVwiaW5saW5lLWVkaXRcIiBbYXR0ci50eXBlXT1cIihndEZpZWxkcyB8IGd0UHJvcGVydHk6Y29sdW1uLm9iamVjdEtleTonaW5saW5lRWRpdCcpID09PSB0cnVlID8gJ3RleHQnOihndEZpZWxkcyB8IGd0UHJvcGVydHk6Y29sdW1uLm9iamVjdEtleTonaW5saW5lRWRpdCcpXCIgWyhuZ01vZGVsKV09XCJjb2x1bW4ucmVuZGVyVmFsdWVcIlxuICAgICAgICAgICAgICAgICAgIChpbnB1dCk9XCJndFVwZGF0ZUNvbHVtbigkZXZlbnQscm93LCBjb2x1bW4pXCI+XG4gICAgICAgICAgICA8c3BhbiBjbGFzcz1cImd0LWlubGluZS1lZGl0LW5vdGljZVwiPnt7Z3RUZXh0cy5pbmxpbmVFZGl0RWRpdGVkfX08L3NwYW4+XG4gICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgICA8Z3QtZHJvcGRvd25cbiAgICAgICAgICAgICpuZ0lmPVwiKGd0RmllbGRzIHwgZ3RQcm9wZXJ0eTpjb2x1bW4ub2JqZWN0S2V5OidpbmxpbmVFZGl0JykgJiYgW3RydWUsJ2VtYWlsJywnbnVtYmVyJywncGFzc3dvcmQnXS5pbmRleE9mKGd0RmllbGRzIHwgZ3RQcm9wZXJ0eTpjb2x1bW4ub2JqZWN0S2V5OidpbmxpbmVFZGl0JykgPT09IC0xXCJcbiAgICAgICAgICAgIFtvcHRpb25zXT1cImd0RmllbGRzIHwgZ3RQcm9wZXJ0eTpjb2x1bW4ub2JqZWN0S2V5OidpbmxpbmVFZGl0J1wiXG4gICAgICAgICAgICBbaWRdPVwiJ18nICsgcm93LiQkZ3RSb3dJZCArICdfJyArIGNvbHVtbi5vYmplY3RLZXlcIlxuICAgICAgICAgICAgWyhzZWxlY3RlZCldPVwiY29sdW1uLnJlbmRlclZhbHVlXCIgKHNlbGVjdGVkQ2hhbmdlKT1cImd0RHJvcGRvd25TZWxlY3Qocm93LCBjb2x1bW4pXCI+QWRkXG4gICAgICAgICAgICBpbmxpbmUgZWRpdGluZyBtb2R1bGVcbiAgICAgICAgICA8L2d0LWRyb3Bkb3duPlxuICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgICAgICA8Z3QtY2hlY2tib3ggKm5nSWY9XCJjb2x1bW4uY29sdW1uQ29tcG9uZW50ICYmIGNvbHVtbi5jb2x1bW5Db21wb25lbnQudHlwZSA9PT0gJ2NoZWNrYm94J1wiIFtjaGVja2VkXT1cIm1ldGFJbmZvW3Jvdy4kJGd0Um93SWRdPy5pc1NlbGVjdGVkXCIgKGNoYW5nZWQpPVwidG9nZ2xlU2VsZWN0KHJvdylcIj48L2d0LWNoZWNrYm94PlxuICAgICAgPC90ZD5cbiAgICA8L3RyPlxuICAgIDx0ciBjbGFzcz1cInJvdy1leHBhbmRlZFwiICpuZ0lmPVwibWV0YUluZm9bcm93LiQkZ3RSb3dJZF0/LmlzT3BlblwiPlxuICAgICAgPHRkIFthdHRyLmNvbHNwYW5dPVwiKGd0RmllbGRzIHwgZ3RWaXNpYmxlOmd0U2V0dGluZ3M6cmVmcmVzaFBpcGUpLmxlbmd0aFwiPlxuICAgICAgICA8Z3QtZXhwYW5kaW5nLXJvdyBbcm93XT1cInJvd1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFt0eXBlXT1cImV4cGFuZGVkUm93LmNvbXBvbmVudCA/IGV4cGFuZGVkUm93LmNvbXBvbmVudDpndFJvd0NvbXBvbmVudFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFtjb2x1bW5XaWR0aF09XCJjb2x1bW5XaWR0aFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFtndEZpZWxkc109XCJndEZpZWxkc1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFtndE9wdGlvbnNdPVwiZ3RPcHRpb25zXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgW2d0RXZlbnRdPVwiZ3RFdmVudFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFtndEluZm9dPVwiZ3RJbmZvXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgW2d0U2V0dGluZ3NdPVwiZ3RTZXR0aW5nc1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFtkYXRhXT1cImV4cGFuZGVkUm93LmRhdGEgPyBleHBhbmRlZFJvdy5kYXRhOnJvd1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgIChyZWRyYXdFdmVudCk9XCJyZWRyYXcoJGV2ZW50KVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICh0b2dnbGVSb3dFdmVudCk9XCJ0b2dnbGVDb2xsYXBzZSgkZXZlbnQpXCI+PC9ndC1leHBhbmRpbmctcm93PlxuICAgICAgPC90ZD5cbiAgICA8L3RyPlxuICAgIDx0ciAqbmdJZj1cImd0T3B0aW9ucy5yZXBvcnRDb2x1bW5XaWR0aCAmJiBsYXN0XCI+XG4gICAgICA8dGQgc3R5bGU9XCJwYWRkaW5nOiAwOyBib3JkZXI6bm9uZTtcIlxuICAgICAgICAgICpuZ0Zvcj1cImxldCBjb2x1bW4gb2YgZ3RTZXR0aW5ncyB8IGd0VmlzaWJsZTpndFNldHRpbmdzOnJlZnJlc2hQaXBlXCIgZ3RDb2x1bW5XaWR0aFxuICAgICAgICAgIFtvYmplY3RLZXldPVwiY29sdW1uLm9iamVjdEtleVwiIFt3aWR0aHNdPVwiY29sdW1uV2lkdGhcIj48L3RkPlxuICAgIDwvdHI+XG4gIDwvbmctdGVtcGxhdGU+XG4gIDx0ciAqbmdJZj1cImd0SW5mby5wYWdlVG90YWwgPT09IDAgJiYgKGd0SW5mby5zZWFyY2hUZXJtcyB8fCBndEluZm8uZmlsdGVyKSAmJiAhbG9hZGluZ1wiPlxuICAgIDx0ZCBjbGFzcz1cImd0LW5vLW1hdGNoaW5nLXJlc3VsdHNcIiBbYXR0ci5jb2xzcGFuXT1cIihndEZpZWxkcyB8IGd0VmlzaWJsZTpndFNldHRpbmdzKS5sZW5ndGhcIj5cbiAgICAgIHt7Z3RUZXh0cy5ub01hdGNoaW5nRGF0YX19XG4gICAgPC90ZD5cbiAgPC90cj5cbiAgPHRyICpuZ0lmPVwiZ3RJbmZvLnBhZ2VUb3RhbCA9PT0gMCAmJiAhKGd0SW5mby5zZWFyY2hUZXJtcyB8fCBndEluZm8uZmlsdGVyKSAmJiAhbG9hZGluZ1wiPlxuICAgIDx0ZCBjbGFzcz1cImd0LW5vLXJlc3VsdHNcIiBbYXR0ci5jb2xzcGFuXT1cIihndEZpZWxkcyB8IGd0VmlzaWJsZTpndFNldHRpbmdzKS5sZW5ndGhcIj57e2d0VGV4dHMubm9EYXRhfX1cbiAgICA8L3RkPlxuICA8L3RyPlxuICA8dHIgKm5nSWY9XCJndEluZm8ucGFnZVRvdGFsID09PSAwICYmIGxvYWRpbmdcIj5cbiAgICA8dGQgY2xhc3M9XCJndC1sb2FkaW5nLWRhdGFcIiBbYXR0ci5jb2xzcGFuXT1cIihndEZpZWxkcyB8IGd0VmlzaWJsZTpndFNldHRpbmdzKS5sZW5ndGhcIj57e2d0VGV4dHMubG9hZGluZ319PC90ZD5cbiAgPC90cj5cbiAgPC90Ym9keT5cbjwvdGFibGU+XG48dGFibGUgY2xhc3M9XCJ0YWJsZVwiIG5nQ2xhc3M9XCJ7e2d0Q2xhc3Nlc319IHt7Z3RPcHRpb25zLnN0YWNrID8gJ3RhYmxlLXN0YWNrZWQnOicnfX1cIlxuICAgICAgICpuZ0lmPVwiZ3RGaWVsZHMgJiYgZ3RTZXR0aW5ncyAmJiAoZ3RGaWVsZHMgfCBndFZpc2libGU6Z3RTZXR0aW5nczpyZWZyZXNoUGlwZSkubGVuZ3RoID09PSAwXCI+XG4gIDx0aGVhZD5cbiAgPHRyPlxuICAgIDx0aCBjbGFzcz1cImd0LW5vLXZpc2libGUtY29sdW1uc1wiPnt7Z3RUZXh0cy5ub1Zpc2libGVDb2x1bW5zSGVhZGluZ319PC90aD5cbiAgPC90cj5cbiAgPC90aGVhZD5cbiAgPHRib2R5PlxuICA8dHI+XG4gICAgPHRkIGNsYXNzPVwiZ3Qtbm8tdmlzaWJsZS1jb2x1bW5zXCI+e3tndFRleHRzLm5vVmlzaWJsZUNvbHVtbnN9fTwvdGQ+XG4gIDwvdHI+XG4gIDwvdGJvZHk+XG48L3RhYmxlPlxuPHRhYmxlIGNsYXNzPVwidGFibGVcIiBuZ0NsYXNzPVwie3tndENsYXNzZXN9fSB7e2d0T3B0aW9ucy5zdGFjayA/ICd0YWJsZS1zdGFja2VkJzonJ319XCJcbiAgICAgICAqbmdJZj1cIiFndEZpZWxkcyB8fCAhZ3RTZXR0aW5nc1wiPlxuICA8dGhlYWQ+XG4gIDx0cj5cbiAgICA8dGggY2xhc3M9XCJndC1sb2FkaW5nLWNvbmZpZ1wiPiZuYnNwOzwvdGg+XG4gIDwvdHI+XG4gIDwvdGhlYWQ+XG4gIDx0Ym9keT5cbiAgPHRyPlxuICAgIDx0ZCBjbGFzcz1cImd0LWxvYWRpbmctY29uZmlnXCI+Jm5ic3A7PC90ZD5cbiAgPC90cj5cbiAgPC90Ym9keT5cbjwvdGFibGU+XG5gXG59KVxuZXhwb3J0IGNsYXNzIEdlbmVyaWNUYWJsZUNvbXBvbmVudDxSIGV4dGVuZHMgR3RSb3csIEMgZXh0ZW5kcyBHdEV4cGFuZGVkUm93PFI+PlxuXHRpbXBsZW1lbnRzIE9uSW5pdCwgT25DaGFuZ2VzLCBPbkRlc3Ryb3kge1xuXHRnZXQgZ3RSb3dDb21wb25lbnQoKTogVHlwZTxDPiB7XG5cdFx0cmV0dXJuIHRoaXMuX2d0Um93Q29tcG9uZW50O1xuXHR9XG5cblx0Z2V0IGhhc0VkaXRzKCk6IGJvb2xlYW4ge1xuXHRcdHJldHVybiBPYmplY3Qua2V5cyh0aGlzLmVkaXRlZFJvd3MpLmxlbmd0aCA+IDA7XG5cdH1cblxuXHRnZXQgZ3RPcHRpb25zKCk6IEd0T3B0aW9ucyB7XG5cdFx0cmV0dXJuIHRoaXMuX2d0T3B0aW9ucztcblx0fVxuXG5cdGdldCBndFRvdGFscygpOiBhbnkge1xuXHRcdHJldHVybiB0aGlzLl9ndFRvdGFscztcblx0fVxuXG5cdGdldCBndEZpZWxkcygpOiBHdENvbmZpZ0ZpZWxkPFIsIGFueT5bXSB7XG5cdFx0cmV0dXJuIHRoaXMuX2d0RmllbGRzO1xuXHR9XG5cblx0Z2V0IGd0U2V0dGluZ3MoKTogR3RDb25maWdTZXR0aW5nW10ge1xuXHRcdHJldHVybiB0aGlzLl9ndFNldHRpbmdzO1xuXHR9XG5cblx0Z2V0IGd0RGF0YSgpOiBBcnJheTxhbnk+IHtcblx0XHRyZXR1cm4gdGhpcy5fZ3REYXRhO1xuXHR9XG5cblx0QElucHV0KClcblx0c2V0IGd0T3B0aW9ucyh2YWx1ZTogR3RPcHRpb25zKSB7XG5cdFx0dGhpcy5fZ3RPcHRpb25zID0gdmFsdWU7XG5cblx0XHQvLyBpZiBudW1iZXIgb2Ygcm93cyBpcyBwYXNzZWQgYW5kIGlmIG51bWJlciBvZiByb3dzIGRpZmZlcnMgZnJvbSBjdXJyZW50IHJlY29yZCBsZW5ndGguLi5cblx0XHRpZiAoXG5cdFx0XHR0aGlzLmd0T3B0aW9ucy5udW1iZXJPZlJvd3MgJiZcblx0XHRcdHRoaXMuZ3RJbmZvLnJlY29yZExlbmd0aCAhPT0gdGhpcy5ndE9wdGlvbnMubnVtYmVyT2ZSb3dzXG5cdFx0KSB7XG5cdFx0XHQvLyAuLi51cGRhdGUgcmVjb3JkIGxlbmd0aCBhbmQgcmVkcmF3IHRhYmxlXG5cdFx0XHR0aGlzLmd0SW5mby5yZWNvcmRMZW5ndGggPSB0aGlzLmd0T3B0aW9ucy5udW1iZXJPZlJvd3M7XG5cdFx0XHR0aGlzLnJlZHJhdygpO1xuXHRcdH1cblxuXHRcdC8vIC4uLmV4dGVuZCBndE9wdGlvbnMgZGVmYXVsdCB2YWx1ZXMgd2l0aCB2YWx1ZXMgcGFzc2VkIGludG8gY29tcG9uZW50XG5cdFx0dGhpcy5fZ3RPcHRpb25zID0gPEd0T3B0aW9ucz50aGlzLmV4dGVuZChcblx0XHRcdHRoaXMuZ3REZWZhdWx0T3B0aW9ucyxcblx0XHRcdHRoaXMuX2d0T3B0aW9uc1xuXHRcdCk7XG5cdH1cblxuXHRASW5wdXQoKVxuXHRzZXQgZ3RUb3RhbHModmFsdWU6IGFueSkge1xuXHRcdHRoaXMuX2d0VG90YWxzID0gdmFsdWU7XG5cdH1cblxuXHRASW5wdXQoKVxuXHRzZXQgZ3RGaWVsZHModmFsdWU6IEd0Q29uZmlnRmllbGQ8UiwgYW55PltdKSB7XG5cdFx0dGhpcy5fZ3RGaWVsZHMgPSB2YWx1ZTtcblx0XHRjb25zdCBDT0xVTU5TX1dJVEhfQ0xBU1NfTkFNRVMgPSB0aGlzLl9ndEZpZWxkc1xuXHRcdFx0Lm1hcChjb2x1bW4gPT4gY29sdW1uKVxuXHRcdFx0LmZpbHRlcihjb2x1bW4gPT4gY29sdW1uLmNsYXNzTmFtZXMpO1xuXHRcdC8vIFRPRE86IHJlbW92ZSBkZXByZWNhdGVkIHdhcm5pbmcgd2hlbiBzZXR0aW5nIGhhcyBiZWVuIHJlbW92ZWRcblx0XHRpZiAoQ09MVU1OU19XSVRIX0NMQVNTX05BTUVTLmxlbmd0aCA+IDApIHtcblx0XHRcdGNvbnNvbGUud2Fybihcblx0XHRcdFx0J0ZpZWxkIHNldHRpbmcgXCJjbGFzc05hbWVzXCIgaGF2ZSBiZWVuIGRlcHJlY2F0ZWQgaW4gZmF2b3IgZm9yIFwiY29sdW1uQ2xhc3NcIiBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBmdXR1cmUsIHBsZWFzZSB1cGRhdGUgZmllbGQgc2V0dGluZ3MgZm9yIGNvbHVtbiB3aXRoIG9iamVjdCBrZXk6ICcgK1xuXHRcdFx0XHRcdENPTFVNTlNfV0lUSF9DTEFTU19OQU1FU1swXS5vYmplY3RLZXlcblx0XHRcdCk7XG5cdFx0fVxuXHR9XG5cblx0QElucHV0KClcblx0c2V0IGd0U2V0dGluZ3ModmFsdWU6IEd0Q29uZmlnU2V0dGluZ1tdKSB7XG5cdFx0dGhpcy5fZ3RTZXR0aW5ncyA9IHZhbHVlO1xuXG5cdFx0Ly8gbG9vcCB0aHJvdWdoIGN1cnJlbnQgc2V0dGluZ3Ncblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2d0U2V0dGluZ3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdC8vIHNldCBzb3J0IGVuYWJsZWQvZGlzYWJsZWQgc2V0dGluZ1xuXHRcdFx0dGhpcy5fZ3RTZXR0aW5nc1tpXS5zb3J0RW5hYmxlZCA9XG5cdFx0XHRcdHRoaXMuX2d0U2V0dGluZ3NbaV0uc29ydEVuYWJsZWQgIT09IGZhbHNlXG5cdFx0XHRcdFx0PyAodGhpcy5fZ3RTZXR0aW5nc1tpXS5zb3J0RW5hYmxlZCA9ICEoXG5cdFx0XHRcdFx0XHRcdHRoaXMuX2d0U2V0dGluZ3NbaV0uc29ydCAmJlxuXHRcdFx0XHRcdFx0XHR0aGlzLl9ndFNldHRpbmdzW2ldLnNvcnQuaW5kZXhPZignZGlzYWJsZScpICE9PSAtMVxuXHRcdFx0XHRcdCAgKSlcblx0XHRcdFx0XHQ6IGZhbHNlO1xuXG5cdFx0XHQvLyBjaGVjayBpZiBzb3J0aW5nIGlzIHVuZGVmaW5lZC4uLlxuXHRcdFx0aWYgKHR5cGVvZiB0aGlzLl9ndFNldHRpbmdzW2ldLnNvcnQgPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRcdC8vIC4uLmlzIHNvLCBzZXQgc29ydGluZyBwcm9wZXJ0eSB0byBlbmFibGVcblx0XHRcdFx0dGhpcy5fZ3RTZXR0aW5nc1tpXS5zb3J0ID0gJ2VuYWJsZSc7XG5cdFx0XHR9XG5cblx0XHRcdC8vIGNoZWNrIGlmIGNvbHVtbiBvcmRlciBpcyB1bmRlZmluZWQuLi5cblx0XHRcdGlmIChcblx0XHRcdFx0dHlwZW9mIHRoaXMuX2d0U2V0dGluZ3NbaV0uY29sdW1uT3JkZXIgPT09ICd1bmRlZmluZWQnICYmXG5cdFx0XHRcdHRoaXMuX2d0U2V0dGluZ3NbaV0uZW5hYmxlZCAhPT0gZmFsc2Vcblx0XHRcdCkge1xuXHRcdFx0XHQvLyAuLi5pcyBzbywgc2V0IHNvcnRpbmcgcHJvcGVydHkgdG8gZW5hYmxlXG5cdFx0XHRcdHRoaXMuX2d0U2V0dGluZ3NbaV0uY29sdW1uT3JkZXIgPSB0aGlzLl9ndFNldHRpbmdzW2kgLSAxXVxuXHRcdFx0XHRcdD8gdGhpcy5fZ3RTZXR0aW5nc1tpIC0gMV0uY29sdW1uT3JkZXIgKyAxXG5cdFx0XHRcdFx0OiAwO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBjaGVjayBpZiBjb2x1bW4gbG9jayBzZXR0aW5ncyBhcmUgdW5kZWZpbmVkLi4uXG5cdFx0XHRpZiAodHlwZW9mIHRoaXMuX2d0U2V0dGluZ3NbaV0ubG9ja1NldHRpbmdzID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHQvLyAuLi5pZiBzbywgc2V0IGxvY2sgc2V0dGluZ3MgdG8gZmFsc2UgdW5sZXNzIGZpZWxkIGlzIGRpc2FibGVkIChlbmFibGUgPT09IGZhbHNlKVxuXHRcdFx0XHR0aGlzLl9ndFNldHRpbmdzW2ldLmxvY2tTZXR0aW5ncyA9XG5cdFx0XHRcdFx0dGhpcy5fZ3RTZXR0aW5nc1tpXS5lbmFibGVkID09PSBmYWxzZSB8fCBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0dGhpcy5yZXN0cnVjdHVyZVNvcnRpbmcoKTtcblx0fVxuXG5cdEBJbnB1dCgpXG5cdHNldCBndERhdGEoaW5pdGlhbERhdGE6IEFycmF5PGFueT4pIHtcblx0XHRjb25zdCBkYXRhID0gdGhpcy5fZ3RPcHRpb25zLm11dGF0ZURhdGFcblx0XHRcdD8gWy4uLmluaXRpYWxEYXRhXVxuXHRcdFx0OiB0aGlzLmNsb25lRGVlcChpbml0aWFsRGF0YSk7XG5cdFx0aWYgKHRoaXMuZ3RPcHRpb25zLmxhenlMb2FkICYmIHRoaXMuZ3RJbmZvKSB7XG5cdFx0XHR0aGlzLmd0TWV0YVBpcGUudHJhbnNmb3JtKFxuXHRcdFx0XHRkYXRhLFxuXHRcdFx0XHR0aGlzLmd0T3B0aW9ucy5yb3dJbmRleCxcblx0XHRcdFx0dGhpcy5ndEluZm8ucGFnZUN1cnJlbnQgLSAxLFxuXHRcdFx0XHR0aGlzLmd0SW5mby5yZWNvcmRMZW5ndGhcblx0XHRcdCk7XG5cdFx0XHRpZiAodGhpcy5sYXp5QWxsU2VsZWN0ZWQpIHtcblx0XHRcdFx0Y29uc3QgVU5JUVVFX1JPV1MgPSB0aGlzLnNlbGVjdGVkUm93cy5tYXAocm93ID0+IHJvdy4kJGd0Um93SWQpO1xuXHRcdFx0XHRkYXRhLm1hcChyb3cgPT4ge1xuXHRcdFx0XHRcdGlmIChVTklRVUVfUk9XUy5pbmRleE9mKHJvdy4kJGd0Um93SWQpID09PSAtMSkge1xuXHRcdFx0XHRcdFx0dGhpcy5zZWxlY3RlZFJvd3MucHVzaChyb3cpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHRcdHRoaXMuX3VwZGF0ZU1ldGFJbmZvKHRoaXMuc2VsZWN0ZWRSb3dzLCAnaXNTZWxlY3RlZCcsIHRydWUpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmd0TWV0YVBpcGUudHJhbnNmb3JtKGRhdGEsIHRoaXMuZ3RPcHRpb25zLnJvd0luZGV4KTtcblx0XHR9XG5cdFx0aWYgKHRoaXMuZ3RPcHRpb25zLnJvd1NlbGVjdGlvbkluaXRpYWxTdGF0ZSkge1xuXHRcdFx0ZGF0YS5tYXAocm93ID0+IHtcblx0XHRcdFx0Y29uc3Qgc2VsZWN0ZWQgPVxuXHRcdFx0XHRcdHR5cGVvZiB0aGlzLmd0T3B0aW9ucy5yb3dTZWxlY3Rpb25Jbml0aWFsU3RhdGUgPT09ICdmdW5jdGlvbidcblx0XHRcdFx0XHRcdD8gdGhpcy5ndE9wdGlvbnMucm93U2VsZWN0aW9uSW5pdGlhbFN0YXRlKHJvdylcblx0XHRcdFx0XHRcdDogdGhpcy5ndE9wdGlvbnMucm93U2VsZWN0aW9uSW5pdGlhbFN0YXRlO1xuXHRcdFx0XHRpZiAoc2VsZWN0ZWQpIHtcblx0XHRcdFx0XHRpZiAodHlwZW9mIHRoaXMubWV0YUluZm9bcm93LiQkZ3RSb3dJZF0gPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRcdFx0XHR0aGlzLm1ldGFJbmZvW3Jvdy4kJGd0Um93SWRdID0geyBpc1NlbGVjdGVkOiB0cnVlIH07XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRoaXMubWV0YUluZm9bcm93LiQkZ3RSb3dJZF0uaXNTZWxlY3RlZCA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRoaXMuc2VsZWN0ZWRSb3dzLnB1c2gocm93KTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdGlmIChcblx0XHRcdHRoaXMuZ3RPcHRpb25zLnJvd0V4cGFuZEluaXRpYWxTdGF0ZSAmJlxuXHRcdFx0dGhpcy5ndE9wdGlvbnMucm93RXhwYW5kSW5pdGlhbENvbXBvbmVudFxuXHRcdCkge1xuXHRcdFx0ZGF0YS5tYXAocm93ID0+IHtcblx0XHRcdFx0Y29uc3QgZXhwYW5kZWQgPVxuXHRcdFx0XHRcdHR5cGVvZiB0aGlzLmd0T3B0aW9ucy5yb3dFeHBhbmRJbml0aWFsU3RhdGUgPT09ICdmdW5jdGlvbidcblx0XHRcdFx0XHRcdD8gdGhpcy5ndE9wdGlvbnMucm93RXhwYW5kSW5pdGlhbFN0YXRlKHJvdylcblx0XHRcdFx0XHRcdDogdGhpcy5ndE9wdGlvbnMucm93RXhwYW5kSW5pdGlhbFN0YXRlO1xuXHRcdFx0XHR0aGlzLmV4cGFuZGVkUm93ID0gdGhpcy5ndE9wdGlvbnMucm93RXhwYW5kSW5pdGlhbENvbXBvbmVudDtcblxuXHRcdFx0XHRpZiAoZXhwYW5kZWQpIHtcblx0XHRcdFx0XHRpZiAodHlwZW9mIHRoaXMubWV0YUluZm9bcm93LiQkZ3RSb3dJZF0gPT09ICd1bmRlZmluZWQnKSB7XG5cdFx0XHRcdFx0XHR0aGlzLm1ldGFJbmZvW3Jvdy4kJGd0Um93SWRdID0geyBpc09wZW46IHRydWUgfTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dGhpcy5tZXRhSW5mb1tyb3cuJCRndFJvd0lkXS5pc09wZW4gPSB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdHRoaXMuX2d0RGF0YSA9IGRhdGE7XG5cdH1cblxuXHRASW5wdXQoKVxuXHRzZXQgZ3RSb3dDb21wb25lbnQodmFsdWU6IFR5cGU8Qz4pIHtcblx0XHRjb25zb2xlLndhcm4oXG5cdFx0XHQnR3RSb3dDb21wb25lbnQgaGFzIGJlZW4gZGVwcmVjYXRlZCBhbmQgc3VwcG9ydCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgcmVsZWFzZSwgc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9oamFsbWVycy9hbmd1bGFyLWdlbmVyaWMtdGFibGUvaXNzdWVzLzM0J1xuXHRcdCk7XG5cdFx0dGhpcy5fZ3RSb3dDb21wb25lbnQgPSB2YWx1ZTtcblx0fVxuXG5cdHB1YmxpYyBjb2x1bW5XaWR0aDogT2JqZWN0ID0ge307XG5cdHB1YmxpYyBjb25maWdPYmplY3Q6IEd0Q29uZmlnPFI+O1xuXHRwdWJsaWMgc29ydE9yZGVyOiBBcnJheTxhbnk+ID0gW107XG5cdHB1YmxpYyBtZXRhSW5mbzogeyBbZ3RSb3dJZDogc3RyaW5nXTogR3RSb3dNZXRhIH0gPSB7fTtcblx0cHVibGljIHNlbGVjdGVkUm93czogQXJyYXk8R3RSb3c+ID0gW107XG5cdHB1YmxpYyBvcGVuUm93czogQXJyYXk8R3RSb3c+ID0gW107XG5cdHByaXZhdGUgX2d0U2V0dGluZ3M6IEd0Q29uZmlnU2V0dGluZ1tdID0gW107XG5cdHByaXZhdGUgX2d0RmllbGRzOiBHdENvbmZpZ0ZpZWxkPFIsIGFueT5bXSA9IFtdO1xuXHRwcml2YXRlIF9ndERhdGE6IEFycmF5PGFueT47XG5cdHByaXZhdGUgX2d0VG90YWxzOiBhbnk7XG5cdHByaXZhdGUgX2d0Um93Q29tcG9uZW50OiBUeXBlPEM+O1xuXHRwdWJsaWMgZXhwYW5kZWRSb3c6IHtcblx0XHRjb21wb25lbnQ6IFR5cGU8Qz47XG5cdFx0ZGF0YT86IEFycmF5PGFueT47XG5cdH07XG5cdHB1YmxpYyBndERlZmF1bHRUZXh0czogR3RUZXh0cyA9IHtcblx0XHRsb2FkaW5nOiAnTG9hZGluZy4uLicsXG5cdFx0bm9EYXRhOiAnTm8gZGF0YScsXG5cdFx0bm9NYXRjaGluZ0RhdGE6ICdObyBkYXRhIG1hdGNoaW5nIHJlc3VsdHMgZm91bmQnLFxuXHRcdG5vVmlzaWJsZUNvbHVtbnNIZWFkaW5nOiAnTm8gdmlzaWJsZSBjb2x1bW5zJyxcblx0XHRub1Zpc2libGVDb2x1bW5zOiAnUGxlYXNlIHNlbGVjdCBhdCBsZWFzdCBvbmUgY29sdW1uIHRvIGJlIHZpc2libGUuJyxcblx0XHR0YWJsZUluZm86XG5cdFx0XHQnU2hvd2luZyAjcmVjb3JkRnJvbSB0byAjcmVjb3JkVG8gb2YgI3JlY29yZHNBZnRlclNlYXJjaCBlbnRyaWVzLicsXG5cdFx0dGFibGVJbmZvQWZ0ZXJTZWFyY2g6XG5cdFx0XHQnU2hvd2luZyAgI3JlY29yZEZyb20gdG8gI3JlY29yZFRvIG9mICNyZWNvcmRzQWZ0ZXJTZWFyY2ggZW50cmllcyAoZmlsdGVyZWQgZnJvbSBhIHRvdGFsIG9mICNyZWNvcmRzQWxsIGVudHJpZXMpLicsXG5cdFx0Y3N2RG93bmxvYWQ6ICdkb3dubG9hZCcsXG5cdFx0c29ydExhYmVsOiAnU29ydDonLFxuXHRcdHBhZ2luYXRlTmV4dDogJ05leHQgcGFnZScsXG5cdFx0cGFnaW5hdGVQcmV2aW91czogJ1ByZXZpb3VzIHBhZ2UnLFxuXHRcdGlubGluZUVkaXRFZGl0ZWQ6ICdQcmVzcyBlbnRlciB0byBzYXZlJ1xuXHR9O1xuXHRASW5wdXQoKSBndFRleHRzOiBHdFRleHRzID0gdGhpcy5ndERlZmF1bHRUZXh0cztcblx0QElucHV0KCkgZ3RDbGFzc2VzOiBzdHJpbmc7XG5cdEBPdXRwdXQoKSBndEV2ZW50OiBFdmVudEVtaXR0ZXI8R3RFdmVudD4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cdHB1YmxpYyBndERlZmF1bHRPcHRpb25zOiBHdE9wdGlvbnMgPSB7XG5cdFx0Y3N2RGVsaW1pdGVyOiAnOycsXG5cdFx0c3RhY2s6IGZhbHNlLFxuXHRcdGxhenlMb2FkOiBmYWxzZSxcblx0XHRjYWNoZTogZmFsc2UsXG5cdFx0ZGVib3VuY2VUaW1lOiAyMDAsXG5cdFx0aGlnaGxpZ2h0U2VhcmNoOiBmYWxzZSxcblx0XHRyb3dTZWxlY3Rpb246IGZhbHNlLFxuXHRcdHJvd1NlbGVjdGlvbkFsbG93TXVsdGlwbGU6IHRydWUsXG5cdFx0cm93RXhwYW5kQWxsb3dNdWx0aXBsZTogdHJ1ZSxcblx0XHRudW1iZXJPZlJvd3M6IDEwLFxuXHRcdHJlcG9ydENvbHVtbldpZHRoOiBmYWxzZSxcblx0XHRhbGxvd1Vuc29ydGVkOiB0cnVlLFxuXHRcdG11dGF0ZURhdGE6IHRydWVcblx0fTtcblx0cHJpdmF0ZSBfZ3RPcHRpb25zOiBHdE9wdGlvbnMgPSB0aGlzLmd0RGVmYXVsdE9wdGlvbnM7XG5cdHB1YmxpYyBzdG9yZTogQXJyYXk8YW55PiA9IFtdO1xuXHRwdWJsaWMgbG9hZGluZyA9IHRydWU7XG5cdHByaXZhdGUgZGVib3VuY2VUaW1lcjogdm9pZCA9IG51bGw7XG5cdHB1YmxpYyBsb2FkaW5nUHJvcGVydHk6IHN0cmluZztcblx0cHVibGljIGxhenlBbGxTZWxlY3RlZCA9IGZhbHNlO1xuXG5cdEBJbnB1dCgpXG5cdGd0SW5mbzogR3RJbmZvcm1hdGlvbiA9IHtcblx0XHRwYWdlQ3VycmVudDogMSxcblx0XHRwYWdlVG90YWw6IDAsXG5cdFx0cmVjb3JkRnJvbTogMCxcblx0XHRyZWNvcmRUbzogMCxcblx0XHRyZWNvcmRMZW5ndGg6IHRoaXMuZ3RPcHRpb25zLm51bWJlck9mUm93cyxcblx0XHRyZWNvcmRzQWxsOiAwLFxuXHRcdHJlY29yZHNBZnRlckZpbHRlcjogMCxcblx0XHRyZWNvcmRzQWZ0ZXJTZWFyY2g6IDBcblx0fTtcblxuXHRwdWJsaWMgcmVmcmVzaFBpcGUgPSBmYWxzZTtcblx0cHVibGljIHJlZnJlc2hUb3RhbHMgPSBmYWxzZTtcblx0cHVibGljIHJlZnJlc2hTb3J0aW5nID0gZmFsc2U7XG5cdHB1YmxpYyByZWZyZXNoRmlsdGVyID0gZmFsc2U7XG5cdHB1YmxpYyByZWZyZXNoUGFnZUFycmF5ID0gZmFsc2U7XG5cdHByaXZhdGUgZ2xvYmFsSW5saW5lRWRpdExpc3RlbmVyOiBGdW5jdGlvbjtcblx0cHVibGljIGVkaXRlZFJvd3M6IHtcblx0XHRba2V5OiBzdHJpbmddOiB7XG5cdFx0XHRjaGFuZ2VzOiB7IFtrZXk6IHN0cmluZ106IEd0UmVuZGVyRmllbGQ8R3RSb3csIGFueT4gfTtcblx0XHRcdHJvdzogR3RSb3c7XG5cdFx0fTtcblx0fSA9IHt9O1xuXG5cdHB1YmxpYyBkYXRhOiB7IGV4cG9ydERhdGE6IEFycmF5PGFueT4gfSA9IHsgZXhwb3J0RGF0YTogW10gfTsgLy8gU3RvcmUgZmlsdGVyZWQgZGF0YSBmb3IgZXhwb3J0XG5cblx0Y29uc3RydWN0b3IocHJpdmF0ZSByZW5kZXJlcjogUmVuZGVyZXIyLCBwcml2YXRlIGd0TWV0YVBpcGU6IEd0TWV0YVBpcGUpIHtcblx0XHR0aGlzLmd0RXZlbnQuc3Vic2NyaWJlKCgkZXZlbnQ6IEd0RXZlbnQpID0+IHtcblx0XHRcdGlmICgkZXZlbnQubmFtZSA9PT0gJ2d0LWluZm8nKSB7XG5cdFx0XHRcdHRoaXMudXBkYXRlUmVjb3JkUmFuZ2UoKTtcblx0XHRcdH1cblx0XHRcdGlmICgkZXZlbnQubmFtZSA9PT0gJ2d0LXJvdy11cGRhdGVkJykge1xuXHRcdFx0XHR0aGlzLnVwZGF0ZVRvdGFscygpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNvcnQgdGFibGUgYnkgb2JqZWN0IGtleS5cblx0ICogQHBhcmFtIG9iamVjdEtleSAtIG5hbWUgb2Yga2V5IHRvIHNvcnQgb24uXG5cdCAqIEBwYXJhbSBldmVudCAtIHN1Y2ggYXMga2V5IHByZXNzIGR1cmluZyBzb3J0aW5nLlxuXHQgKi9cblx0cHVibGljIGd0U29ydCA9IGZ1bmN0aW9uKG9iamVjdEtleTogc3RyaW5nLCBldmVudDogYW55KSB7XG5cdFx0dGhpcy5pbmxpbmVFZGl0Q2FuY2VsKCk7IC8vIGNhbmNlbCBpbmxpbmUgZWRpdGluZ1xuXG5cdFx0Ly8gbG9vcCB0aHJvdWdoIGN1cnJlbnQgc2V0dGluZ3Ncblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2d0U2V0dGluZ3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmICh0aGlzLl9ndFNldHRpbmdzW2ldLm9iamVjdEtleSA9PT0gb2JqZWN0S2V5KSB7XG5cdFx0XHRcdC8vIGNoZWNrIGlmIHNvcnRpbmcgaXMgZGlzYWJsZWQuLi5cblx0XHRcdFx0aWYgKFxuXHRcdFx0XHRcdHRoaXMuX2d0U2V0dGluZ3NbaV0uc29ydCAmJlxuXHRcdFx0XHRcdHRoaXMuX2d0U2V0dGluZ3NbaV0uc29ydC5pbmRleE9mKCdkaXNhYmxlJykgIT09IC0xXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdC8vIC4uLmlmIHNvLCBleGl0IGZ1bmN0aW9uIHdpdGhvdXQgYXBwbHlpbmcgYW55IHNvcnRpbmdcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH0gZWxzZSBpZiAoXG5cdFx0XHRcdFx0LyogY2hlY2sgaWYgc29ydGluZyBpcyB1bmRlZmluZWQuLi4gKi8gdHlwZW9mIHRoaXMuX2d0U2V0dGluZ3NbaV1cblx0XHRcdFx0XHRcdC5zb3J0ID09PSAndW5kZWZpbmVkJ1xuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHQvLyAuLi5pcyBzbywgc2V0IHNvcnRpbmcgcHJvcGVydHkgdG8gZW5hYmxlXG5cdFx0XHRcdFx0dGhpcy5fZ3RTZXR0aW5nc1tpXS5zb3J0ID0gJ2VuYWJsZSc7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBjaGVjayBsZW5ndGhcblx0XHRjb25zdCBjdHJsS2V5ID0gZXZlbnQubWV0YUtleSB8fCBldmVudC5jdHJsS2V5O1xuXHRcdGNvbnN0IHNvcnQgPSB0aGlzLnNvcnRPcmRlci5zbGljZSgwKTtcblxuXHRcdGxldCBtYXRjaCA9IC0xO1xuXHRcdGxldCBtYXRjaERlc2MgPSAtMTtcblx0XHRsZXQgcG9zID0gLTE7XG5cblx0XHQvLyBjaGVjayBpZiBwcm9wZXJ0eSBhbHJlYWR5IGV4aXRzXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBzb3J0Lmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRjb25zdCBoaXQgPSBzb3J0W2ldLmluZGV4T2Yob2JqZWN0S2V5KTtcblx0XHRcdGlmIChoaXQgIT09IC0xKSB7XG5cdFx0XHRcdG1hdGNoID0gdGhpcy5zb3J0T3JkZXIuaW5kZXhPZihvYmplY3RLZXkpO1xuXHRcdFx0XHRtYXRjaERlc2MgPVxuXHRcdFx0XHRcdG1hdGNoID09PSAtMSA/IHRoaXMuc29ydE9yZGVyLmluZGV4T2YoJy0nICsgb2JqZWN0S2V5KSA6IG1hdGNoO1xuXHRcdFx0XHRwb3MgPSBNYXRoLm1heChtYXRjaCwgbWF0Y2hEZXNjKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBpZiBjdHJsIGtleSBvciBtZXRhIGtleSBpcyBwcmVzcyB0b2dldGhlciB3aXRoIHNvcnQuLi5cblx0XHRpZiAoY3RybEtleSkge1xuXHRcdFx0aWYgKHRoaXMuc29ydE9yZGVyW3RoaXMuc29ydE9yZGVyLmxlbmd0aCAtIDFdID09PSAnJCRndEluaXRpYWxSb3dJbmRleCcpIHtcblx0XHRcdFx0dGhpcy5zb3J0T3JkZXIucG9wKCk7XG5cdFx0XHR9XG5cdFx0XHRzd2l0Y2ggKHBvcykge1xuXHRcdFx0XHQvLyAuLi5hbmQgcHJvcGVydHkgaXMgbm90IHNvcnRlZCBiZWZvcmUuLi5cblx0XHRcdFx0Y2FzZSAtMTpcblx0XHRcdFx0XHQvLyAuLi5hZGQgcHJvcGVydHkgdG8gc29ydGluZ1xuXHRcdFx0XHRcdHRoaXMuc29ydE9yZGVyLnB1c2gob2JqZWN0S2V5KTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHQvLyAuLi5hbmQgcHJvcGVydHkgaXMgc29ydGVkIGJlZm9yZS4uLlxuXHRcdFx0XHRcdGlmIChtYXRjaCAhPT0gLTEpIHtcblx0XHRcdFx0XHRcdC8vIC4uLmNoYW5nZSBmcm9tIGFzYyB0byBkZXNjIGlmIHNvcnRlZCBhc2Ncblx0XHRcdFx0XHRcdHRoaXMuc29ydE9yZGVyW3Bvc10gPSAnLScgKyBvYmplY3RLZXk7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICh0aGlzLnNvcnRPcmRlci5sZW5ndGggPiAxKSB7XG5cdFx0XHRcdFx0XHQvLyAuLi5yZW1vdmUgc29ydGluZyBpZiBzb3J0ZWQgZGVzY1xuXHRcdFx0XHRcdFx0aWYgKGN0cmxLZXkpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5zb3J0T3JkZXJbcG9zXSA9IG9iamVjdEtleTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuc29ydE9yZGVyLnNwbGljZShwb3MsIDEpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSBpZiAodGhpcy5zb3J0T3JkZXIubGVuZ3RoID09PSAxKSB7XG5cdFx0XHRcdFx0XHQvLyAuLi5zZXQgc29ydGluZyB0byBhc2MgaWYgb25seSBzb3J0ZWQgcHJvcGVydHlcblx0XHRcdFx0XHRcdHRoaXMuc29ydE9yZGVyW3Bvc10gPSBvYmplY3RLZXk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHQvKiBpZiBjdHJsIGtleSBvciBtZXRhIGtleSBpcyBub3QgcHJlc3MgdG9nZXRoZXIgd2l0aCBzb3J0Li4uICovXG5cdFx0XHRzd2l0Y2ggKHBvcykge1xuXHRcdFx0XHQvLyAuLi5hbmQgcHJvcGVydHkgaXMgbm90IHNvcnRlZCBiZWZvcmUuLi5cblx0XHRcdFx0Y2FzZSAtMTpcblx0XHRcdFx0XHQvLyAuLi5zb3J0IGJ5IHByb3BlcnR5XG5cdFx0XHRcdFx0dGhpcy5zb3J0T3JkZXIgPSBbb2JqZWN0S2V5XTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHQvLyAuLi5jaGFuZ2UgZnJvbSBkZXNjIHRvIGFzYyBhbmQgdmlzZSB2ZXJzYVxuXHRcdFx0XHRcdHRoaXMuc29ydE9yZGVyID1cblx0XHRcdFx0XHRcdG1hdGNoICE9PSAtMVxuXHRcdFx0XHRcdFx0XHQ/IFsnLScgKyBvYmplY3RLZXldXG5cdFx0XHRcdFx0XHRcdDogY3RybEtleSB8fCAhdGhpcy5ndE9wdGlvbnMuYWxsb3dVbnNvcnRlZFxuXHRcdFx0XHRcdFx0XHRcdD8gW29iamVjdEtleV1cblx0XHRcdFx0XHRcdFx0XHQ6IFtdO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIHVwZGF0ZSBzZXR0aW5ncyBvYmplY3Qgd2l0aCBuZXcgc29ydGluZyBpbmZvcm1hdGlvblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fZ3RTZXR0aW5ncy5sZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKHRoaXMuX2d0U2V0dGluZ3NbaV0ub2JqZWN0S2V5ID09PSBvYmplY3RLZXkpIHtcblx0XHRcdFx0c3dpdGNoICh0aGlzLl9ndFNldHRpbmdzW2ldLnNvcnQpIHtcblx0XHRcdFx0XHQvLyBpZiBzb3J0ZWQgYXNjLi4uXG5cdFx0XHRcdFx0Y2FzZSAnYXNjJzpcblx0XHRcdFx0XHRcdC8vIC4uLmNoYW5nZSB0byBkZXNjXG5cdFx0XHRcdFx0XHR0aGlzLl9ndFNldHRpbmdzW2ldLnNvcnQgPSAnZGVzYyc7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHQvLyBpZiBzb3J0ZWQgZGVzYy4uLlxuXHRcdFx0XHRcdGNhc2UgJ2Rlc2MnOlxuXHRcdFx0XHRcdFx0Ly8gLi4uY2hhbmdlIHRvIGFzYyBpZiBpdCdzIHRoZSBvbmx5IHNvcnRlZCBwcm9wZXJ0eSBvdGhlcndpc2UgcmVtb3ZlIHNvcnRpbmdcblx0XHRcdFx0XHRcdHRoaXMuX2d0U2V0dGluZ3NbaV0uc29ydCA9XG5cdFx0XHRcdFx0XHRcdCh0aGlzLnNvcnRPcmRlci5sZW5ndGggPT09IDEgJiYgc29ydC5sZW5ndGggPCAyKSB8fFxuXHRcdFx0XHRcdFx0XHRjdHJsS2V5IHx8XG5cdFx0XHRcdFx0XHRcdCF0aGlzLmd0T3B0aW9ucy5hbGxvd1Vuc29ydGVkXG5cdFx0XHRcdFx0XHRcdFx0PyAnYXNjJ1xuXHRcdFx0XHRcdFx0XHRcdDogJ2VuYWJsZSc7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHQvLyBpZiBzb3J0aW5nIGVuYWJsZWQuLi5cblx0XHRcdFx0XHRjYXNlICdlbmFibGUnOlxuXHRcdFx0XHRcdFx0Ly8gLi4uY2hhbmdlIHRvIGFzY1xuXHRcdFx0XHRcdFx0dGhpcy5fZ3RTZXR0aW5nc1tpXS5zb3J0ID0gJ2FzYyc7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLl9ndFNldHRpbmdzW2ldLnNvcnRPcmRlciA9XG5cdFx0XHRcdFx0dGhpcy5fZ3RTZXR0aW5nc1tpXS5zb3J0ID09PSAnZW5hYmxlJ1xuXHRcdFx0XHRcdFx0PyB0aGlzLl9ndFNldHRpbmdzLmxlbmd0aCAtIDFcblx0XHRcdFx0XHRcdDogdGhpcy5zb3J0T3JkZXIuaW5kZXhPZihvYmplY3RLZXkpID09PSAtMVxuXHRcdFx0XHRcdFx0XHQ/IHRoaXMuc29ydE9yZGVyLmluZGV4T2YoJy0nICsgb2JqZWN0S2V5KVxuXHRcdFx0XHRcdFx0XHQ6IHRoaXMuc29ydE9yZGVyLmluZGV4T2Yob2JqZWN0S2V5KTtcblx0XHRcdH0gZWxzZSBpZiAoXG5cdFx0XHRcdHRoaXMuX2d0U2V0dGluZ3NbaV0uc29ydCAmJlxuXHRcdFx0XHR0aGlzLl9ndFNldHRpbmdzW2ldLnNvcnQuaW5kZXhPZignZGlzYWJsZScpID09PSAtMSAmJlxuXHRcdFx0XHR0aGlzLnNvcnRPcmRlci5pbmRleE9mKHRoaXMuX2d0U2V0dGluZ3NbaV0ub2JqZWN0S2V5KSA9PT0gLTEgJiZcblx0XHRcdFx0dGhpcy5zb3J0T3JkZXIuaW5kZXhPZignLScgKyB0aGlzLl9ndFNldHRpbmdzW2ldLm9iamVjdEtleSkgPT09IC0xXG5cdFx0XHQpIHtcblx0XHRcdFx0dGhpcy5fZ3RTZXR0aW5nc1tpXS5zb3J0ID0gJ2VuYWJsZSc7XG5cdFx0XHRcdHRoaXMuX2d0U2V0dGluZ3NbaV0uc29ydE9yZGVyID0gdGhpcy5fZ3RTZXR0aW5ncy5sZW5ndGggLSAxO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIHJlZnJlc2ggc29ydGluZyBwaXBlXG5cdFx0dGhpcy5yZWZyZXNoU29ydGluZyA9ICF0aGlzLnJlZnJlc2hTb3J0aW5nO1xuXHRcdHRoaXMucmVmcmVzaFBhZ2VBcnJheSA9ICF0aGlzLnJlZnJlc2hQYWdlQXJyYXk7XG5cblx0XHQvLyBzb3J0IGJ5IGluaXRpYWwgc29ydCBvcmRlciBhcyBsYXN0IHJlc29ydFxuXHRcdHRoaXMuc29ydE9yZGVyLnB1c2goJyQkZ3RJbml0aWFsUm93SW5kZXgnKTtcblxuXHRcdC8vIGVtaXQgc29ydCBldmVudFxuXHRcdHRoaXMuZ3RFdmVudC5lbWl0KHtcblx0XHRcdG5hbWU6ICdndC1zb3J0aW5nLWFwcGxpZWQnLFxuXHRcdFx0dmFsdWU6IHRoaXMuc29ydE9yZGVyXG5cdFx0fSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIENoYW5nZSBudW1iZXIgb2Ygcm93cyB0byBiZSBkaXNwbGF5ZWQuXG5cdCAqIEBwYXJhbSByb3dMZW5ndGggLSB0b3RhbCBudW1iZXIgb2Ygcm93cy5cblx0ICogQHBhcmFtIHJlc2V0IC0gc2hvdWxkIHBhZ2UgYmUgcmVzZXQgdG8gZmlyc3QgcGFnZS5cblx0ICovXG5cdHB1YmxpYyBjaGFuZ2VSb3dMZW5ndGggPSBmdW5jdGlvbihyb3dMZW5ndGg6IGFueSwgcmVzZXQ/OiBib29sZWFuKSB7XG5cdFx0bGV0IGxlbmd0aFZhbHVlID0gaXNOYU4ocGFyc2VJbnQocm93TGVuZ3RoLCAxMCkpXG5cdFx0XHQ/IDBcblx0XHRcdDogcGFyc2VJbnQocm93TGVuZ3RoLCAxMCk7XG5cdFx0bGV0IG5ld1Bvc2l0aW9uID0gMTtcblxuXHRcdGlmICghbGVuZ3RoVmFsdWUgJiYgdGhpcy5ndERhdGEpIHtcblx0XHRcdGxlbmd0aFZhbHVlID0gdGhpcy5ndERhdGEubGVuZ3RoO1xuXHRcdH1cblxuXHRcdC8vIGlmIHJlc2V0IGlzIG5vdCB0cnVlIGFuZCB3ZSdyZSBub3QgbGF6eSBsb2FkaW5nIGRhdGEuLi5cblx0XHRpZiAocmVzZXQgIT09IHRydWUgJiYgdGhpcy5fZ3RPcHRpb25zLmxhenlMb2FkICE9PSB0cnVlKSB7XG5cdFx0XHQvLyAuLi5nZXQgY3VycmVudCBwb3NpdGlvbiBpbiByZWNvcmQgc2V0XG5cdFx0XHRjb25zdCBjdXJyZW50UmVjb3JkID1cblx0XHRcdFx0dGhpcy5ndEluZm8ucmVjb3JkTGVuZ3RoICogKHRoaXMuZ3RJbmZvLnBhZ2VDdXJyZW50IC0gMSk7XG5cdFx0XHRjb25zdCBjdXJyZW50UG9zaXRpb24gPVxuXHRcdFx0XHR0aGlzLl9ndERhdGEuaW5kZXhPZih0aGlzLl9ndERhdGFbY3VycmVudFJlY29yZF0pICsgMTtcblxuXHRcdFx0Ly8gLi4uZ2V0IG5ldyBwb3NpdGlvblxuXHRcdFx0bmV3UG9zaXRpb24gPSBNYXRoLmNlaWwoY3VycmVudFBvc2l0aW9uIC8gbGVuZ3RoVmFsdWUpO1xuXHRcdH1cblxuXHRcdC8vIGNoYW5nZSByb3cgbGVuZ3RoXG5cdFx0dGhpcy5ndEluZm8ucmVjb3JkTGVuZ3RoID0gbGVuZ3RoVmFsdWU7XG5cblx0XHQvLyBnbyB0byBuZXcgcG9zaXRpb25cblx0XHR0aGlzLmd0SW5mby5wYWdlQ3VycmVudCA9IG5ld1Bvc2l0aW9uO1xuXG5cdFx0Ly8gaWYgbGF6eSBsb2FkaW5nIGRhdGEuLi5cblx0XHRpZiAodGhpcy5fZ3RPcHRpb25zLmxhenlMb2FkKSB7XG5cdFx0XHQvLyAuLi5yZXBsYWNlIGRhdGEgd2l0aCBwbGFjZSBob2xkZXJzIGZvciBuZXcgZGF0YVxuXHRcdFx0dGhpcy5fZ3REYXRhWzBdID0gdGhpcy5sb2FkaW5nQ29udGVudChsZW5ndGhWYWx1ZSk7XG5cblx0XHRcdC8vIC4uLmVtcHR5IGN1cnJlbnQgc3RvcmVcblx0XHRcdHRoaXMuc3RvcmUgPSBbXTtcblx0XHR9XG5cblx0XHQvLyB0aGlzLnVwZGF0ZVJlY29yZFJhbmdlKCk7XG5cblx0XHR0aGlzLmd0RXZlbnQuZW1pdCh7XG5cdFx0XHRuYW1lOiAnZ3Qtcm93LWxlbmd0aC1jaGFuZ2VkJyxcblx0XHRcdHZhbHVlOiBsZW5ndGhWYWx1ZVxuXHRcdH0pO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBGb3JjZSBhIHJlZHJhdyBvZiB0YWJsZSByb3dzLlxuXHQgKiBBcyB0aGUgdGFibGUgdXNlcyBwdXJlIHBpcGVzLCB3ZSBuZWVkIHRvIGZvcmNlIGEgcmVkcmF3IGlmIGFuIG9iamVjdCBpbiB0aGUgYXJyYXkgaXMgY2hhbmdlZCB0byBzZWUgdGhlIGNoYW5nZXMuXG5cdCAqL1xuXHRwdWJsaWMgcmVkcmF3ID0gZnVuY3Rpb24oJGV2ZW50PzogYW55KSB7XG5cdFx0dGhpcy5yZWZyZXNoU29ydGluZyA9ICF0aGlzLnJlZnJlc2hTb3J0aW5nO1xuXHRcdHRoaXMucmVmcmVzaFBhZ2VBcnJheSA9ICF0aGlzLnJlZnJlc2hQYWdlQXJyYXk7XG5cdFx0dGhpcy5yZWZyZXNoUGlwZSA9ICF0aGlzLnJlZnJlc2hQaXBlO1xuXHR9O1xuXG5cdC8qKiBVcGRhdGUgcmVjb3JkIHJhbmdlLiAqL1xuXHRwcml2YXRlIHVwZGF0ZVJlY29yZFJhbmdlKCkge1xuXHRcdHRoaXMuZ3RJbmZvLnJlY29yZEZyb20gPVxuXHRcdFx0dGhpcy5ndEluZm8ucmVjb3Jkc0FmdGVyU2VhcmNoID09PSAwXG5cdFx0XHRcdD8gMFxuXHRcdFx0XHQ6ICh0aGlzLmd0SW5mby5wYWdlQ3VycmVudCAtIDEpICogdGhpcy5ndEluZm8ucmVjb3JkTGVuZ3RoICsgMTtcblx0XHR0aGlzLmd0SW5mby5yZWNvcmRUbyA9XG5cdFx0XHR0aGlzLmd0SW5mby5yZWNvcmRzQWZ0ZXJTZWFyY2ggPFxuXHRcdFx0dGhpcy5ndEluZm8ucGFnZUN1cnJlbnQgKiB0aGlzLmd0SW5mby5yZWNvcmRMZW5ndGhcblx0XHRcdFx0PyB0aGlzLmd0SW5mby5yZWNvcmRzQWZ0ZXJTZWFyY2hcblx0XHRcdFx0OiB0aGlzLmd0SW5mby5wYWdlQ3VycmVudCAqIHRoaXMuZ3RJbmZvLnJlY29yZExlbmd0aDtcblx0fVxuXG5cdC8qKiBVcGRhdGUgdG90YWxzLiAqL1xuXHRwcml2YXRlIHVwZGF0ZVRvdGFscygpIHtcblx0XHR0aGlzLnJlZnJlc2hUb3RhbHMgPSAhdGhpcy5yZWZyZXNoVG90YWxzO1xuXHR9XG5cblx0LyoqIEdvIHRvIG5leHQgcGFnZS4gKi9cblx0cHVibGljIG5leHRQYWdlID0gZnVuY3Rpb24oKSB7XG5cdFx0Y29uc3QgcGFnZSA9XG5cdFx0XHR0aGlzLmd0SW5mby5wYWdlQ3VycmVudCA9PT0gdGhpcy5ndEluZm8ucGFnZVRvdGFsXG5cdFx0XHRcdD8gdGhpcy5ndEluZm8ucGFnZVRvdGFsXG5cdFx0XHRcdDogdGhpcy5ndEluZm8ucGFnZUN1cnJlbnQgKyAxO1xuXHRcdHRoaXMuZ29Ub1BhZ2UocGFnZSk7XG5cdH07XG5cblx0LyoqIEdvIHRvIHByZXZpb3VzIHBhZ2UuICovXG5cdHB1YmxpYyBwcmV2aW91c1BhZ2UgPSBmdW5jdGlvbigpIHtcblx0XHRjb25zdCBwYWdlID1cblx0XHRcdHRoaXMuZ3RJbmZvLnBhZ2VDdXJyZW50ID09PSAxID8gMSA6IHRoaXMuZ3RJbmZvLnBhZ2VDdXJyZW50IC0gMTtcblx0XHR0aGlzLmdvVG9QYWdlKHBhZ2UpO1xuXHR9O1xuXG5cdC8qKiBSZXF1ZXN0IG1vcmUgZGF0YSAodXNlZCB3aGVuIGxhenkgbG9hZGluZykgKi9cblx0cHJpdmF0ZSBnZXREYXRhID0gZnVuY3Rpb24oKSB7XG5cdFx0Ly8gLi4uZW1pdCBldmVudCByZXF1ZXN0aW5nIGZvciBtb3JlIGRhdGFcblx0XHR0aGlzLmd0RXZlbnQuZW1pdCh7XG5cdFx0XHRuYW1lOiAnZ3QtcGFnZS1jaGFuZ2VkLWxhenknLFxuXHRcdFx0dmFsdWU6IHtcblx0XHRcdFx0cGFnZUN1cnJlbnQ6IHRoaXMuZ3RJbmZvLnBhZ2VDdXJyZW50LFxuXHRcdFx0XHRyZWNvcmRMZW5ndGg6IHRoaXMuZ3RJbmZvLnJlY29yZExlbmd0aFxuXHRcdFx0fVxuXHRcdH0pO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBHbyB0byBzcGVjaWZpYyBwYWdlLlxuXHQgKiBAcGFyYW0gcGFnZSAtIHBhZ2UgbnVtYmVyLlxuXHQgKi9cblx0cHVibGljIGdvVG9QYWdlID0gZnVuY3Rpb24ocGFnZTogbnVtYmVyKSB7XG5cdFx0Y29uc3QgcHJldmlvdXNQYWdlID0gdGhpcy5ndEluZm8ucGFnZUN1cnJlbnQ7XG5cdFx0dGhpcy5ndEluZm8ucGFnZUN1cnJlbnQgPSBwYWdlO1xuXHRcdHRoaXMuaW5saW5lRWRpdENhbmNlbCgpOyAvLyBjYW5jZWwgaW5saW5lIGVkaXRcblxuXHRcdC8vIGlmIGxhenkgbG9hZGluZyBhbmQgaWYgcGFnZSBjb250YWlucyBubyByZWNvcmRzLi4uXG5cdFx0aWYgKHRoaXMuX2d0T3B0aW9ucy5sYXp5TG9hZCkge1xuXHRcdFx0Ly8gLi4uaWYgZGF0YSBmb3IgY3VycmVudCBwYWdlIGNvbnRhaW5zIG5vIGVudHJpZXMuLi5cblx0XHRcdGlmIChcblx0XHRcdFx0dGhpcy5fZ3RPcHRpb25zLmNhY2hlID09PSBmYWxzZSB8fFxuXHRcdFx0XHR0aGlzLl9ndERhdGFbdGhpcy5ndEluZm8ucGFnZUN1cnJlbnQgLSAxXS5sZW5ndGggPT09IDBcblx0XHRcdCkge1xuXHRcdFx0XHQvLyAuLi5jcmVhdGUgdGVtcG9yYXJ5IGNvbnRlbnQgd2hpbGUgd2FpdGluZyBmb3IgZGF0YVxuXHRcdFx0XHR0aGlzLl9ndERhdGFbdGhpcy5ndEluZm8ucGFnZUN1cnJlbnQgLSAxXSA9IHRoaXMubG9hZGluZ0NvbnRlbnQoXG5cdFx0XHRcdFx0dGhpcy5ndEluZm8ucmVjb3JkTGVuZ3RoXG5cdFx0XHRcdCk7XG5cdFx0XHRcdHRoaXMubG9hZGluZyA9IHRydWU7IC8vIGxvYWRpbmcgdHJ1ZVxuXHRcdFx0fVxuXHRcdFx0Ly8gLi4uaWYgZmlyc3QgZW50cnkgaW4gY3VycmVudCBwYWdlIGVxdWFscyBvdXIgbG9hZGluZyBwbGFjZWhvbGRlci4uLlxuXHRcdFx0aWYgKFxuXHRcdFx0XHR0aGlzLl9ndERhdGFbdGhpcy5ndEluZm8ucGFnZUN1cnJlbnQgLSAxXVswXVt0aGlzLmxvYWRpbmdQcm9wZXJ0eV0gPT09XG5cdFx0XHRcdHRoaXMuZ3RUZXh0cy5sb2FkaW5nXG5cdFx0XHQpIHtcblx0XHRcdFx0Ly8gLi4uZ2V0IGRhdGFcblx0XHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMuZGVib3VuY2VUaW1lcik7XG5cdFx0XHRcdHRoaXMuZGVib3VuY2VUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuXHRcdFx0XHRcdHRoaXMuZ2V0RGF0YSgpO1xuXHRcdFx0XHR9LCB0aGlzLl9ndE9wdGlvbnMuZGVib3VuY2VUaW1lKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyB0aGlzLnVwZGF0ZVJlY29yZFJhbmdlKCk7XG5cblx0XHQvLyAuLi5lbWl0IHBhZ2UgY2hhbmdlIGV2ZW50XG5cdFx0aWYgKHByZXZpb3VzUGFnZSAhPT0gcGFnZSkge1xuXHRcdFx0dGhpcy5ndEV2ZW50LmVtaXQoe1xuXHRcdFx0XHRuYW1lOiAnZ3QtcGFnZS1jaGFuZ2VkJyxcblx0XHRcdFx0dmFsdWU6IHtcblx0XHRcdFx0XHRwYWdlQ3VycmVudDogdGhpcy5ndEluZm8ucGFnZUN1cnJlbnQsXG5cdFx0XHRcdFx0cGFnZVByZXZpb3VzOiBwcmV2aW91c1BhZ2UsXG5cdFx0XHRcdFx0cmVjb3JkTGVuZ3RoOiB0aGlzLmd0SW5mby5yZWNvcmRMZW5ndGhcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBHZXQgbWV0YSBkYXRhIGZvciByb3cuXG5cdCAqL1xuXHRwdWJsaWMgZ2V0Um93U3RhdGUocm93OiBSKTogR3RSb3dNZXRhIHtcblx0XHRyZXR1cm4gdHlwZW9mIHRoaXMubWV0YUluZm9bcm93LiQkZ3RSb3dJZF0gPT09ICd1bmRlZmluZWQnXG5cdFx0XHQ/IG51bGxcblx0XHRcdDogdGhpcy5tZXRhSW5mb1tyb3cuJCRndFJvd0lkXTtcblx0fVxuXG5cdC8qKlxuXHQgKiBFeHBhbmQgYWxsIHJvd3MuXG5cdCAqIEBwYXJhbSBleHBhbmRlZFJvdyAtIGNvbXBvbmVudCB0byByZW5kZXIgd2hlbiByb3dzIGFyZSBleHBhbmRlZC5cblx0ICovXG5cdHB1YmxpYyBleHBhbmRBbGxSb3dzKGV4cGFuZGVkUm93OiB7IGNvbXBvbmVudDogVHlwZTxDPjsgZGF0YT86IGFueSB9KTogdm9pZCB7XG5cdFx0dGhpcy5leHBhbmRlZFJvdyA9IGV4cGFuZGVkUm93O1xuXHRcdHRoaXMuX3RvZ2dsZUFsbFJvd1Byb3BlcnR5KCdpc09wZW4nLCB0cnVlKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb2xsYXBzZSBhbGwgcm93cy5cblx0ICovXG5cdHB1YmxpYyBjb2xsYXBzZUFsbFJvd3MoKTogdm9pZCB7XG5cdFx0dGhpcy5fdG9nZ2xlQWxsUm93UHJvcGVydHkoJ2lzT3BlbicsIGZhbHNlKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZWxlY3QgYWxsIHJvd3MuXG5cdCAqL1xuXHRwdWJsaWMgc2VsZWN0QWxsUm93cygpOiB2b2lkIHtcblx0XHR0aGlzLl90b2dnbGVBbGxSb3dQcm9wZXJ0eSgnaXNTZWxlY3RlZCcsIHRydWUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIERlc2VsZWN0IGFsbCByb3dzLlxuXHQgKi9cblx0cHVibGljIGRlc2VsZWN0QWxsUm93cygpOiB2b2lkIHtcblx0XHR0aGlzLl90b2dnbGVBbGxSb3dQcm9wZXJ0eSgnaXNTZWxlY3RlZCcsIGZhbHNlKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBUb2dnbGUgYWxsIHJvd3MuXG5cdCAqL1xuXHRwdWJsaWMgdG9nZ2xlQWxsUm93cygpOiB2b2lkIHtcblx0XHRpZiAodGhpcy5fZ3RPcHRpb25zLmxhenlMb2FkKSB7XG5cdFx0XHRpZiAoIXRoaXMubGF6eUFsbFNlbGVjdGVkIHx8IHRoaXMuc2VsZWN0ZWRSb3dzLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0XHR0aGlzLnNlbGVjdEFsbFJvd3MoKTtcblx0XHRcdFx0dGhpcy5sYXp5QWxsU2VsZWN0ZWQgPSB0cnVlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5kZXNlbGVjdEFsbFJvd3MoKTtcblx0XHRcdFx0dGhpcy5sYXp5QWxsU2VsZWN0ZWQgPSBmYWxzZTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKHRoaXMuc2VsZWN0ZWRSb3dzLmxlbmd0aCAhPT0gdGhpcy5ndERhdGEubGVuZ3RoKSB7XG5cdFx0XHRcdHRoaXMuc2VsZWN0QWxsUm93cygpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5kZXNlbGVjdEFsbFJvd3MoKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKipcblx0ICogVG9nZ2xlIHJvdyBjb2xsYXBzZWQgc3RhdGUgaWUuIGV4cGFuZGVkL29wZW4gb3IgY29sbGFwc2VkL2Nsb3NlZC5cblx0ICogQHBhcmFtIHJvdyAtIHJvdyBvYmplY3QgdGhhdCBzaG91bGQgYmUgZXhwYW5kZWQvY29sbGFwc2VkLlxuXHQgKiBAcGFyYW0gZXhwYW5kZWRSb3cgLSBjb21wb25lbnQgdG8gcmVuZGVyIHdoZW4gcm93IGlzIGV4cGFuZGVkLlxuXHQgKi9cblx0cHVibGljIHRvZ2dsZUNvbGxhcHNlKFxuXHRcdHJvdzogR3RSb3csXG5cdFx0ZXhwYW5kZWRSb3c/OiB7IGNvbXBvbmVudDogVHlwZTxDPjsgZGF0YT86IGFueSB9XG5cdCkge1xuXHRcdGlmIChleHBhbmRlZFJvdykge1xuXHRcdFx0dGhpcy5leHBhbmRlZFJvdyA9IGV4cGFuZGVkUm93O1xuXHRcdH1cblx0XHR0aGlzLl90b2dnbGVSb3dQcm9wZXJ0eShyb3csICdpc09wZW4nKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBUb2dnbGUgcm93IHNlbGVjdGVkIHN0YXRlIGllLiBzZWxlY3RlZCBvciBub3QuXG5cdCAqIEBwYXJhbSByb3cgLSByb3cgb2JqZWN0IHRoYXQgc2hvdWxkIGJlIHNlbGVjdGVkL2Rlc2VsZWN0ZWQuXG5cdCAqL1xuXHRwdWJsaWMgdG9nZ2xlU2VsZWN0KHJvdzogR3RSb3cpIHtcblx0XHR0aGlzLl90b2dnbGVSb3dQcm9wZXJ0eShyb3csICdpc1NlbGVjdGVkJyk7XG5cdH1cblxuXHRwdWJsaWMgcm93Q2xpY2socm93OiBHdFJvdywgJGV2ZW50OiBNb3VzZUV2ZW50KSB7XG5cdFx0dGhpcy5ndEV2ZW50LmVtaXQoe1xuXHRcdFx0bmFtZTogJ2d0LXJvdy1jbGlja2VkJyxcblx0XHRcdHZhbHVlOiB7IHJvdzogcm93LCBldmVudDogJGV2ZW50IH1cblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBVcGRhdGUgcm93IGRhdGEuXG5cdCAqIEBwYXJhbSByb3cgLSByb3cgb2JqZWN0IHRoYXQgaGFzIGJlZW4gZWRpdGVkLlxuXHQgKiBAcGFyYW0gb2xkVmFsdWUgLSByb3cgb2JqZWN0IGJlZm9yZSBlZGl0LlxuXHQgKi9cblx0cHVibGljIHVwZGF0ZVJvdyhyb3c6IEd0Um93LCBvbGRWYWx1ZTogR3RSb3cpIHtcblx0XHR0aGlzLl90b2dnbGVSb3dQcm9wZXJ0eShyb3csICdpc1VwZGF0ZWQnLCBvbGRWYWx1ZSk7XG5cdH1cblxuXHQvKipcblx0ICogcmVtb3ZlcyBhIHJvdyBmcm9tIHRoZSB0YWJsZVxuXHQgKiBAcGFyYW0gcm93IC0gdGhlIHJvdyBvYmplY3QgdG8gcmVtb3ZlXG5cdCAqL1xuXHRwdWJsaWMgcmVtb3ZlUm93KHJvdzogR3RSb3cpIHtcblx0XHRpZiAodGhpcy5pc1Jvd1NlbGVjdGVkKHJvdykpIHtcblx0XHRcdHRoaXMudG9nZ2xlU2VsZWN0KHJvdyk7XG5cdFx0fVxuXHRcdGNvbnN0IGluZGV4ID0gdGhpcy5fZ3REYXRhLmluZGV4T2Yocm93KTtcblx0XHR0aGlzLl9ndERhdGEuc3BsaWNlKGluZGV4LCAxKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBjaGVjayBpZiBhIHJvdyBpcyBzZWxlY3RlZFxuXHQgKiBAcGFyYW0gcm93IC0gcm93IG9iamVjdFxuXHQgKi9cblx0cHVibGljIGlzUm93U2VsZWN0ZWQocm93OiBHdFJvdyk6IGJvb2xlYW4ge1xuXHRcdHJldHVybiAoXG5cdFx0XHR0aGlzLm1ldGFJbmZvW3Jvdy4kJGd0Um93SWRdICYmIHRoaXMubWV0YUluZm9bcm93LiQkZ3RSb3dJZF0uaXNTZWxlY3RlZFxuXHRcdCk7XG5cdH1cblxuXHQvKipcblx0ICogVXBkYXRlIG1ldGEgaW5mbyBmb3IgYWxsIHJvd3MsIGllLiBpc1NlbGVjdGVkLCBpc09wZW4uXG5cdCAqIEBwYXJhbSBhcnJheSAtIGFycmF5IHRoYXQgaG9sZHMgcm93cyB0aGF0IG5lZWQgdG8gYmUgdXBkYXRlZC5cblx0ICogQHBhcmFtIHByb3BlcnR5IC0gbmFtZSBvZiBwcm9wZXJ0eSB0aGF0IHNob3VsZCBiZSBjaGFuZ2VkL3RvZ2dsZWQuXG5cdCAqIEBwYXJhbSBhY3RpdmUgLSBzaG91bGQgcm93cyBiZSBleHBhbmRlZC9vcGVuLCBzZWxlY3RlZC5cblx0ICogQHBhcmFtIGV4Y2VwdGlvbiAtIHVwZGF0ZSBhbGwgcm93cyBleGNlcHQgdGhpcyBvbmUuXG5cdCAqL1xuXHRwcml2YXRlIF91cGRhdGVNZXRhSW5mbyhcblx0XHRhcnJheTogQXJyYXk8R3RSb3c+LFxuXHRcdHByb3BlcnR5OiBzdHJpbmcsXG5cdFx0YWN0aXZlOiBib29sZWFuLFxuXHRcdGV4Y2VwdGlvbj86IEd0Um93XG5cdCkge1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmICghdGhpcy5tZXRhSW5mb1thcnJheVtpXS4kJGd0Um93SWRdKSB7XG5cdFx0XHRcdHRoaXMubWV0YUluZm9bYXJyYXlbaV0uJCRndFJvd0lkXSA9IHt9O1xuXHRcdFx0fVxuXHRcdFx0aWYgKGV4Y2VwdGlvbiAmJiBhcnJheVtpXS4kJGd0Um93SWQgPT09IGV4Y2VwdGlvbi4kJGd0Um93SWQpIHtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMubWV0YUluZm9bYXJyYXlbaV0uJCRndFJvd0lkXVtwcm9wZXJ0eV0gPSBhY3RpdmU7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIFB1c2ggc2VsZWN0ZWQvZXhwYW5kZWQgbGF6eSBsb2FkZWQgcm93cyB0byBhcnJheSB3aXRoIG1ldGEgZGF0YS5cblx0ICogQHBhcmFtIHRhcmdldCAtIGFycmF5IHRvIHdoaWNoIHJvd3Mgc2hvdWxkIGJlIGFkZGVkLlxuXHQgKiBAcGFyYW0gc291cmNlIC0gYXJyYXkgdGhhdCBob2xkcyByb3dzIHRoYXQgc2hvdWxkIGJlIGFkZGVkLlxuXHQgKiBAcmV0dXJucyBhcnJheSB3aXRoIGFkZGVkIHJvd3MuXG5cdCAqL1xuXHRwcml2YXRlIF9wdXNoTGF6eVJvd3MoXG5cdFx0dGFyZ2V0OiBBcnJheTxHdFJvdz4sXG5cdFx0c291cmNlOiBBcnJheTxHdFJvdz5cblx0KTogQXJyYXk8R3RSb3c+IHtcblx0XHRjb25zdCBVTklRVUVfUk9XUyA9IHRhcmdldC5tYXAocm93ID0+IHJvdy4kJGd0Um93SWQpO1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgc291cmNlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHQvLyBvbmx5IGFkZCBpZiBub3QgYWxyZWFkeSBpbiBsaXN0XG5cdFx0XHRpZiAoVU5JUVVFX1JPV1MuaW5kZXhPZihzb3VyY2VbaV0uJCRndFJvd0lkKSA9PT0gLTEpIHtcblx0XHRcdFx0dGFyZ2V0LnB1c2goc291cmNlW2ldKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRhcmdldDtcblx0fVxuXG5cdC8qKlxuXHQgKiBUb2dnbGUgbWV0YSBpbmZvIGZvciBhbGwgcm93cywgaWUuIGlzU2VsZWN0ZWQsIGlzT3Blbi5cblx0ICogQHBhcmFtIHByb3BlcnR5IC0gbmFtZSBvZiBwcm9wZXJ0eSB0aGF0IHNob3VsZCBiZSBjaGFuZ2VkL3RvZ2dsZWQuXG5cdCAqIEBwYXJhbSBhY3RpdmUgLSBzaG91bGQgcm93cyBiZSBleHBhbmRlZC9vcGVuLCBzZWxlY3RlZC5cblx0ICovXG5cdHByaXZhdGUgX3RvZ2dsZUFsbFJvd1Byb3BlcnR5KHByb3BlcnR5OiBzdHJpbmcsIGFjdGl2ZTogYm9vbGVhbikge1xuXHRcdGxldCBldmVudE5hbWU6IHN0cmluZztcblx0XHRsZXQgZXZlbnRWYWx1ZTogYW55O1xuXHRcdHN3aXRjaCAocHJvcGVydHkpIHtcblx0XHRcdGNhc2UgJ2lzT3Blbic6XG5cdFx0XHRcdC8vIGNoZWNrIGlmIG11bHRpcGxlIGV4cGFuZGVkIHJvd3MgYXJlIGFsbG93ZWQuLi5cblx0XHRcdFx0aWYgKHRoaXMuX2d0T3B0aW9ucy5yb3dFeHBhbmRBbGxvd011bHRpcGxlID09PSBmYWxzZSkge1xuXHRcdFx0XHRcdC8vIC4uLmlmIG5vdCwgZXhpdCBmdW5jdGlvblxuXHRcdFx0XHRcdGNvbnNvbGUubG9nKFxuXHRcdFx0XHRcdFx0J2ZlYXR1cmUgZGlzYWJsZWQ6IGVuYWJsZSBieSBzZXR0aW5nIFwicm93RXhwYW5kQWxsb3dNdWx0aXBsZSA9IHRydWVcIidcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoYWN0aXZlKSB7XG5cdFx0XHRcdFx0ZXZlbnROYW1lID0gJ2V4cGFuZC1hbGwnO1xuXHRcdFx0XHRcdHRoaXMub3BlblJvd3MgPSB0aGlzLl9ndE9wdGlvbnMubGF6eUxvYWRcblx0XHRcdFx0XHRcdD8gdGhpcy5fcHVzaExhenlSb3dzKFxuXHRcdFx0XHRcdFx0XHRcdHRoaXMub3BlblJvd3MsXG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fZ3REYXRhW3RoaXMuZ3RJbmZvLnBhZ2VDdXJyZW50IC0gMV0uc2xpY2UoKVxuXHRcdFx0XHRcdFx0ICApXG5cdFx0XHRcdFx0XHQ6IHRoaXMuX2d0RGF0YS5zbGljZSgpO1xuXHRcdFx0XHRcdHRoaXMuX3VwZGF0ZU1ldGFJbmZvKHRoaXMub3BlblJvd3MsIHByb3BlcnR5LCBhY3RpdmUpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGV2ZW50TmFtZSA9ICdjb2xsYXBzZS1hbGwnO1xuXHRcdFx0XHRcdHRoaXMuX3VwZGF0ZU1ldGFJbmZvKHRoaXMub3BlblJvd3MsIHByb3BlcnR5LCBhY3RpdmUpO1xuXHRcdFx0XHRcdHRoaXMub3BlblJvd3MgPSBbXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRldmVudFZhbHVlID0ge1xuXHRcdFx0XHRcdGV4cGFuZGVkUm93czogdGhpcy5vcGVuUm93cyxcblx0XHRcdFx0XHRjaGFuZ2VkUm93OiAnYWxsJ1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ2lzU2VsZWN0ZWQnOlxuXHRcdFx0XHQvLyBjaGVjayBpZiBtdWx0aSByb3cgc2VsZWN0aW9uIGlzIGFsbG93ZWQuLi5cblx0XHRcdFx0aWYgKHRoaXMuX2d0T3B0aW9ucy5yb3dTZWxlY3Rpb25BbGxvd011bHRpcGxlID09PSBmYWxzZSkge1xuXHRcdFx0XHRcdC8vIC4uLmlmIG5vdCwgZXhpdCBmdW5jdGlvblxuXHRcdFx0XHRcdGNvbnNvbGUubG9nKFxuXHRcdFx0XHRcdFx0J2ZlYXR1cmUgZGlzYWJsZWQ6IGVuYWJsZSBieSBzZXR0aW5nIFwicm93U2VsZWN0aW9uQWxsb3dNdWx0aXBsZSA9IHRydWVcIidcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoYWN0aXZlKSB7XG5cdFx0XHRcdFx0ZXZlbnROYW1lID0gJ3NlbGVjdC1hbGwnO1xuXHRcdFx0XHRcdHRoaXMuc2VsZWN0ZWRSb3dzID0gdGhpcy5fZ3RPcHRpb25zLmxhenlMb2FkXG5cdFx0XHRcdFx0XHQ/IHRoaXMuX3B1c2hMYXp5Um93cyhcblx0XHRcdFx0XHRcdFx0XHR0aGlzLnNlbGVjdGVkUm93cyxcblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9ndERhdGFbdGhpcy5ndEluZm8ucGFnZUN1cnJlbnQgLSAxXS5zbGljZSgpXG5cdFx0XHRcdFx0XHQgIClcblx0XHRcdFx0XHRcdDogdGhpcy5fZ3REYXRhLnNsaWNlKCk7XG5cdFx0XHRcdFx0dGhpcy5fdXBkYXRlTWV0YUluZm8odGhpcy5zZWxlY3RlZFJvd3MsIHByb3BlcnR5LCBhY3RpdmUpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGV2ZW50TmFtZSA9ICdkZXNlbGVjdC1hbGwnO1xuXHRcdFx0XHRcdHRoaXMuX3VwZGF0ZU1ldGFJbmZvKHRoaXMuc2VsZWN0ZWRSb3dzLCBwcm9wZXJ0eSwgYWN0aXZlKTtcblx0XHRcdFx0XHR0aGlzLnNlbGVjdGVkUm93cyA9IFtdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGV2ZW50VmFsdWUgPSB7XG5cdFx0XHRcdFx0c2VsZWN0ZWRSb3dzOiB0aGlzLnNlbGVjdGVkUm93cyxcblx0XHRcdFx0XHRjaGFuZ2VkUm93OiAnYWxsJ1xuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdGJyZWFrO1xuXHRcdH1cblx0XHR0aGlzLmd0RXZlbnQuZW1pdCh7XG5cdFx0XHRuYW1lOiAnZ3Qtcm93LScgKyBldmVudE5hbWUsXG5cdFx0XHR2YWx1ZTogZXZlbnRWYWx1ZVxuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIFRvZ2dsZSBtZXRhIGluZm8gZm9yIHJvdywgaWUuIGlzU2VsZWN0ZWQsIGlzT3Blbi5cblx0ICogQHBhcmFtIHJvdyAtIHJvdyBvYmplY3QuXG5cdCAqIEBwYXJhbSBwcm9wZXJ0eSAtIG5hbWUgb2YgcHJvcGVydHkgdGhhdCBzaG91bGQgYmUgY2hhbmdlZC90b2dnbGVkLlxuXHQgKiBAcGFyYW0gcHJvcGVydHlWYWx1ZXMgLSBvcHRpb25hbCBwcm9wZXJ0eSB2YWx1ZXMgdGhhdCBjYW4gYmUgcGFzc2VkLlxuXHQgKi9cblx0cHJpdmF0ZSBfdG9nZ2xlUm93UHJvcGVydHkoXG5cdFx0cm93OiBHdFJvdyxcblx0XHRwcm9wZXJ0eTogc3RyaW5nLFxuXHRcdHByb3BlcnR5VmFsdWVzPzogYW55XG5cdCkge1xuXHRcdGxldCBldmVudE5hbWU6IHN0cmluZztcblx0XHRsZXQgZXZlbnRWYWx1ZTogYW55O1xuXHRcdC8vIG1ha2Ugc3VyZSBndFJvd0lkIGV4aXN0cyBvbiByb3cgb2JqZWN0XG5cdFx0aWYgKHR5cGVvZiByb3cuJCRndFJvd0lkICE9PSAndW5kZWZpbmVkJykge1xuXHRcdFx0Ly8gY2hlY2sgaWYgbWV0YSBpbmZvIGV4aXN0cyBmb3Igcm93XG5cdFx0XHRpZiAoIXRoaXMubWV0YUluZm9bcm93LiQkZ3RSb3dJZF0pIHtcblx0XHRcdFx0Ly8gaWYgbm90LCBhZGQgb2JqZWN0IHRvIHN0b3JlIG1ldGEgaW5mb1xuXHRcdFx0XHR0aGlzLm1ldGFJbmZvW3Jvdy4kJGd0Um93SWRdID0ge307XG5cdFx0XHR9XG5cblx0XHRcdHN3aXRjaCAocHJvcGVydHkpIHtcblx0XHRcdFx0Y2FzZSAnaXNPcGVuJzpcblx0XHRcdFx0XHRjb25zdCBvcGVuZWQgPSB0aGlzLm1ldGFJbmZvW3Jvdy4kJGd0Um93SWRdW3Byb3BlcnR5XTtcblxuXHRcdFx0XHRcdC8vIGNoZWNrIGlmIG11bHRpcGxlIGV4cGFuZGVkIHJvd3MgYXJlIGFsbG93ZWQuLi5cblx0XHRcdFx0XHRpZiAodGhpcy5fZ3RPcHRpb25zLnJvd0V4cGFuZEFsbG93TXVsdGlwbGUgPT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0XHQvLyAuLi5pZiBub3QsIGNvbGxhcHNlIGFsbCByb3dzIGV4Y2VwdCBjdXJyZW50IHJvd1xuXHRcdFx0XHRcdFx0dGhpcy5fdXBkYXRlTWV0YUluZm8odGhpcy5vcGVuUm93cywgcHJvcGVydHksIGZhbHNlLCByb3cpO1xuXHRcdFx0XHRcdFx0dGhpcy5vcGVuUm93cyA9IFtdO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIGNoZWNrIGlmIHJvdyBpcyBleHBhbmRlZFxuXHRcdFx0XHRcdGlmICghb3BlbmVkKSB7XG5cdFx0XHRcdFx0XHRldmVudE5hbWUgPSAnZXhwYW5kJztcblx0XHRcdFx0XHRcdC8vIGFkZCByb3cgdG8gZXhwYW5kZWQgcm93c1xuXHRcdFx0XHRcdFx0dGhpcy5vcGVuUm93cy5wdXNoKHJvdyk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGV2ZW50TmFtZSA9ICdjb2xsYXBzZSc7XG5cdFx0XHRcdFx0XHQvLyBsb29wIHRocm91Z2ggZXhwYW5kZWQgcm93cy4uLlxuXHRcdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm9wZW5Sb3dzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdC8vIGlmIGV4cGFuZGVkIHJvdyBlcXVhbHMgcGFzc2VkIHJvdy4uLlxuXHRcdFx0XHRcdFx0XHRpZiAodGhpcy5vcGVuUm93c1tpXS4kJGd0Um93SWQgPT09IHJvdy4kJGd0Um93SWQpIHtcblx0XHRcdFx0XHRcdFx0XHQvLyAuLi5yZW1vdmUgcm93IGZyb20gZXhwYW5kZWQgcm93cy4uLlxuXHRcdFx0XHRcdFx0XHRcdHRoaXMub3BlblJvd3Muc3BsaWNlKGksIDEpO1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gLi4uYW5kIGV4aXQgbG9vcFxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGV2ZW50VmFsdWUgPSB7XG5cdFx0XHRcdFx0XHRleHBhbmRlZFJvd3M6IHRoaXMub3BlblJvd3MsXG5cdFx0XHRcdFx0XHRjaGFuZ2VkUm93OiByb3dcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRjYXNlICdpc1NlbGVjdGVkJzpcblx0XHRcdFx0XHRjb25zdCBzZWxlY3RlZCA9IHRoaXMubWV0YUluZm9bcm93LiQkZ3RSb3dJZF1bcHJvcGVydHldO1xuXG5cdFx0XHRcdFx0Ly8gY2hlY2sgaWYgbXVsdGkgcm93IHNlbGVjdGlvbiBpcyBhbGxvd2VkLi4uXG5cdFx0XHRcdFx0aWYgKHRoaXMuX2d0T3B0aW9ucy5yb3dTZWxlY3Rpb25BbGxvd011bHRpcGxlID09PSBmYWxzZSkge1xuXHRcdFx0XHRcdFx0Ly8gLi4uaWYgbm90LCBkZXNlbGVjdCBhbGwgcm93cyBleGNlcHQgY3VycmVudCByb3dcblx0XHRcdFx0XHRcdHRoaXMuX3VwZGF0ZU1ldGFJbmZvKHRoaXMuc2VsZWN0ZWRSb3dzLCBwcm9wZXJ0eSwgZmFsc2UsIHJvdyk7XG5cdFx0XHRcdFx0XHR0aGlzLnNlbGVjdGVkUm93cyA9IFtdO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIGNoZWNrIGlmIHJvdyBpcyBzZWxlY3RlZFxuXHRcdFx0XHRcdGlmICghc2VsZWN0ZWQpIHtcblx0XHRcdFx0XHRcdGV2ZW50TmFtZSA9ICdzZWxlY3QnO1xuXHRcdFx0XHRcdFx0Ly8gYWRkIHJvdyB0byBzZWxlY3RlZCByb3dzXG5cdFx0XHRcdFx0XHR0aGlzLnNlbGVjdGVkUm93cy5wdXNoKHJvdyk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGlmICh0aGlzLmd0T3B0aW9ucy5sYXp5TG9hZCAmJiB0aGlzLmxhenlBbGxTZWxlY3RlZCkge1xuXHRcdFx0XHRcdFx0XHR0aGlzLmxhenlBbGxTZWxlY3RlZCA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0ZXZlbnROYW1lID0gJ2Rlc2VsZWN0Jztcblx0XHRcdFx0XHRcdC8vIGxvb3AgdGhyb3VnaCBzZWxlY3RlZCByb3dzLi4uXG5cdFx0XHRcdFx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuc2VsZWN0ZWRSb3dzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdC8vIGlmIHNlbGVjdGVkIHJvdyBlcXVhbHMgcGFzc2VkIHJvdy4uLlxuXHRcdFx0XHRcdFx0XHRpZiAodGhpcy5zZWxlY3RlZFJvd3NbaV0uJCRndFJvd0lkID09PSByb3cuJCRndFJvd0lkKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gLi4ucmVtb3ZlIHJvdyBmcm9tIHNlbGVjdGVkIHJvd3MuLi5cblx0XHRcdFx0XHRcdFx0XHR0aGlzLnNlbGVjdGVkUm93cy5zcGxpY2UoaSwgMSk7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyAuLi5hbmQgZXhpdCBsb29wXG5cdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZXZlbnRWYWx1ZSA9IHtcblx0XHRcdFx0XHRcdHNlbGVjdGVkUm93czogdGhpcy5zZWxlY3RlZFJvd3MsXG5cdFx0XHRcdFx0XHRjaGFuZ2VkUm93OiByb3dcblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdGNhc2UgJ2lzVXBkYXRlZCc6XG5cdFx0XHRcdFx0ZXZlbnROYW1lID0gJ3VwZGF0ZWQnO1xuXHRcdFx0XHRcdGNvbnN0IG9sZFZhbHVlID0gcHJvcGVydHlWYWx1ZXM7XG5cdFx0XHRcdFx0Ly8gY2hlY2sgaWYgZWRpdCBvYmplY3QgZXhpc3RzIGZvciByb3dcblx0XHRcdFx0XHRpZiAodHlwZW9mIHRoaXMubWV0YUluZm9bcm93LiQkZ3RSb3dJZF1bcHJvcGVydHldID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHRcdFx0dGhpcy5tZXRhSW5mb1tyb3cuJCRndFJvd0lkXVtwcm9wZXJ0eV0gPSB7XG5cdFx0XHRcdFx0XHRcdG9yaWdpbmFsVmFsdWU6IG9sZFZhbHVlLFxuXHRcdFx0XHRcdFx0XHRvbGRWYWx1ZTogb2xkVmFsdWUsXG5cdFx0XHRcdFx0XHRcdG5ld1ZhbHVlOiByb3dcblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRoaXMubWV0YUluZm9bcm93LiQkZ3RSb3dJZF1bcHJvcGVydHldLm9sZFZhbHVlID0gb2xkVmFsdWU7XG5cdFx0XHRcdFx0XHR0aGlzLm1ldGFJbmZvW3Jvdy4kJGd0Um93SWRdW3Byb3BlcnR5XS5uZXdWYWx1ZSA9IHJvdztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZXZlbnRWYWx1ZSA9IHRoaXMubWV0YUluZm9bcm93LiQkZ3RSb3dJZF1bcHJvcGVydHldO1xuXHRcdFx0XHRcdHRoaXMucmVkcmF3KCk7XG5cdFx0XHRcdFx0dGhpcy5pbmxpbmVFZGl0Q2FuY2VsKHJvdyk7XG5cdFx0XHRcdFx0Ly8gdGhpcy5ndERhdGEgPSBbLi4udGhpcy5ndERhdGEubWFwKChyKSA9PiB7IHJldHVybnsuLi5yfTsgfSldO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5ndEV2ZW50LmVtaXQoe1xuXHRcdFx0XHRuYW1lOiAnZ3Qtcm93LScgKyBldmVudE5hbWUsXG5cdFx0XHRcdHZhbHVlOiBldmVudFZhbHVlXG5cdFx0XHR9KTtcblx0XHRcdGlmIChwcm9wZXJ0eSAhPT0gJ2lzVXBkYXRlZCcpIHtcblx0XHRcdFx0dGhpcy5tZXRhSW5mb1tyb3cuJCRndFJvd0lkXVtwcm9wZXJ0eV0gPSAhdGhpcy5tZXRhSW5mb1tyb3cuJCRndFJvd0lkXVtcblx0XHRcdFx0XHRwcm9wZXJ0eVxuXHRcdFx0XHRdO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBVcGRhdGUgY29sdW1uLlxuXHQgKiBAcGFyYW0gJGV2ZW50IC0ga2V5IHVwIGV2ZW50LlxuXHQgKiBAcGFyYW0gcm93IC0gcm93IG9iamVjdC5cblx0ICogQHBhcmFtIGNvbHVtbiAtIGNvbHVtbiBvYmplY3QuXG5cdCAqL1xuXHRwdWJsaWMgZ3RVcGRhdGVDb2x1bW4oXG5cdFx0JGV2ZW50OiBLZXlib2FyZEV2ZW50LFxuXHRcdHJvdzogR3RSb3csXG5cdFx0Y29sdW1uOiBHdFJlbmRlckZpZWxkPGFueSwgYW55PlxuXHQpIHtcblx0XHR0aGlzLl9lZGl0Um93KHJvdywgY29sdW1uKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBEcm9wZG93biBzZWxlY3QuXG5cdCAqIEBwYXJhbSByb3cgLSByb3cgb2JqZWN0LlxuXHQgKiBAcGFyYW0gY29sdW1uIC0gY29sdW1uIG9iamVjdC5cblx0ICovXG5cdHB1YmxpYyBndERyb3Bkb3duU2VsZWN0KHJvdzogR3RSb3csIGNvbHVtbjogR3RSZW5kZXJGaWVsZDxhbnksIGFueT4pIHtcblx0XHRjb25zdCBvbGRWYWx1ZSA9IHsgLi4ucm93IH07XG5cdFx0cm93W2NvbHVtbi5vYmplY3RLZXldID0gY29sdW1uLnJlbmRlclZhbHVlO1xuXHRcdHRoaXMudXBkYXRlUm93KHJvdywgb2xkVmFsdWUpO1xuXHR9XG5cblx0cHJpdmF0ZSBfZWRpdFJvdyhyb3c6IEd0Um93LCBjb2x1bW46IEd0UmVuZGVyRmllbGQ8YW55LCBhbnk+KSB7XG5cdFx0Y29uc3QgT0JKRUNUX0tFWSA9IGNvbHVtbi5vYmplY3RLZXk7IC8vIGRlY2xhcmUgb2JqZWN0IGtleSB3aGljaCBjb250YWlucyBjaGFuZ2VzXG5cblx0XHQvLyBjaGVjayBpZiBjZWxsIGhhcyBjaGFuZ2VkIHZhbHVlXG5cdFx0Y29sdW1uLmVkaXRlZCA9IHJvd1tjb2x1bW4ub2JqZWN0S2V5XSAhPT0gY29sdW1uLnJlbmRlclZhbHVlO1xuXHRcdC8vIGNoZWNrIGlmIHJvdyBjb250YWlucyBjaGFuZ2VzLi4uXG5cdFx0aWYgKCF0aGlzLmVkaXRlZFJvd3Nbcm93LiQkZ3RSb3dJZF0pIHtcblx0XHRcdC8vIGlmIG5vdCwgY3JlYXRlIGFuIG9iamVjdCBmb3IgdGhlIGNoYW5nZWQgcm93XG5cdFx0XHR0aGlzLmVkaXRlZFJvd3Nbcm93LiQkZ3RSb3dJZF0gPSB7XG5cdFx0XHRcdGNoYW5nZXM6IHt9LCAvLyBjcmVhdGUgcGxhY2Vob2xkZXIgZm9yIGNoYW5nZXNcblx0XHRcdFx0cm93OiByb3cgLy8gc3RvcmUgcmVmZXJlbmNlIHRvIHRoZSByb3cgdGhhdCBzaG91bGQgYmUgdXBkYXRlZFxuXHRcdFx0fTtcblx0XHR9XG5cblx0XHQvLyBzdG9yZSBjaGFuZ2VkIGNvbHVtbiB1bmRlciBjaGFuZ2VzIGlmIGl0IGhhcyBiZWVuIGVkaXRlZFxuXHRcdGlmIChjb2x1bW4uZWRpdGVkKSB7XG5cdFx0XHR0aGlzLmVkaXRlZFJvd3Nbcm93LiQkZ3RSb3dJZF0uY2hhbmdlc1tPQkpFQ1RfS0VZXSA9IGNvbHVtbjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gZGVsZXRlIGNoYW5nZSBvYmplY3QgaWYgY29sdW1uIGlzIHVuY2hhbmdlZFxuXHRcdFx0ZGVsZXRlIHRoaXMuZWRpdGVkUm93c1tyb3cuJCRndFJvd0lkXS5jaGFuZ2VzW09CSkVDVF9LRVldO1xuXHRcdFx0Ly8gY2hlY2sgaG93IG1hbnkgY29sdW1ucyBoYXZlIGJlZW4gY2hhbmdlZFxuXHRcdFx0Y29uc3QgQ0hBTkdFRF9DT0xVTU5TID0gT2JqZWN0LmtleXMoXG5cdFx0XHRcdHRoaXMuZWRpdGVkUm93c1tyb3cuJCRndFJvd0lkXS5jaGFuZ2VzXG5cdFx0XHQpLmxlbmd0aDtcblx0XHRcdGlmIChDSEFOR0VEX0NPTFVNTlMgPT09IDApIHtcblx0XHRcdFx0Ly8gZGVsZXRlIHJvdyBmcm9tIGVkaXRlZCByb3dzIGlmIG5vIGNvbHVtbnMgaGF2ZSBiZWVuIGVkaXRlZFxuXHRcdFx0XHRkZWxldGUgdGhpcy5lZGl0ZWRSb3dzW3Jvdy4kJGd0Um93SWRdO1xuXHRcdFx0fVxuXHRcdH1cblx0XHQvLyBpZiBubyBsaXN0ZW5lciBpcyBwcmVzZW50Li4uXG5cdFx0aWYgKCF0aGlzLmdsb2JhbElubGluZUVkaXRMaXN0ZW5lcikge1xuXHRcdFx0Ly8gLi4ubGlzdGVuIGZvciB1cGRhdGUgZXZlbnRcblx0XHRcdHRoaXMuX2xpc3RlbkZvcktleWRvd25FdmVudCgpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBMaXN0ZW4gZm9yIGtleSBkb3duIGV2ZW50IC0gbGlzdGVuIGZvciBrZXkgZG93biBldmVudCBkdXJpbmcgaW5saW5lIGVkaXQuXG5cdCAqL1xuXHRwcml2YXRlIF9saXN0ZW5Gb3JLZXlkb3duRXZlbnQoKSB7XG5cdFx0Ly8gYWRkIGdsb2JhbCBsaXN0ZW5lciBmb3Iga2V5IGRvd24gZXZlbnRzXG5cdFx0dGhpcy5nbG9iYWxJbmxpbmVFZGl0TGlzdGVuZXIgPSB0aGlzLnJlbmRlcmVyLmxpc3Rlbihcblx0XHRcdCdkb2N1bWVudCcsXG5cdFx0XHQna2V5ZG93bicsXG5cdFx0XHQkZXZlbnQgPT4ge1xuXHRcdFx0XHRzd2l0Y2ggKCRldmVudC5rZXkpIHtcblx0XHRcdFx0XHRjYXNlICdFbnRlcic6IC8vIHVwZGF0ZSBkYXRhIG9iamVjdFxuXHRcdFx0XHRcdFx0dGhpcy5pbmxpbmVFZGl0VXBkYXRlKCk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRjYXNlICdFc2NhcGUnOiAvLyBjYW5jZWxcblx0XHRcdFx0XHRcdHRoaXMuaW5saW5lRWRpdENhbmNlbCgpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIElubGluZSBlZGl0IHVwZGF0ZSAtIGFjY2VwdCBjaGFuZ2VzIGFuZCB1cGRhdGUgcm93IHZhbHVlcy5cblx0ICovXG5cdHB1YmxpYyBpbmxpbmVFZGl0VXBkYXRlKCkge1xuXHRcdC8vIGxvb3AgdGhyb3VnaCByb3dzIHRoYXQgaGF2ZSBiZWVuIGVkaXRlZFxuXHRcdE9iamVjdC5rZXlzKHRoaXMuZWRpdGVkUm93cykubWFwKGtleSA9PiB7XG5cdFx0XHRjb25zdCBST1cgPSB0aGlzLmVkaXRlZFJvd3Nba2V5XS5yb3c7IC8vIHJvdyB0byB1cGRhdGVcblx0XHRcdGNvbnN0IENIQU5HRVMgPSB0aGlzLmVkaXRlZFJvd3Nba2V5XS5jaGFuZ2VzOyAvLyBjaGFuZ2VzIHRvIHRoZSByb3dcblxuXHRcdFx0Ly8gbG9vcCB0aHJvdWdoIGNoYW5nZXMgaW4gcm93XG5cdFx0XHRPYmplY3Qua2V5cyhDSEFOR0VTKS5tYXAob2JqZWN0S2V5ID0+IHtcblx0XHRcdFx0Y29uc3Qgb2xkVmFsdWUgPSB7IC4uLlJPVyB9O1xuXHRcdFx0XHRST1dbb2JqZWN0S2V5XSA9IENIQU5HRVNbb2JqZWN0S2V5XS5yZW5kZXJWYWx1ZTsgLy8gdXBkYXRlIGRhdGEgdmFsdWVcblx0XHRcdFx0dGhpcy51cGRhdGVSb3coUk9XLCBvbGRWYWx1ZSk7IC8vIHVwZGF0ZSBtZXRhIGluZm8gZm9yIHJvdyBhbmQgc2VuZCBldmVudFxuXHRcdFx0XHRDSEFOR0VTW29iamVjdEtleV0uZWRpdGVkID0gZmFsc2U7IC8vIGRpc2FibGUgZWRpdCBtb2RlXG5cdFx0XHR9KTtcblx0XHR9KTtcblx0XHQvLyBjbGVhciByb3dzIG1hcmtlZCBhcyBlZGl0ZWQgYXMgdGhlIHJvd3MgaGF2ZSBiZWVuIHVwZGF0ZWRcblx0XHR0aGlzLmVkaXRlZFJvd3MgPSB7fTtcblx0XHQvLyByZW1vdmUgbGlzdGVuZXJcblx0XHR0aGlzLl9zdG9wTGlzdGVuaW5nRm9yS2V5ZG93bkV2ZW50KCk7XG5cdH1cblxuXHQvKipcblx0ICogSW5saW5lIGVkaXQgY2FuY2VsIC0gY2FuY2VsIGFuZCByZXNldCBpbmxpbmUgZWRpdHMuXG5cdCAqL1xuXHRwdWJsaWMgaW5saW5lRWRpdENhbmNlbChyb3c/OiBHdFJvdykge1xuXHRcdGlmIChyb3cpIHtcblx0XHRcdGRlbGV0ZSB0aGlzLmVkaXRlZFJvd3Nbcm93LiQkZ3RSb3dJZF07XG5cdFx0XHQvLyByZW1vdmUgbGlzdGVuZXJcblx0XHRcdHRoaXMuX3N0b3BMaXN0ZW5pbmdGb3JLZXlkb3duRXZlbnQoKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBsb29wIHRocm91Z2ggcm93cyB0aGF0IGhhdmUgYmVlbiBlZGl0ZWRcblx0XHRPYmplY3Qua2V5cyh0aGlzLmVkaXRlZFJvd3MpLm1hcChrZXkgPT4ge1xuXHRcdFx0Y29uc3QgUk9XID0gdGhpcy5lZGl0ZWRSb3dzW2tleV0ucm93OyAvLyByb3cgdG8gdXBkYXRlXG5cdFx0XHRjb25zdCBDSEFOR0VTID0gdGhpcy5lZGl0ZWRSb3dzW2tleV0uY2hhbmdlczsgLy8gY2hhbmdlcyB0byB0aGUgcm93XG5cblx0XHRcdC8vIGxvb3AgdGhyb3VnaCBjaGFuZ2VzIGluIHJvd1xuXHRcdFx0T2JqZWN0LmtleXMoQ0hBTkdFUykubWFwKG9iamVjdEtleSA9PiB7XG5cdFx0XHRcdENIQU5HRVNbb2JqZWN0S2V5XS5yZW5kZXJWYWx1ZSA9IFJPV1tvYmplY3RLZXldOyAvLyByZXNldCByZW5kZXJlZCB2YWx1ZVxuXHRcdFx0XHRDSEFOR0VTW29iamVjdEtleV0uZWRpdGVkID0gZmFsc2U7IC8vIGRpc2FibGUgZWRpdCBtb2RlXG5cdFx0XHR9KTtcblx0XHR9KTtcblx0XHQvLyBjbGVhciByb3dzIG1hcmtlZCBhcyBlZGl0ZWQgYXMgdGhlIHJvd3MgaGF2ZSBiZWVuIHVwZGF0ZWRcblx0XHR0aGlzLmVkaXRlZFJvd3MgPSB7fTtcblx0XHQvLyByZW1vdmUgbGlzdGVuZXJcblx0XHR0aGlzLl9zdG9wTGlzdGVuaW5nRm9yS2V5ZG93bkV2ZW50KCk7XG5cdH1cblxuXHQvKipcblx0ICogU3RvcCBsaXN0ZW5pbmcgZm9yIGtleSBkb3duIGV2ZW50IC0gc3RvcCBsaXN0ZW5pbmcgZm9yIGtleSBkb3duIGV2ZW50cyBwYXNzZWQgZHVyaW5nIGlubGluZSBlZGl0LlxuXHQgKi9cblx0cHJpdmF0ZSBfc3RvcExpc3RlbmluZ0ZvcktleWRvd25FdmVudCgpIHtcblx0XHRpZiAodGhpcy5nbG9iYWxJbmxpbmVFZGl0TGlzdGVuZXIpIHtcblx0XHRcdHRoaXMuZ2xvYmFsSW5saW5lRWRpdExpc3RlbmVyKCk7XG5cdFx0XHR0aGlzLmdsb2JhbElubGluZUVkaXRMaXN0ZW5lciA9IG51bGw7XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCAqIEFwcGx5IGZpbHRlcihzKS5cblx0ICogQHBhcmFtIGZpbHRlciAtIG9iamVjdCBjb250YWluaW5nIGtleSB2YWx1ZSBwYWlycywgd2hlcmUgdmFsdWUgc2hvdWxkIGJlIGFycmF5IG9mIHZhbHVlcy5cblx0ICovXG5cdHB1YmxpYyBndEFwcGx5RmlsdGVyKGZpbHRlcjogT2JqZWN0KSB7XG5cdFx0dGhpcy5ndEluZm8uZmlsdGVyID0gZmlsdGVyO1xuXHRcdC8vIGdvIHRvIGZpcnN0IHBhZ2Vcblx0XHR0aGlzLmdvVG9QYWdlKDEpO1xuXHRcdHRoaXMudXBkYXRlVG90YWxzKCk7XG5cdH1cblxuXHQvKiogQ2xlYXIvcmVtb3ZlIGFwcGxpZWQgZmlsdGVyKHMpLiAqL1xuXHRwdWJsaWMgZ3RDbGVhckZpbHRlcigpIHtcblx0XHR0aGlzLmd0SW5mby5maWx0ZXIgPSBmYWxzZTtcblx0XHR0aGlzLnVwZGF0ZVRvdGFscygpO1xuXHRcdC8vIHRoaXMudXBkYXRlUmVjb3JkUmFuZ2UoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBTZWFyY2hcblx0ICogQHBhcmFtIHZhbHVlIC0gc3RyaW5nIGNvbnRhaW5pbmcgb25lIG9yIG1vcmUgd29yZHNcblx0ICovXG5cdHB1YmxpYyBndFNlYXJjaCh2YWx1ZTogc3RyaW5nKSB7XG5cdFx0dGhpcy5ndEluZm8uc2VhcmNoVGVybXMgPSB2YWx1ZTtcblx0XHQvLyBhbHdheXMgZ28gdG8gZmlyc3QgcGFnZSB3aGVuIHNlYXJjaGluZ1xuXHRcdHRoaXMuZ29Ub1BhZ2UoMSk7XG5cdFx0dGhpcy51cGRhdGVUb3RhbHMoKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBZGQgcm93c1xuXHQgKiBAcGFyYW0gcm93cyAtIHJvd3MgdG8gYWRkXG5cdCAqIEByZXR1cm5zIG5ldyBkYXRhIGFycmF5LlxuXHQgKi9cblx0cHVibGljIGd0QWRkKHJvd3M6IEFycmF5PFI+KTogUmVhZG9ubHlBcnJheTxSPiB7XG5cdFx0dGhpcy5ndERhdGEgPSBbLi4udGhpcy5ndERhdGEsIC4uLnJvd3NdO1xuXHRcdHJldHVybiBbLi4udGhpcy5ndERhdGFdO1xuXHR9XG5cblx0LyoqXG5cdCAqIERlbGV0ZSByb3dcblx0ICogQHBhcmFtIG9iamVjdEtleSAtIG9iamVjdCBrZXkgeW91IHdhbnQgdG8gZmluZCBtYXRjaCB3aXRoXG5cdCAqIEBwYXJhbSB2YWx1ZSAtIHRoZSB2YWx1ZSB0aGF0IHNob3VsZCBiZSBkZWxldGVkXG5cdCAqIEBwYXJhbSBtYXRjaCAtIGFsbDogZGVsZXRlIGFsbCBtYXRjaGVzLCBmaXJzdDogZGVsZXRlIGZpcnN0IG1hdGNoIChkZWZhdWx0KVxuXHQgKiBAcmV0dXJucyBuZXcgZGF0YSBhcnJheS5cblx0ICovXG5cdHB1YmxpYyBndERlbGV0ZShcblx0XHRvYmplY3RLZXk6IHN0cmluZyxcblx0XHR2YWx1ZTogc3RyaW5nIHwgbnVtYmVyLFxuXHRcdG1hdGNoOiAnZmlyc3QnIHwgJ2FsbCcgPSAnZmlyc3QnXG5cdCk6IFJlYWRvbmx5QXJyYXk8Uj4ge1xuXHRcdGlmIChtYXRjaCA9PT0gJ2ZpcnN0Jykge1xuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmd0RGF0YS5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAodGhpcy5ndERhdGFbaV1bb2JqZWN0S2V5XSA9PT0gdmFsdWUpIHtcblx0XHRcdFx0XHRpZiAodGhpcy5pc1Jvd1NlbGVjdGVkKHRoaXMuZ3REYXRhW2ldKSkge1xuXHRcdFx0XHRcdFx0dGhpcy50b2dnbGVTZWxlY3QodGhpcy5ndERhdGFbaV0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLmd0RGF0YS5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdFx0dGhpcy5ndERhdGEgPSBbLi4udGhpcy5ndERhdGFdO1xuXHRcdFx0XHRcdGlmIChtYXRjaCA9PT0gJ2ZpcnN0Jykge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAobGV0IGkgPSB0aGlzLmd0RGF0YS5sZW5ndGg7IGkgPiAwOyBpLS0pIHtcblx0XHRcdFx0aWYgKHRoaXMuZ3REYXRhW2kgLSAxXVtvYmplY3RLZXldID09PSB2YWx1ZSkge1xuXHRcdFx0XHRcdGlmICh0aGlzLmlzUm93U2VsZWN0ZWQodGhpcy5ndERhdGFbaSAtIDFdKSkge1xuXHRcdFx0XHRcdFx0dGhpcy50b2dnbGVTZWxlY3QodGhpcy5ndERhdGFbaSAtIDFdKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5ndERhdGEuc3BsaWNlKGkgLSAxLCAxKTtcblx0XHRcdFx0XHR0aGlzLmd0RGF0YSA9IFsuLi50aGlzLmd0RGF0YV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIFsuLi50aGlzLmd0RGF0YV07XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlIHN0b3JlIHRvIGhvbGQgcHJldmlvdXNseSBsb2FkZWQgcmVjb3Jkcy5cblx0ICogQHBhcmFtIHJlY29yZHMgLSB0b3RhbCBudW1iZXIgb2YgcmVjb3JkcyBpbiBzdG9yZS5cblx0ICogQHBhcmFtIHBlclBhZ2UgLSBob3cgbWFueSByZWNvcmRzIHRvIHNob3cgcGVyIHBhZ2UuXG5cdCAqIEByZXR1cm5zIGEgbmVzdGVkIGFycmF5IHRvIGhvbGQgcmVjb3JkcyBwZXIgcGFnZS5cblx0ICovXG5cdHByaXZhdGUgY3JlYXRlU3RvcmUocmVjb3JkczogbnVtYmVyLCBwZXJQYWdlOiBudW1iZXIpOiBBcnJheTxBcnJheTxhbnk+PiB7XG5cdFx0Y29uc3Qgc3RvcmVzID0gTWF0aC5jZWlsKHJlY29yZHMgLyBwZXJQYWdlKTtcblx0XHRjb25zdCBzdG9yZTogQXJyYXk8QXJyYXk8YW55Pj4gPSBbXTtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHN0b3JlczsgaSsrKSB7XG5cdFx0XHRzdG9yZVtpXSA9IFtdO1xuXHRcdH1cblx0XHRyZXR1cm4gc3RvcmU7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlIHBsYWNlaG9sZGVycyBmb3Igcm93cyB3aGlsZSBsb2FkaW5nIGRhdGEgZnJvbSBiYWNrLWVuZC5cblx0ICogQHBhcmFtIHBlclBhZ2UgLSBob3cgbWFueSByZWNvcmRzIHRvIHNob3cgcGVyIHBhZ2UuXG5cdCAqIEByZXR1cm5zIGFuIGFycmF5IGNvbnRhaW5pbmcgZW1wdHkgcmVjb3JkcyB0byBiZSBwcmVzZW50ZWQgd2hpbGUgZmV0Y2hpbmcgcmVhbCBkYXRhLlxuXHQgKi9cblx0cHJpdmF0ZSBsb2FkaW5nQ29udGVudChwZXJQYWdlOiBudW1iZXIpIHtcblx0XHQvLyBjcmVhdGUgcm93IG9iamVjdFxuXHRcdGNvbnN0IHJvd09iamVjdDogT2JqZWN0ID0ge1xuXHRcdFx0JCRsb2FkaW5nOiB0cnVlXG5cdFx0fTtcblx0XHRsZXQgb3JkZXIgPSAwO1xuXG5cdFx0Ly8gc29ydCBzZXR0aW5ncyBieSBjb2x1bW4gb3JkZXJcblx0XHR0aGlzLl9ndFNldHRpbmdzLnNvcnQodGhpcy5nZXRDb2x1bW5PcmRlcik7XG5cblx0XHQvLyBsb29wIHRocm91Z2ggYWxsIHNldHRpbmdzIG9iamVjdHMuLi5cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2d0U2V0dGluZ3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdGNvbnN0IHNldHRpbmcgPSB0aGlzLl9ndFNldHRpbmdzW2ldO1xuXG5cdFx0XHQvLyAuLi5pZiBjb2x1bW4gaXMgdmlzaWJsZSBhbmQgZW5hYmxlZC4uLlxuXHRcdFx0aWYgKHNldHRpbmcudmlzaWJsZSAhPT0gZmFsc2UgJiYgc2V0dGluZy5lbmFibGVkICE9PSBmYWxzZSkge1xuXHRcdFx0XHQvLyAuLi5pZiBmaXJzdCBjb2x1bW4sIHNldCB2YWx1ZSB0byBsb2FkaW5nIHRleHQgb3RoZXJ3aXNlIGxlYXZlIGl0IGVtcHR5XG5cdFx0XHRcdGlmIChvcmRlciA9PT0gMCkge1xuXHRcdFx0XHRcdHJvd09iamVjdFtzZXR0aW5nLm9iamVjdEtleV0gPSB0aGlzLmd0VGV4dHMubG9hZGluZztcblx0XHRcdFx0XHR0aGlzLmxvYWRpbmdQcm9wZXJ0eSA9IHNldHRpbmcub2JqZWN0S2V5O1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJvd09iamVjdFtzZXR0aW5nLm9iamVjdEtleV0gPSAnJztcblx0XHRcdFx0fVxuXHRcdFx0XHRvcmRlcisrO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cm93T2JqZWN0W3NldHRpbmcub2JqZWN0S2V5XSA9ICcnO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIGNyZWF0ZSBjb250ZW50IHBsYWNlaG9sZGVyXG5cdFx0Y29uc3QgY29udGVudFBsYWNlaG9sZGVyOiBBcnJheTxhbnk+ID0gW107XG5cblx0XHQvLyBjcmVhdGUgZXF1YWwgbnVtYmVyIG9mIHJvd3MgYXMgcm93cyBwZXIgcGFnZVxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgcGVyUGFnZTsgaSsrKSB7XG5cdFx0XHQvLyAuLi5hZGQgdGVtcG9yYXJ5IHJvdyBvYmplY3Rcblx0XHRcdGNvbnRlbnRQbGFjZWhvbGRlci5wdXNoKHJvd09iamVjdCk7XG5cdFx0fVxuXHRcdHJldHVybiBjb250ZW50UGxhY2Vob2xkZXI7XG5cdH1cblxuXHQvLyBUT0RPOiBtb3ZlIHRvIGhlbHBlciBmdW5jdGlvbnNcblx0LyoqIFNvcnQgYnkgc29ydCBvcmRlciAqL1xuXHRwcml2YXRlIGdldFNvcnRPcmRlciA9IGZ1bmN0aW9uKGE6IEd0Q29uZmlnU2V0dGluZywgYjogR3RDb25maWdTZXR0aW5nKSB7XG5cdFx0aWYgKGEuc29ydE9yZGVyIDwgYi5zb3J0T3JkZXIpIHtcblx0XHRcdHJldHVybiAtMTtcblx0XHR9XG5cdFx0aWYgKGEuc29ydE9yZGVyID4gYi5zb3J0T3JkZXIgfHwgdHlwZW9mIGEuc29ydE9yZGVyID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0cmV0dXJuIDE7XG5cdFx0fVxuXHRcdHJldHVybiAwO1xuXHR9O1xuXG5cdC8vIFRPRE86IG1vdmUgdG8gaGVscGVyIGZ1bmN0aW9uc1xuXHQvKiogU29ydCBieSBjb2x1bW4gb3JkZXIgKi9cblx0cHJpdmF0ZSBnZXRDb2x1bW5PcmRlciA9IGZ1bmN0aW9uKGE6IEd0Q29uZmlnU2V0dGluZywgYjogR3RDb25maWdTZXR0aW5nKSB7XG5cdFx0aWYgKGEuY29sdW1uT3JkZXIgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cmV0dXJuIC0xO1xuXHRcdH1cblx0XHRpZiAoYS5jb2x1bW5PcmRlciA8IGIuY29sdW1uT3JkZXIpIHtcblx0XHRcdHJldHVybiAtMTtcblx0XHR9XG5cdFx0aWYgKGEuY29sdW1uT3JkZXIgPiBiLmNvbHVtbk9yZGVyKSB7XG5cdFx0XHRyZXR1cm4gMTtcblx0XHR9XG5cdFx0cmV0dXJuIDA7XG5cdH07XG5cblx0Ly8gVE9ETzogbW92ZSB0byBoZWxwZXIgZnVuY3Rpb25zXG5cdC8qKiBDcmVhdGUgYSBkZWVwIGNvcHkgb2YgZGF0YSAqL1xuXHRwcml2YXRlIGNsb25lRGVlcCA9IGZ1bmN0aW9uKG86IGFueSkge1xuXHRcdHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG8pKTtcblx0fTtcblxuXHQvKiogRXhwb3J0IGRhdGEgYXMgQ1NWXG5cdCAqIEBwYXJhbSBmaWxlTmFtZSAtIG9wdGlvbmFsIGZpbGUgbmFtZSAob3ZlcnJpZGVzIGRlZmF1bHQgZmlsZSBuYW1lKS5cblx0ICogQHBhcmFtIHVzZUJPTSAtIHVzZSBCT00gKGJ5dGUgb3JkZXIgbWFya2VyKS5cblx0ICovXG5cdHB1YmxpYyBleHBvcnRDU1YoZmlsZU5hbWU/OiBzdHJpbmcsIHVzZUJPTTogYm9vbGVhbiA9IGZhbHNlKSB7XG5cdFx0Y29uc3QgZGF0YSA9IHRoaXMuZGF0YS5leHBvcnREYXRhO1xuXHRcdGxldCBjc3YgPSAnJztcblx0XHRjb25zdCBCT00gPSAnXFx1RkVGRic7XG5cblx0XHQvLyBjc3YgZXhwb3J0IGhlYWRlcnNcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX2d0U2V0dGluZ3MubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmICh0aGlzLl9ndFNldHRpbmdzW2ldLmV4cG9ydCAhPT0gZmFsc2UpIHtcblx0XHRcdFx0Ly8gZ2V0IGZpZWxkIHNldHRpbmdzXG5cdFx0XHRcdGNvbnN0IGZpZWxkU2V0dGluZyA9IHRoaXMuZ2V0UHJvcGVydHkoXG5cdFx0XHRcdFx0dGhpcy5fZ3RGaWVsZHMsXG5cdFx0XHRcdFx0dGhpcy5fZ3RTZXR0aW5nc1tpXS5vYmplY3RLZXlcblx0XHRcdFx0KTtcblxuXHRcdFx0XHQvLyBnZXQgZXhwb3J0IHZhbHVlLCBpZiBleHBvcnRIZWFkZXIgc3RyaW5nIGlzIGRlZmluZWQgdXNlIGl0IG90aGVyd2lzZSByZXR1cm5zIG5hbWVcblx0XHRcdFx0Y29uc3QgZXhwb3J0VmFsdWU6IHN0cmluZyA9IGZpZWxkU2V0dGluZy5leHBvcnRIZWFkZXJcblx0XHRcdFx0XHQ/IGZpZWxkU2V0dGluZy5leHBvcnRIZWFkZXJcblx0XHRcdFx0XHQ6IGZpZWxkU2V0dGluZy5uYW1lO1xuXG5cdFx0XHRcdGNzdiArPSB0aGlzLmVzY2FwZUNTVkRlbGltaXRlcihleHBvcnRWYWx1ZSk7XG5cblx0XHRcdFx0Y3N2ICs9IHRoaXMuZ2V0UHJvcGVydHkodGhpcy5fZ3RGaWVsZHMsIHRoaXMuX2d0U2V0dGluZ3NbaV0ub2JqZWN0S2V5KVxuXHRcdFx0XHRcdC5uYW1lO1xuXG5cdFx0XHRcdGlmIChpIDwgdGhpcy5fZ3RTZXR0aW5ncy5sZW5ndGggLSAxKSB7XG5cdFx0XHRcdFx0Y3N2ICs9IHRoaXMuX2d0T3B0aW9ucy5jc3ZEZWxpbWl0ZXI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBjc3YgZXhwb3J0IGJvZHlcblx0XHRkYXRhLmZvckVhY2gocm93ID0+IHtcblx0XHRcdGNzdiArPSAnXFxuJztcblx0XHRcdGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fZ3RTZXR0aW5ncy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAodGhpcy5fZ3RTZXR0aW5nc1tpXS5leHBvcnQgIT09IGZhbHNlKSB7XG5cdFx0XHRcdFx0Ly8gZ2V0IGZpZWxkIHNldHRpbmdzXG5cdFx0XHRcdFx0Y29uc3QgZmllbGRTZXR0aW5nID0gdGhpcy5nZXRQcm9wZXJ0eShcblx0XHRcdFx0XHRcdHRoaXMuX2d0RmllbGRzLFxuXHRcdFx0XHRcdFx0dGhpcy5fZ3RTZXR0aW5nc1tpXS5vYmplY3RLZXlcblx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0Ly8gZ2V0IGV4cG9ydCB2YWx1ZSwgaWYgZXhwb3J0IGZ1bmN0aW9uIGlzIGRlZmluZWQgdXNlIGl0IG90aGVyd2lzZSBjaGVjayBmb3IgdmFsdWUgZnVuY3Rpb24gYW5kIGFzIGEgbGFzdCByZXNvcnQgZXhwb3J0IHJhdyBkYXRhXG5cdFx0XHRcdFx0Y29uc3QgZXhwb3J0VmFsdWU6IHN0cmluZyA9XG5cdFx0XHRcdFx0XHRmaWVsZFNldHRpbmcuZXhwb3J0ICYmIHR5cGVvZiBmaWVsZFNldHRpbmcuZXhwb3J0ID09PSAnZnVuY3Rpb24nXG5cdFx0XHRcdFx0XHRcdD8gZmllbGRTZXR0aW5nLmV4cG9ydChyb3cpXG5cdFx0XHRcdFx0XHRcdDogZmllbGRTZXR0aW5nLnZhbHVlICYmIHR5cGVvZiBmaWVsZFNldHRpbmcudmFsdWUgPT09ICdmdW5jdGlvbidcblx0XHRcdFx0XHRcdFx0XHQ/IGZpZWxkU2V0dGluZy52YWx1ZShyb3cpXG5cdFx0XHRcdFx0XHRcdFx0OiByb3dbdGhpcy5fZ3RTZXR0aW5nc1tpXS5vYmplY3RLZXldO1xuXG5cdFx0XHRcdFx0Y3N2ICs9IHRoaXMuZXNjYXBlQ1NWRGVsaW1pdGVyKGV4cG9ydFZhbHVlKTtcblxuXHRcdFx0XHRcdGlmIChpIDwgdGhpcy5fZ3RTZXR0aW5ncy5sZW5ndGggLSAxKSB7XG5cdFx0XHRcdFx0XHRjc3YgKz0gdGhpcy5fZ3RPcHRpb25zLmNzdkRlbGltaXRlcjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdGNvbnN0IGJsb2IgPSBuZXcgQmxvYihbKHVzZUJPTSA/IEJPTSA6ICcnKSArIGNzdl0sIHtcblx0XHRcdHR5cGU6ICd0ZXh0L2NzdjtjaGFyc2V0PXV0Zi04J1xuXHRcdH0pO1xuXG5cdFx0aWYgKHdpbmRvdy5uYXZpZ2F0b3IubXNTYXZlT3JPcGVuQmxvYikge1xuXHRcdFx0bmF2aWdhdG9yLm1zU2F2ZU9yT3BlbkJsb2IoXG5cdFx0XHRcdGJsb2IsXG5cdFx0XHRcdGZpbGVOYW1lID8gZmlsZU5hbWUgKyAnLmNzdicgOiB0aGlzLmd0VGV4dHMuY3N2RG93bmxvYWQgKyAnLmNzdidcblx0XHRcdCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbnN0IGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG5cdFx0XHRsaW5rLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cdFx0XHRkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGxpbmspO1xuXHRcdFx0aWYgKGxpbmsuZG93bmxvYWQgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRsaW5rLnNldEF0dHJpYnV0ZShcblx0XHRcdFx0XHQnaHJlZicsXG5cdFx0XHRcdFx0J2RhdGE6dGV4dC9jc3Y7Y2hhcnNldD11dGYtOCwnICtcblx0XHRcdFx0XHRcdGVuY29kZVVSSUNvbXBvbmVudCgodXNlQk9NID8gQk9NIDogJycpICsgY3N2KVxuXHRcdFx0XHQpOyAvLyBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpKTtcblx0XHRcdFx0bGluay5zZXRBdHRyaWJ1dGUoXG5cdFx0XHRcdFx0J2Rvd25sb2FkJyxcblx0XHRcdFx0XHRmaWxlTmFtZSA/IGZpbGVOYW1lICsgJy5jc3YnIDogdGhpcy5ndFRleHRzLmNzdkRvd25sb2FkICsgJy5jc3YnXG5cdFx0XHRcdCk7XG5cdFx0XHRcdGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQobGluayk7XG5cdFx0XHRcdGxpbmsuY2xpY2soKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNzdiA9ICdkYXRhOnRleHQvY3N2O2NoYXJzZXQ9dXRmLTgsJyArICh1c2VCT00gPyBCT00gOiAnJykgKyBjc3Y7XG5cdFx0XHRcdHdpbmRvdy5vcGVuKGVuY29kZVVSSUNvbXBvbmVudChjc3YpKTtcblx0XHRcdH1cblx0XHRcdGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQobGluayk7XG5cdFx0fVxuXG5cdFx0Ly8gZW1pdCBleHBvcnQgZXZlbnRcblx0XHR0aGlzLmd0RXZlbnQuZW1pdCh7XG5cdFx0XHRuYW1lOiAnZ3QtZXhwb3J0ZWQtY3N2Jyxcblx0XHRcdHZhbHVlOiBmaWxlTmFtZSA/IGZpbGVOYW1lIDogdGhpcy5ndFRleHRzLmNzdkRvd25sb2FkICsgJy5jc3YnXG5cdFx0fSk7XG5cdH1cblxuXHQvKiogUmV0dXJuIHByb3BlcnR5ICovXG5cdHByaXZhdGUgZ2V0UHJvcGVydHkgPSBmdW5jdGlvbihhcnJheTogQXJyYXk8YW55Piwga2V5OiBzdHJpbmcpIHtcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRpZiAoYXJyYXlbaV0ub2JqZWN0S2V5ID09PSBrZXkpIHtcblx0XHRcdFx0cmV0dXJuIGFycmF5W2ldO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHRwcml2YXRlIHJlc3RydWN0dXJlU29ydGluZyA9IGZ1bmN0aW9uKCkge1xuXHRcdC8qKiBDaGVjayBhbmQgc3RvcmUgc29ydCBvcmRlciB1cG9uIGluaXRpYWxpemF0aW9uLlxuXHRcdCAqICBUaGlzIGlzIGRvbmUgYnkgY2hlY2tpbmcgc29ydCBwcm9wZXJ0aWVzIGluIHRoZSBzZXR0aW5ncyBhcnJheSBvZiB0aGUgdGFibGUsIGlmIG5vIHNvcnRpbmcgaXMgZGVmaW5lZFxuXHRcdCAqICB3ZSdsbCBzb3J0IHRoZSBkYXRhIGJ5IHRoZSBmaXJzdCB2aXNpYmxlIGFuZCBlbmFibGVkIGNvbHVtbiBpbiB0aGUgdGFibGUoYXNjZW5kaW5nKS4gUGxlYXNlIG5vdGUgdGhhdCBhY3R1YWxseVxuXHRcdCAqICBzb3J0aW5nIGhhdmUgdG8gYmUgZG9uZSBzZXJ2ZXIgc2lkZSB3aGVuIGxhenkgbG9hZGluZyBkYXRhIGZvciBvYnZpb3VzIHJlYXNvbnMuICAqL1xuXHRcdC8vIGNyZWF0ZSBzb3J0aW5nIGFycmF5XG5cdFx0Y29uc3Qgc29ydGluZyA9IFtdO1xuXHRcdGlmICh0aGlzLl9ndFNldHRpbmdzKSB7XG5cdFx0XHQvLyAuLi5zb3J0IHNldHRpbmdzIGJ5IHNvcnQgb3JkZXJcblx0XHRcdHRoaXMuX2d0U2V0dGluZ3Muc29ydCh0aGlzLmdldFNvcnRPcmRlcik7XG5cblx0XHRcdC8vIC4uLmxvb3AgdGhyb3VnaCBzZXR0aW5nc1xuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9ndFNldHRpbmdzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGNvbnN0IHNldHRpbmcgPSB0aGlzLl9ndFNldHRpbmdzW2ldO1xuXG5cdFx0XHRcdC8vIC4uLmlmIHNvcnRlZCBhc2NlbmRpbmcuLi5cblx0XHRcdFx0aWYgKHNldHRpbmcuc29ydCA9PT0gJ2FzYycpIHtcblx0XHRcdFx0XHQvLyAuLi4gYWRkIHRvIHNvcnRpbmdcblx0XHRcdFx0XHRzb3J0aW5nLnB1c2goc2V0dGluZy5vYmplY3RLZXkpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHNldHRpbmcuc29ydCA9PT0gJ2Rlc2MnKSB7XG5cdFx0XHRcdFx0LyogLi4uZWxzZSBpZiBzb3J0ZWQgZGVzY2VuZGluZy4uLiAqLyAvLyAuLi4gYWRkIHRvIHNvcnRpbmdcblx0XHRcdFx0XHRzb3J0aW5nLnB1c2goJy0nICsgc2V0dGluZy5vYmplY3RLZXkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHQvLyAuLi5pZiBubyBzb3J0aW5nIGFwcGxpZWQuLi5cblx0XHRcdGlmIChzb3J0aW5nLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0XHRzb3J0aW5nLnB1c2goJyQkZ3RSb3dJZCcpO1xuXHRcdFx0XHQvKi8vIC4uLnNvcnQgc2V0dGluZ3MgYnkgY29sdW1uIG9yZGVyXG5cdFx0XHRcdHRoaXMuX2d0U2V0dGluZ3Muc29ydCh0aGlzLmdldENvbHVtbk9yZGVyKTtcblxuXHRcdFx0XHQvLyAuLi5sb29wIHRocm91Z2ggc2V0dGluZ3Ncblx0XHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9ndFNldHRpbmdzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0Y29uc3Qgc2V0dGluZyA9IHRoaXMuX2d0U2V0dGluZ3NbaV07XG5cblx0XHRcdFx0XHQvLyAuLi5pZiBjb2x1bW4gaXMgZW5hYmxlZCBhbmQgdmlzaWJsZS4uLlxuXHRcdFx0XHRcdGlmIChzZXR0aW5nLmVuYWJsZWQgIT09IGZhbHNlICYmIHNldHRpbmcudmlzaWJsZSAhPT0gZmFsc2UpIHtcblx0XHRcdFx0XHRcdC8vIC4uLmFkZCBmaXJzdCBtYXRjaCBhbmQgZXhpdCBmdW5jdGlvblxuXHRcdFx0XHRcdFx0dGhpcy5zb3J0T3JkZXIgPSBbdGhpcy5fZ3RTZXR0aW5nc1tpXS5vYmplY3RLZXldO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSovXG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuc29ydE9yZGVyLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0dGhpcy5zb3J0T3JkZXIgPSBzb3J0aW5nO1xuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogRXNjYXBlIGV4cG9ydCB2YWx1ZSB1c2luZyBkb3VibGUgcXVvdGVzIChcIikgaWYgZXhwb3J0IHZhbHVlIGNvbnRhaW5zIGRlbGltaXRlclxuXHQgKiBAcGFyYW0gdmFsdWUgVmFsdWUgdG8gYmUgZXNjYXBlZFxuXHQgKi9cblx0cHJpdmF0ZSBlc2NhcGVDU1ZEZWxpbWl0ZXIodmFsdWUpIHtcblx0XHRyZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJlxuXHRcdFx0dmFsdWUuaW5kZXhPZih0aGlzLl9ndE9wdGlvbnMuY3N2RGVsaW1pdGVyKSAhPT0gLTFcblx0XHRcdD8gJ1wiJyArIHZhbHVlICsgJ1wiJ1xuXHRcdFx0OiB2YWx1ZTtcblx0fVxuXG5cdG5nT25Jbml0KCkge1xuXHRcdC8vIGlmIG51bWJlciBvZiByb3cgdG8gZGlzcGxheSBmcm9tIHN0YXJ0IGlzIHNldCB0byBudWxsIG9yIDAuLi5cblx0XHRpZiAoIXRoaXMuZ3RPcHRpb25zLm51bWJlck9mUm93cykge1xuXHRcdFx0Ly8gLi4uY2hhbmdlIHJvdyBsZW5ndGhcblx0XHRcdHRoaXMuY2hhbmdlUm93TGVuZ3RoKHRoaXMuZ3RPcHRpb25zLm51bWJlck9mUm93cyk7XG5cdFx0fVxuXHRcdHRoaXMucmVzdHJ1Y3R1cmVTb3J0aW5nKCk7XG5cdH1cblxuXHQvKipcblx0ICogIEV4dGVuZCBvYmplY3QgZnVuY3Rpb24uXG5cdCAqL1xuXHRwcml2YXRlIGV4dGVuZCA9IGZ1bmN0aW9uKGE6IE9iamVjdCwgYjogT2JqZWN0KSB7XG5cdFx0Zm9yIChjb25zdCBrZXkgaW4gYikge1xuXHRcdFx0aWYgKGIuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuXHRcdFx0XHRhW2tleV0gPSBiW2tleV07XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBhO1xuXHR9O1xuXG5cdG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpIHtcblx0XHQvLyBpZiBndCB0ZXh0cyBoYXZlIGNoYW5nZWQuLi5cblx0XHRpZiAoY2hhbmdlc1snZ3RUZXh0cyddKSB7XG5cdFx0XHQvLyAuLi5leHRlbmQgZ3RPcHRpb25zIGRlZmF1bHQgdmFsdWVzIHdpdGggdmFsdWVzIHBhc3NlZCBpbnRvIGNvbXBvbmVudFxuXHRcdFx0dGhpcy5ndFRleHRzID0gPEd0VGV4dHM+dGhpcy5leHRlbmQodGhpcy5ndERlZmF1bHRUZXh0cywgdGhpcy5ndFRleHRzKTtcblx0XHR9XG5cblx0XHQvLyBpZiBsYXp5IGxvYWRpbmcgZGF0YSBhbmQgcGFnaW5nIGluZm9ybWF0aW9uIGlzIGF2YWlsYWJsZS4uLlxuXHRcdGlmICh0aGlzLmd0T3B0aW9ucy5sYXp5TG9hZCAmJiB0aGlzLmd0SW5mbykge1xuXHRcdFx0Ly8gLi4uY2FsY3VsYXRlIHRvdGFsIG51bWJlciBvZiBwYWdlc1xuXHRcdFx0dGhpcy5ndEluZm8ucGFnZVRvdGFsID0gTWF0aC5jZWlsKFxuXHRcdFx0XHR0aGlzLmd0SW5mby5yZWNvcmRzQWZ0ZXJTZWFyY2ggLyB0aGlzLmd0SW5mby5yZWNvcmRMZW5ndGhcblx0XHRcdCk7XG5cblx0XHRcdC8vIC4uLmRlY2xhcmUgc3RvcmUgcG9zaXRpb25cblx0XHRcdGNvbnN0IHN0b3JlUG9zaXRpb24gPSB0aGlzLmd0SW5mby5wYWdlQ3VycmVudCAtIDE7XG5cblx0XHRcdC8vIC4uLmFuZCBpZiBzdG9yZSBpcyBlbXB0eSBvciBwYWdlIGxlbmd0aCBoYXMgY2hhbmdlZC4uLlxuXHRcdFx0aWYgKFxuXHRcdFx0XHR0aGlzLnN0b3JlLmxlbmd0aCA9PT0gMCB8fFxuXHRcdFx0XHR0aGlzLnN0b3JlWzBdLmxlbmd0aCAhPT0gdGhpcy5ndEluZm8ucmVjb3JkTGVuZ3RoXG5cdFx0XHQpIHtcblx0XHRcdFx0Ly8gLi4uY3JlYXRlIHN0b3JlXG5cdFx0XHRcdHRoaXMuc3RvcmUgPSB0aGlzLmNyZWF0ZVN0b3JlKFxuXHRcdFx0XHRcdHRoaXMuZ3RJbmZvLnJlY29yZHNBZnRlclNlYXJjaCxcblx0XHRcdFx0XHR0aGlzLmd0SW5mby5yZWNvcmRMZW5ndGhcblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gLi4uc3RvcmUgcmV0cmlldmVkIGRhdGEgaW4gc3RvcmUgYXQgc3RvcmUgcG9zaXRpb25cblx0XHRcdHRoaXMuc3RvcmVbc3RvcmVQb3NpdGlvbl0gPSB0aGlzLmd0RGF0YTtcblx0XHRcdHRoaXMuZ3RJbmZvLnZpc2libGVSZWNvcmRzID0gWy4uLnRoaXMuZ3REYXRhXTsgLy8gYWRkIHZpc2libGUgcm93c1xuXG5cdFx0XHQvLyByZXBsYWNlIGRhdGEgd2l0aCBzdG9yZVxuXHRcdFx0dGhpcy5fZ3REYXRhID0gdGhpcy5zdG9yZTtcblx0XHRcdHRoaXMubG9hZGluZyA9IGZhbHNlO1xuXHRcdFx0dGhpcy51cGRhdGVSZWNvcmRSYW5nZSgpO1xuXHRcdFx0dGhpcy5ndEV2ZW50LmVtaXQoe1xuXHRcdFx0XHRuYW1lOiAnZ3QtaW5mbycsXG5cdFx0XHRcdHZhbHVlOiB0aGlzLmd0SW5mb1xuXHRcdFx0fSk7XG5cdFx0fSBlbHNlIGlmIChcblx0XHRcdHRoaXMuX2d0RGF0YSAmJlxuXHRcdFx0dGhpcy5fZ3REYXRhLmxlbmd0aCA+PSAwICYmXG5cdFx0XHRjaGFuZ2VzWydndERhdGEnXSAmJlxuXHRcdFx0Y2hhbmdlc1snZ3REYXRhJ10ucHJldmlvdXNWYWx1ZVxuXHRcdCkge1xuXHRcdFx0dGhpcy5sb2FkaW5nID0gZmFsc2U7XG5cdFx0fSBlbHNlIGlmIChcblx0XHRcdGNoYW5nZXNbJ2d0RGF0YSddICYmXG5cdFx0XHRjaGFuZ2VzWydndERhdGEnXS5maXJzdENoYW5nZSAmJlxuXHRcdFx0dGhpcy5fZ3REYXRhICYmXG5cdFx0XHR0aGlzLl9ndERhdGEubGVuZ3RoID4gMFxuXHRcdCkge1xuXHRcdFx0dGhpcy5sb2FkaW5nID0gZmFsc2U7XG5cdFx0fVxuXHR9XG5cblx0dHJhY2tCeUZuKGluZGV4OiBudW1iZXIsIGl0ZW06IEd0Um93KSB7XG5cdFx0cmV0dXJuIGl0ZW0uJCRndFJvd0lkO1xuXHR9XG5cblx0dHJhY2tCeUNvbHVtbkZuKGluZGV4OiBudW1iZXIsIGl0ZW06IEd0Q29uZmlnRmllbGQ8YW55LCBhbnk+KSB7XG5cdFx0cmV0dXJuIGl0ZW0ub2JqZWN0S2V5O1xuXHR9XG5cblx0bmdPbkRlc3Ryb3koKSB7XG5cdFx0Ly8gcmVtb3ZlIGxpc3RlbmVyXG5cdFx0dGhpcy5fc3RvcExpc3RlbmluZ0ZvcktleWRvd25FdmVudCgpO1xuXHR9XG59XG4iXX0=