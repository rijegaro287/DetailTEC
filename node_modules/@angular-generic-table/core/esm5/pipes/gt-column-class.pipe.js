/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
import { Pipe } from '@angular/core';
var GtColumnClassPipe = /** @class */ (function () {
    function GtColumnClassPipe() {
    }
    /**
     * @param {?} gtFields
     * @param {?} column
     * @param {?=} row
     * @return {?}
     */
    GtColumnClassPipe.prototype.transform = /**
     * @param {?} gtFields
     * @param {?} column
     * @param {?=} row
     * @return {?}
     */
    function (gtFields, column, row) {
        // find columns with columnClass property defined
        var /** @type {?} */ COLUMN_WITH_CLASS = gtFields
            .map(function (field) { return field; })
            .filter(function (field) { return field.columnClass && field.objectKey === column.objectKey; })[0];
        if (!COLUMN_WITH_CLASS) {
            return;
        }
        else if (typeof COLUMN_WITH_CLASS.columnClass === 'function') {
            // if column class is a function, try using the function...
            try {
                return COLUMN_WITH_CLASS.columnClass(row, column);
            }
            catch (/** @type {?} */ error) {
                console.log('Error when trying to get column class name using formula.', error);
            }
        }
        else {
            // if not a function, return plain string value
            return COLUMN_WITH_CLASS.columnClass;
        }
    };
    GtColumnClassPipe.decorators = [
        { type: Pipe, args: [{
                    name: 'gtColumnClass'
                },] },
    ];
    return GtColumnClassPipe;
}());
export { GtColumnClassPipe };
function GtColumnClassPipe_tsickle_Closure_declarations() {
    /** @type {!Array<{type: !Function, args: (undefined|!Array<?>)}>} */
    GtColumnClassPipe.decorators;
    /**
     * @nocollapse
     * @type {function(): !Array<(null|{type: ?, decorators: (undefined|!Array<{type: !Function, args: (undefined|!Array<?>)}>)})>}
     */
    GtColumnClassPipe.ctorParameters;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ3QtY29sdW1uLWNsYXNzLnBpcGUuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9AYW5ndWxhci1nZW5lcmljLXRhYmxlL2NvcmUvIiwic291cmNlcyI6WyJwaXBlcy9ndC1jb2x1bW4tY2xhc3MucGlwZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7O0FBQUEsT0FBTyxFQUFFLElBQUksRUFBaUIsTUFBTSxlQUFlLENBQUM7Ozs7Ozs7Ozs7SUFRbkQscUNBQVM7Ozs7OztJQUFULFVBQ0MsUUFBd0MsRUFDeEMsTUFBaUMsRUFDakMsR0FBVzs7UUFHWCxxQkFBTSxpQkFBaUIsR0FBRyxRQUFRO2FBQ2hDLEdBQUcsQ0FBQyxVQUFBLEtBQUssSUFBSSxPQUFBLEtBQUssRUFBTCxDQUFLLENBQUM7YUFDbkIsTUFBTSxDQUNOLFVBQUEsS0FBSyxJQUFJLE9BQUEsS0FBSyxDQUFDLFdBQVcsSUFBSSxLQUFLLENBQUMsU0FBUyxLQUFLLE1BQU0sQ0FBQyxTQUFTLEVBQXpELENBQXlELENBQ2xFLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDTixFQUFFLENBQUMsQ0FBQyxDQUFDLGlCQUFpQixDQUFDLENBQUMsQ0FBQztZQUN4QixNQUFNLENBQUM7U0FDUDtRQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQyxPQUFPLGlCQUFpQixDQUFDLFdBQVcsS0FBSyxVQUFVLENBQUMsQ0FBQyxDQUFDOztZQUVoRSxJQUFJLENBQUM7Z0JBQ0osTUFBTSxDQUFDLGlCQUFpQixDQUFDLFdBQVcsQ0FBQyxHQUFHLEVBQUUsTUFBTSxDQUFDLENBQUM7YUFDbEQ7WUFBQyxLQUFLLENBQUMsQ0FBQyxpQkFBQSxLQUFLLEVBQUUsQ0FBQztnQkFDaEIsT0FBTyxDQUFDLEdBQUcsQ0FDViwyREFBMkQsRUFDM0QsS0FBSyxDQUNMLENBQUM7YUFDRjtTQUNEO1FBQUMsSUFBSSxDQUFDLENBQUM7O1lBRVAsTUFBTSxDQUFDLGlCQUFpQixDQUFDLFdBQVcsQ0FBQztTQUNyQztLQUNEOztnQkEvQkQsSUFBSSxTQUFDO29CQUNMLElBQUksRUFBRSxlQUFlO2lCQUNyQjs7NEJBTkQ7O1NBT2EsaUJBQWlCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUGlwZSwgUGlwZVRyYW5zZm9ybSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgR3RDb25maWdGaWVsZCB9IGZyb20gJy4uL2ludGVyZmFjZXMvZ3QtY29uZmlnLWZpZWxkJztcbmltcG9ydCB7IEd0Um93IH0gZnJvbSAnLi4vaW50ZXJmYWNlcy9ndC1yb3cnO1xuXG5AUGlwZSh7XG5cdG5hbWU6ICdndENvbHVtbkNsYXNzJ1xufSlcbmV4cG9ydCBjbGFzcyBHdENvbHVtbkNsYXNzUGlwZSBpbXBsZW1lbnRzIFBpcGVUcmFuc2Zvcm0ge1xuXHR0cmFuc2Zvcm0oXG5cdFx0Z3RGaWVsZHM6IEFycmF5PEd0Q29uZmlnRmllbGQ8YW55LCBhbnk+Pixcblx0XHRjb2x1bW46IEd0Q29uZmlnRmllbGQ8R3RSb3csIGFueT4sXG5cdFx0cm93PzogR3RSb3dcblx0KTogYW55IHtcblx0XHQvLyBmaW5kIGNvbHVtbnMgd2l0aCBjb2x1bW5DbGFzcyBwcm9wZXJ0eSBkZWZpbmVkXG5cdFx0Y29uc3QgQ09MVU1OX1dJVEhfQ0xBU1MgPSBndEZpZWxkc1xuXHRcdFx0Lm1hcChmaWVsZCA9PiBmaWVsZClcblx0XHRcdC5maWx0ZXIoXG5cdFx0XHRcdGZpZWxkID0+IGZpZWxkLmNvbHVtbkNsYXNzICYmIGZpZWxkLm9iamVjdEtleSA9PT0gY29sdW1uLm9iamVjdEtleVxuXHRcdFx0KVswXTtcblx0XHRpZiAoIUNPTFVNTl9XSVRIX0NMQVNTKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fSBlbHNlIGlmICh0eXBlb2YgQ09MVU1OX1dJVEhfQ0xBU1MuY29sdW1uQ2xhc3MgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdC8vIGlmIGNvbHVtbiBjbGFzcyBpcyBhIGZ1bmN0aW9uLCB0cnkgdXNpbmcgdGhlIGZ1bmN0aW9uLi4uXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRyZXR1cm4gQ09MVU1OX1dJVEhfQ0xBU1MuY29sdW1uQ2xhc3Mocm93LCBjb2x1bW4pO1xuXHRcdFx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRcdFx0Y29uc29sZS5sb2coXG5cdFx0XHRcdFx0J0Vycm9yIHdoZW4gdHJ5aW5nIHRvIGdldCBjb2x1bW4gY2xhc3MgbmFtZSB1c2luZyBmb3JtdWxhLicsXG5cdFx0XHRcdFx0ZXJyb3Jcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gaWYgbm90IGEgZnVuY3Rpb24sIHJldHVybiBwbGFpbiBzdHJpbmcgdmFsdWVcblx0XHRcdHJldHVybiBDT0xVTU5fV0lUSF9DTEFTUy5jb2x1bW5DbGFzcztcblx0XHR9XG5cdH1cbn1cbiJdfQ==